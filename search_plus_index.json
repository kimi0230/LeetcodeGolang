{"./":{"url":"./","title":"Introduction","keywords":"","body":"Leetcode in Golang Leetcode, Codility , GeekforGeeks algorithms exercises written in Golang. https://kimi0230.github.io/LeetcodeGolang/ leetcode Content Leetcode in Golang leetcode Content Data Structure Array \\& String Matrix Linked List HashSet \\& HashMap Stack \\& Queue Heap \\& Priority Queue Heap 有幾個特色： heap sort Disjoint Set Union Trie Binary Indexed Tree Design Data Structures Algorithm Greedy Sort Multiple Pointers Backtracking (回溯法). DFS DFS \\& BFS Dynamic Programming Sliding Window Sweep Line Rolling Sum Two Pointers Bit Manipulation∂ Union Find Breadth First Search Binary Search Minimax Graph Graph Topological Sort Tree Tree Traversal Binary Search Tree Compputational Geometry Selected Topics Mathematics Random Bitwise Manipulation GeeksforGeeks Content Codility Content Reference Data Structure Array & String No. Title Solution Difficulty Time Space Topic 0001 Two Sum Go Easy O(n) O(n) Array 0003 Longest Substring Without Repeating Characters Go Medium O(n) O(1) Array, Sliding Window 0015 3 Sum Go Medium O(n^2) O(n) Array 0027 Remove Element Go Easy O(n) O(1) Array 0035 Search Insert Position Go Easy O(n), O(logn) O(1) Array 0049 Search Insert Position Go Medium O(kn) O(kn) Array 0059 Spiral Matrix II Go Medium O(n) O(n^2) Array 0088 Merge Sorted Array Go Easy O(n) O(1) Array 0217 0217.Contains Duplicate Go Easy O(n) O(n) Array 0242 0242.Valid Anagram Go Easy O(n) O(n) Array 0409 409. Longest Palindrome Go Easy O(n) O(1) Array 0380 0380.Insert Delete GetRandom O(1) Go Medium O(1) O(n) Array 0381 0381.Insert Delete GetRandom O(1) Duplicates allowed Go Medium O(1) O(n) Array 0412 0412.Fizz Buzz Go Easy O(n) O(n) Array, string 1195 1195.Fizz Buzz Multithreaded Go Medium O(n) Array, string,Concurrency 0238 238. Product of Array Except Self Go Medium O(n) Array, string, Prefix Sum 0128 128. Longest Consecutive Sequence Go Medium O(n) O(n) Array, Hash Table, Union Find Matrix Linked List No. Title Solution Difficulty Time Space Topic 0019 Remove Nth Node From End of List Go Medium O(n) O(1) Linked List, Two Pointers 0141 Linked List Cycle Go Easy O(n) O(1) Linked List, Two Pointers 0142 Linked List Cycle II Go Medium O(n) O(1) Linked List, Two Pointers 0203 Remove Linked List Elements Go Easy O(n) O(1) Linked List 0206 Reverse Linked List Go Easy O(n) O(1) Linked List 0876 Middle of the Linked List Go Easy Linked List, Two Pointers 0021 Merge Two Sorted Lists Go Easy O(log n) O(1) Linked List 0002 Add Two Number Go Medium O(max(m,n)) O(1) Linked List HashSet & HashMap Stack & Queue No. Title Solution Difficulty Time Space Topic 0020 Valid Parentheses Go Easy O(n) O(n) Stack 0094 Binary Tree Inorder Traversal Go Medium O(n) O(1) Stack Heap & Priority Queue Heap 總是能讓整棵樹當中最大或最小值維持在root節點上 Heap 有幾個特色： 常見架構是像 binary tree 那樣 保持 balanced max heap 的 root 是最大值；min heap 的 root 則是最小值 雖然是 tree，卻很適合放在 array 中處理 heap sort 根據定義 heap 的 root 一定是最大(假設是 max heap)，也就是說，無序數列經過 heapify 再作 n 次 root deletion 取出最大值，就可以得到排序的結果。 最後就得到 heap sort 的 worst case 時間複雜度 O(nlogn) 的結果。 可是 quick sort 的 worst case 時間複雜度是 O(n²)，怎麼 quick sort 的時間複雜度比較糟糕卻比較受歡迎？ google 的結果是說 heap sort 比較不利於 caching 對於 spatial locality 機制，蠻有道理的阿。 https://www.zhihu.com/question/23873747 https://rust-algo.club/sorting/heapsort/index.html No. Title Solution Difficulty Time Space Topic 0703 Kth Largest Element in a Stream Go Easy O(K + (N-K)logK) O(k) Heap, Priority Queue 1046 Last Stone Weight Go Easy O(nlogn) O(n) Heap, Priority Queue 0347 Top K Frequent Elements Go Medium O(Nlog⁡k) O(n) Heap, Priority Queue, Quick Sort Disjoint Set Union Trie Binary Indexed Tree Design Data Structures Algorithm Greedy Sort No. Title Solution Difficulty Time Space Topic 0075 Sort Colors Go Medium O(n) O(1) Sort 0215 Kth Largest Element in an Array Go Medium O(n) O(logn) Sort Multiple Pointers Backtracking (回溯法). DFS DFS. 解決一個回溯問題, 實際上就是一個決策樹的遍歷過程. 算是一個暴力的窮舉算法 路徑：也就是已經做出的選擇。 選擇列表：也就是你當前可以做的選擇。 結束條件：也就是到達決策樹底層，無法再做選擇的條件。 https://www.bilibili.com/video/BV1P5411N7Xc result = [] def backtrack(路徑, 選擇列表): if 滿足結束條件: result.add(路徑) return for 選擇 in 選擇列表: 做選擇(前序) backtrack(路徑, 選擇列表) 撤銷選擇(後序) No. Title Solution Difficulty Time Space Topic 0046 Permutations (全排列) Go Medium O(n) O(n) Backtracking 0078 Subsets Go Medium O(n^2) O(n) Backtracking DFS & BFS 找最短路徑用BFS, 其他時用DFS用得多一些, 因為遞迴較好寫 假設有棵滿的二叉樹,節點數為 N. 對DFS來說空間複雜度就是遞迴, 最壞的情況就是樹的高度 O(log N) BFS算法, Queue每次都會存二叉樹一層的節點, 最壞的情況下空間複雜度應該就是樹的最下層的數量, 也就是 N/2. 空間複雜度 O(N) DFS（深度優先搜索）通常使用堆棧（Stack）來實現。在DFS中，您首先處理一個節點，然後將其子節點按某種順序推入堆棧中，接著繼續處理堆棧頂部的節點，直到堆棧為空。 BFS（廣度優先搜索）則使用隊列（Queue）來實現。在BFS中，您首先處理一個節點，然後將其子節點按某種順序排隊，接著繼續處理隊列的前端節點，直到隊列為空。 No. Title Solution Difficulty Time Space Topic 0695 Max Area of Island Go Medium O(m*n) O(m*n) DFS & BFS 0733 Flood Fill Go Easy O(m*n) O(m*n) DFS & BFS Dynamic Programming 動態規劃問題的一般形式就是求最值, 最長遞增子序列, 最小編輯距離等. 核心問題是窮舉 重疊子問題 memory table DP table 最優子結構 狀態轉移方程式 這問題的 base case (最簡單情況) 是什麼? 這問題有什麼狀態 對於每個狀態, 可以做出什麼選擇, 使得狀態發生改變 如何定義 dp 數組/函數的含義來表現狀態和選擇? 替換 /跳過 dp[i-1][j-1] 刪除 dp[i-1][j] 插入 dp[i][j-1] dp[i][j] # 初始化 base case dp[0][0][...] = base # 進行狀態轉移 for 狀態1 in 狀態1的所有取值： for 狀態2 in 狀態2的所有取值： for ... dp[狀態1][狀態2][...] = 求最值(選擇1，選擇2...) No. Title Solution Difficulty Time Space Topic 0053 Maximum Subarray Go Easy O(n) O(n) Dynamic Programming 0072 0072. Edit Distance Go Hard Dynamic Programming 0300 Longest-Increasing-Subsequence Go Medium 方法一:O(n^2) 方法二:O(nlogn) O(n) Dynamic Programming 0322 Coin Change Go Medium O(nm) O(n) Dynamic Programming 0354 Russian Doll Envelope Go Hard Dynamic Programming 0509 Fibonacci Number Go Easy 很多解法 很多解法 Dynamic Programming 0070 0070.Climbing Stairs Go Easy O(n) O(n) Dynamic Programming 0746 0746.Min Cost Climbing Stairs Go Easy O(n) O(1) Dynamic Programming Sliding Window 維護一個窗口, 不斷滑動 void slidingWindow(string s, string t){ unordered mapneed, window; for (char c:t) need[c++] int left = 0 , right = 0 int valid = 0 // 先移動 right 再移動 left. 直到right到達 string的末端 while(right No. Title Solution Difficulty Time Space Topic 0209 Minimum Size Subarray Sum Go Medium O(n^2) / O(n) / O(nlog n) O(1) / O(1) / O(n) Sliding Window 0438 Find All Anagrams in a String Go Medium O(n) O(1) Sliding Window 0567 Permutation in String Go Medium O(n) O(1) Sliding Window Sweep Line Rolling Sum Two Pointers 只要array有序, 就應該想到雙指針技巧 分為兩類 1. \"快,慢指針\" 2. \"左,右指針\" 快,慢指針: 主要解決 linkedlist 問題, 典型的判斷 linkedlist 是否包含環 左,右指針: 主要解決array(或 string)中的問題, 如二分搜尋. https://labuladong.gitee.io/algo/2/21/57/ No. Title Solution Difficulty Time Space Topic 0019 Remove Nth Node From End of List Go Medium O(n) O(1) Linked List, Two Pointers 0141 Linked List Cycle Go Easy O(n) O(1) Linked List, Two Pointers 0283 Move Zeroes Go Easy O(n) O(1) Two Pointers 0142 Linked List Cycle II Go Medium O(n) O(1) Linked List, Two Pointers 0344 Reverse String Go Easy O(n) O(1) Two Pointers 0876 Middle of the Linked List Go Easy Linked List, Two Pointers 0011 Container With Most Water Go Medium Two Pointers 0074 Search a 2D Matrix Go Medium Binary Search, Two Pointers Bit Manipulation∂ No. Title Solution Difficulty Time Space Topic 0693 Binary Number with Alternating Bits Go Easy O(n)/ O(1) O(1) / O(1) Bit Manipulation Union Find No. Title Solution Difficulty Time Space Topic 0721 Accounts Merge Go Easy O(n) / O(n log n) O(n) / O(n) Union Find Breadth First Search DFS 算法可以被認為是回溯算法, BFS算法都是用Queue這種數據結構, 每次將一個截短周圍的所有節點加入Queue. BFS 找到的路徑一定是最短的, 但是代價是空間複雜度比DFS大. BFS vs DFS 優化: 雙向 BFS 優化, 在 while 開始時做一個判斷. 讓每次都選擇較小的集合進行擴散, 那麼佔用的空間增長速度就會慢一些, 盡可能以最小的空間代價產生 curDepth 和 nextDepth 的交集 無論單向的 BFS 或是 雙向BFS, 優化過的BFS 空間複雜度都是一樣的 // 計算從起點 start 到 終點 target 的最點距離 int BFS(Node start, Node targe){ Queue q; // 核心數據結構 Set visited; // 避免走回頭路 q.offer(start); // 將起點加入 Queue visited.add(start); int step = 0; // 紀錄擴散的步數 while(q not empty) { int sz = q.size(); // 當前 Queue 中的所有節點向四周擴散 for (int i = 0 ; i No. Title Solution Difficulty Time Space Topic 0310 Minimum Height Trees Go Medium Breadth First Search 0752 752. Open the Lock Go Medium Breadth First Search Binary Search 分析二分搜尋技巧: 不要出現 else, 而是把所有情況用 else if 寫清楚. 計算 mid 時需要防止溢出 int binarySearch(int[] nums, int target){ int left = 0 , right = ...; while(...) { int mid = left + (right - left)/2 if (nums[mid] == target){ ... } else if (nums[mid] target){ right = ... } } return ...; } 將搜尋區間全部統一成兩端都閉, 方便記憶 [letf,right] func Search(nums []int, target int) int { lenght := len(nums) if lenght target { // 找左邊 right = mid - 1 } } // 都沒找到 return -1 } // 有點類似 nums 小於 target的元素有幾個 func LeftBound(nums []int, target int) (index int) { lenght := len(nums) if lenght >1 mid := int(uint(right+left) >> 1) if nums[mid] == target { // 要繼續找左邊, 所以把右邊變小 right = mid - 1 } else if nums[mid] target { // 找左邊 right = mid - 1 } } // 都沒找到 注意: left越界情況 if left >= lenght || nums[left] != target { return -1 } return left } // 有點類似 nums 大於 target的元素有幾個 func RightBound(nums []int, target int) (index int) { lenght := len(nums) if lenght >1 mid := int(uint(right+left) >> 1) if nums[mid] == target { // 注意:要繼續找右邊, 所以把左邊變大=mid+1 left = mid + 1 } else if nums[mid] target { // 找左邊 right = mid - 1 } } // 都沒找到 注意:right越界情況 if right for left ： 此方法在迭代終止時，left 和 right 指針指向同一個位置。 此方法會包括最後一個可能的候選解，在某些情況下可能更容易理解和實現。 在應對邊界情況時可能更為方便，例如當 left 和 right 指向同一位置時，這時可能需要進一步處理。 for left ： 此方法在迭代終止時，left 和 right 指針指向相鄰位置。 此方法會排除最後一個可能的候選解，當要求嚴格小於或大於某個值時可能更合適。 在一些情況下，可能會更高效，因為在每次循環中只需要比較一次 left 和 right，而不需要再處理當兩者相等時的情況。 func search(nums []int, target int) int { left, right := 0, len(nums)-1 for left >1) if nums[mid]==target{ return mid }else if (nums[mid] No. Title Solution Difficulty Time Space Topic 0704 704. Binary Search Go Easy 最差:O(long n) 最佳O(1)剛好在中間 迭代: O(1) 遞迴O(log n) Binary Search 0875 875. Koko Eating Bananas Go Medium O（n log m） O(1) Binary Search 0153 153. Find Minimum in Rotated Sorted Array Go Medium O(log n） O(1) Binary Search 0033 33. Search in Rotated Sorted Array Go Medium O(log n） O(1) Binary Search 0034 34. Find First and Last Position of Element in Sorted Array Go Medium O(log n） O(1) Binary Search 0981 0981.Time Based Key-Value Store Go Medium O(log n） Binary Search Minimax Graph Graph Topological Sort Tree No. Title Solution Difficulty Time Space Topic 0226 Invert Binary Tree Go Easy O(n) O(1) Tree 0104 Maximum Depth of Binary Tree Go Easy O(n) O(1) Tree 0543 Diameter of Binary Tree Go Easy O(n) O(n), O(log(n)) Tree, DFS 0110 Balanced Binary Tree Go Easy O(n) O(1) Tree, DFS 0100 Same Tree Go Easy O(n) O(1) Tree 0105 Construct Binary Tree from Preorder and Inorder Traversal Go Medium O(n) O(n) Array Tree Traversal Binary Search Tree Compputational Geometry Selected Topics Mathematics Random Bitwise Manipulation GeeksforGeeks Content Topic Title No. Solution Difficulty TimeComplexity SpaceComplexity Sorting Find Minimum Difference Between Any Two Elements 0031 Go Basic O(n^2), O(n log n) O(n), O(n) Codility Content Topic Title Solution Difficulty TimeComplexity SpaceComplexity Lesson 1 Iterations Binary Gap Go Painless O(log n) O(1) Lesson 2 Array Cyclic Rotation Go Painless O(1) O(1) Odd Occurrences In Array Go Painless O(n), O(n) O(n), O(1) Lesson 3 Time Complexity Frog Jmp Go Painless O(1) O(1) Perm Missing Elem Go Painless O(n) O(1) Tape Equilibrium Go Painless O(n) O(n) Lesson 4 Counting Elements Frog River One Go Painless O(n) O(n) Max Counters Go Respectable O(n+m) O(n) Missing Integer Go Respectable O(n) O(n) Perm Check Go Painless O(n) O(n) Lesson 5 Prefix Sums Count Div Go Respectable O(1) O(1) Genomic Range Query Go Respectable O(n+m) O(n) MinAvg Two Slice Go Respectable O(n) O(n) Passing Cars Go Painless O(n) O(1) Lesson 6 Sorting Distinct Go Painless O(nlogn) O(n) Max Product of Three Go Painless O(nlogn) O(1) Number Of Disc Intersections Go Respectable O(nlogn) O(n) Triangle Go Painless O(nlogn) O(n) Lesson 7 Stacks and Queues Brackets Go Painless O(n) O(n) Fish Go Painless O(n) O(n) Nesting Go Painless O(n) O(1) Stone Wall Go Painless O(n) O(n) Lesson 8 Leader Dominator Go Painless O(n) O(1) EquiLeader Go Painless O(n) O(n) Lesson 9 Maximum slice problem Max Profit Go Painless O(n) O(1) Max Slice Sum Go Painless O(n) O(n) Max Double Slice Sum Go Respectable O(n) O(n) Lesson 10 Prime and composite numbers Count Factors Go Painless O(sqrt(n)) O(1) Flags Go Respectable O(n) O(n) MinPerimeterRectangle Go Painless O(sqrt(n))) O(1) Peaks Go Respectable O( n*log( log(n) )) O(n) Lesson 11 Sieve of Eratosthenes (質數篩) Count Non Divisible Go Respectable O(N * log(N)) O(n) Count Semiprimes Go Respectable O(N*log(log(N))+M) O(N+M) Lesson 12 Euclidean algorithm (輾轉相除法 or 歐幾里得算法) Chocolates By Numbers Go Painless O(log(N + M)) O(1) Common Prime Divisors Go Respectable O(Z * log(max(A) + max(B))**2) O(1) Lesson 13 Fibonacci numbers FibFrog Go Respectable O(N * log(N)) O(N) Ladder Respectable Lesson 14 Binary search algorithm MinMaxDivision Respectable NailingPlanks Respectable Lesson 15 Caterpillar method AbsDistinct Painless CountDistinctSlices Painless CountTriangles Painless MinAbsSumOfTwo Respectable Lesson 16 Greedy algorithms MaxNonoverlappingSegments Painless TieRopes Painless Lesson 17 Dynamic programming MinAbsSum Ambitious NumberSolitaire Respectable Reference leetcode leetcode-cn halfrost anakin wufenggirl GeeksforGeeks Codility GitHub: labuladong/fucking-algorithm(labuladong 算法小抄) https://cses.fi/ https://github.com/neetcode-gh/leetcode © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Algorithms/A1B2C3/":{"url":"Algorithms/A1B2C3/","title":"A1B2C3: Two Go Routine Print A1B2C3....Z26","summary":"Two Go Routine Print A1B2C3....Z26","keywords":"","body":"A1B2C3 tagsstart Algorithm Golang A1B2C3 tagsstop 用兩個 go routine 印出 A1B2C3....Z26 Two Go Routine Print A1B2C3....Z26 Channle With Buffer func ChannelWBuffer() { abc := make(chan struct{}, 1) num := make(chan struct{}, 1) done := make(chan struct{}) abc Channel Without Buffer func ChannelWOBuffer() { abc := make(chan struct{}) num := make(chan struct{}) done := make(chan struct{}) go func() { for i := 65; i Wait Group func WGLock() { abcMux := sync.Mutex{} numMux := sync.Mutex{} numMux.Lock() wg := sync.WaitGroup{} wg.Add(2) go func() { defer wg.Done() for i := 65; i Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Algorithms/A1B2C3 cpu: Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz BenchmarkChannelWBuffer-4 79159 14612 ns/op 344 B/op 5 allocs/op BenchmarkChannelWOBuffer-4 83068 14451 ns/op 344 B/op 5 allocs/op BenchmarkWGLock-4 51303 23072 ns/op 96 B/op 5 allocs/op PASS ok LeetcodeGolang/Algorithms/A1B2C3 4.092s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Algorithms/Find_Target_Last_Index/findtargetlastindex.html":{"url":"Algorithms/Find_Target_Last_Index/findtargetlastindex.html","title":"Find Target Last Index","summary":"在有序的array中 找出target在array中最後的index是什麼","keywords":"","body":"Find Target Last Index tagsstart Interview Algorithms Go Easy Find Target Last Index Right Bound Left Bound tagsstop 在有序的array中 找出target在array中最後的index是什麼 用二分搜尋法去找, RightBound 可參考 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0704.Binary-Search/main.go 方法一 func Solution(nums []int, target int) int { left, right := 0, len(nums)-1 result := -1 for left > 1) if nums[mid] == target { // 繼續找, 縮小右邊 if target == nums[right] { result = right break } else { right-- } } else if nums[mid] target { // 往左找 right = mid - 1 } } return result } 方法二 遞迴 func SolutionRecursive(nums []int, target int) int { left, right := 0, len(nums)-1 return findTarget(nums, left, right, target) } func findTarget(nums []int, left, right, target int) int { if left > right { return -1 } mid := int(uint(left+right) >> 1) if nums[mid] == target { if nums[right] == target { return right } else { return findTarget(nums, mid, right-1, target) } } else if nums[mid] go test -benchmem -run=none LeetcodeGolang/Algorithms/Find_Target_Last_Index -bench=. goos: darwin goarch: amd64 pkg: LeetcodeGolang/Algorithms/Find_Target_Last_Index cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkSolution-8 54216429 24.75 ns/op 0 B/op 0 allocs/op BenchmarkSolutionRecursive-8 40756744 27.75 ns/op 0 B/op 0 allocs/op PASS ok LeetcodeGolang/Algorithms/Find_Target_Last_Index 2.537s RightBound // 有點類似 nums 大於 target的元素有幾個 func RightBound(nums []int, target int) (index int) { lenght := len(nums) if lenght >1 mid := int(uint(right+left) >> 1) if nums[mid] == target { // 注意:要繼續找右邊, 所以把左邊變大=mid+1 left = mid + 1 } else if nums[mid] target { // 找左邊 right = mid - 1 } } // 都沒找到 注意:right越界情況 if right LeftBound // 有點類似 nums 小於 target的元素有幾個 func LeftBound(nums []int, target int) (index int) { lenght := len(nums) if lenght >1 mid := int(uint(right+left) >> 1) if nums[mid] == target { // 要繼續找左邊, 所以把右邊變小 right = mid - 1 } else if nums[mid] target { // 找左邊 right = mid - 1 } } // 都沒找到 注意: left越界情況 if left >= lenght || nums[left] != target { return -1 } return left } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Algorithms/Intersection-of-Two-Sorted-Arrays-using-In-Place-Approach/":{"url":"Algorithms/Intersection-of-Two-Sorted-Arrays-using-In-Place-Approach/","title":"Intersection Of Two Sorted Arrays Using In Place Approach","summary":"","keywords":"","body":"Intersection of Two Sorted Arrays using In Place Approach tagsstart Golang Algorithms Intersection tagsstop Intersection of Two Sorted Arrays using In Place Approach 要在原地（in-place）解決這個問題，可以使用雙指針的方法。假設給定的兩個數組分別為A和B，它們已經按升序排序。 首先，我們可以初始化兩個指針i和j分別指向A和B的起始位置，然後開始進行比較。如果A[i]小於B[j]，則移動指針i向後移動一位；如果A[i]大於B[j]，則移動指針j向後移動一位；如果A[i]等於B[j]，則將該值添加到結果中，並將兩個指針都向後移動一位。 重複上述步驟，直到其中一個數組的指針達到數組末尾為止。最終，得到的結果就是兩個數組的交集。 package intersection func FindIntersection(A, B []int) []int { var i, j int = 0, 0 result := []int{} for i B[j] { j++ } else { result = append(result, A[i]) i++ j++ } } return result } func TestFindIntersection(t *testing.T) { var tests = []struct { arg1 []int arg2 []int want []int }{ { arg1: []int{1, 3, 4, 6, 7}, arg2: []int{2, 4, 6, 8, 9}, want: []int{4, 6}, }, } for _, tt := range tests { if got := FindIntersection(tt.arg1, tt.arg2); !reflect.DeepEqual(got, tt.want) { t.Errorf(\"got = %v, want = %v\", got, tt.want) } } } TODO: 延伸 349. Intersection of Two Arrays (easy) 350. Intersection of Two Arrays II © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Algorithms/SearchGraph/":{"url":"Algorithms/SearchGraph/","title":"Search Graph In Golang","summary":"","keywords":"","body":"Search Graph tagsstart Golang Algorithms Search Graph BFS tagsstop 2 / \\ / \\ 1 - 3 - 5 - 7 \\ / \\ 6 \\ / 4 一個Graph,隨便指定一個起點, 優先print出周圍的值 // 1 -> [2, 3, 4] // 2 -> [1, 5] // 3 -> [1, 5] // 4 -> [1, 6] // 5 -> [2, 3, 7] // 6 -> [4, 7] // 7 -> [5, 6] // print : 1,2,3,4,5,6,7 // Also this is valid : 1,4,3,2,6,5,7 例如 開始位置1, print : 1,2,3,4,5,6, 解法 用BFS(Queue) 時間複雜度是O(V+E)，其中V是圖中節點的數量，E是圖中邊的數量 解答 package searchgraph import ( \"LeetcodeGolang/Utility/crud\" \"LeetcodeGolang/structures\" \"fmt\" \"strconv\" jsoniter \"github.com/json-iterator/go\" ) func fetchNeighbours(node int) []int { crud := crud.NewCrud(\"https://hackbear.tv/graph/\" + strconv.Itoa(node)) var result = []int{} if got := crud.Get(); got.Error != nil { // fmt.Printf(\"got = %v\", got) } else { var json = jsoniter.ConfigCompatibleWithStandardLibrary json.Unmarshal([]byte(got.Response), &result) } return result } /* 2 / \\ / \\ 1 - 3 - 5 - 7 \\ / \\ 6 \\ / 4 */ // 1 -> [2, 3, 4] // 2 -> [1, 5] // 3 -> [1, 5] // 4 -> [1, 6] // 5 -> [2, 3, 7] // 6 -> [4, 7] // 7 -> [5, 6] // print : 1,2,3,4,5,6,7 // Also this is valid : 1,4,3,2,6,5,7 // You will be working on this part /* 時間複雜度是O(V+E)，其中V是圖中節點的數量，E是圖中邊的數量 */ func SearchGraph(start int) { queue := structures.NewQueue() queue.Push(start) visit := make(map[int][]int) for queue.Len() > 0 { node := queue.Pop() if _, ok := visit[node]; !ok { fmt.Printf(\"%d \", node) neighours := fetchNeighbours(node) visit[node] = neighours for _, neighour := range neighours { if _, ok := visit[neighour]; !ok { queue.Push(neighour) } } } } } func SearchGraph2(start int) { queue := structures.NewQueue() queue.Push(start) visited := make(map[int]bool) for queue.Len() > 0 { node := queue.Pop() if !visited[node] { fmt.Printf(\"%d \", node) visited[node] = true neighbors := fetchNeighbours(node) for _, neighbor := range neighbors { if !visited[neighbor] { queue.Push(neighbor) } } } } } Reference https://www.youtube.com/watch?v=BkszA-MvjXA https://web.ntnu.edu.tw/~algo/Graph.html © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Algorithms/WeightedEditDistance/":{"url":"Algorithms/WeightedEditDistance/","title":"Weighted Edit Distance","summary":"","keywords":"","body":"WeightedEditDistance tagsstart Golang WeightedEditDistance Dynamic Programming tagsstop WeightedEditDistance 是一個計算帶有權重的編輯距離的函式。編輯距離是衡量兩個字串之間的相似度的指標，表示將一個字串轉換為另一個字串所需的最小操作數量。 在標準的編輯距離算法中，操作包括插入、刪除和替換字符。每個操作都被認為具有相同的代價。然而，在 WeightedEditDistance 中，每個字符的操作代價可以不同，並由一個權重映射表指定。 函式 WeightedEditDistance 接受兩個字符串 word1 和 word2，以及一個權重映射表 weights。該映射表將每個字符映射到其相應的權重值，用於計算操作的代價。 該函式使用動態規劃的方法計算編輯距離。它創建一個二維矩陣 dp，其中 dp[i][j] 表示將 word1[:i] 轉換為 word2[:j] 的最小操作代價。 算法的核心是遍歷 dp 矩陣並計算每個單元格的值。如果 word1[i-1] 等於 word2[j-1]，則表示兩個字符相等，不需要進行操作，所以 dp[i][j] 等於 dp[i-1][j-1]。否則，需要考慮插入、刪除和替換操作的代價，並取其中最小的作為 dp[i][j] 的值。 最終，函式返回 dp[m][n]，其中 m 和 n 分別為 word1 和 word2 的長度，表示將整個字串 word1 轉換為 word2 的最小操作代價。 使用 WeightedEditDistance 函式，您可以根據字符的權重值計算帶有自定義操作代價的編輯距離，以更好地反映兩個字串之間的相似性。 題目大意 weightededitdistance 雖然不是一個特定的LeetCode問題，但它涉及到一個概念：加權編輯距離（Weighted Edit Distance）。 加權編輯距離是指在兩個字串之間進行編輯操作（插入、刪除、替換）時，每個操作具有不同的成本或權重。該問題要求計算從一個字串轉換到另一個字串的最小總成本或權重。 解題思路 解決加權編輯距離問題的常用方法是使用動態規劃（Dynamic Programming）。 創建一個二維數組dp，其中dp[i][j]表示將字串1的前i個字符轉換為字串2的前j個字符的最小加權編輯距離。 初始化dp矩陣的第一行和第一列，分別表示將空字串轉換為字串1和字串2的成本，根據具體問題設置初始值。 遍歷dp矩陣，計算每個dp[i][j]的值，根據以下三種情況進行選擇： 如果字串1的第i個字符等於字串2的第j個字符，則dp[i][j]等於dp[i-1][j-1]，即不需要進行編輯操作，繼承前一個狀態的編輯距離。 否則，dp[i][j]等於插入操作的成本加上dp[i][j-1]，刪除操作的成本加上dp[i-1][j]，替換操作的成本加上dp[i-1][j-1]，取這三種操作的最小值。 最終，dp[m][n]（其中m和n分別為兩個字串的長度）即為兩個字串的最小加權編輯距離。 替換 /跳過 dp[i-1][j-1] 刪除 dp[i-1][j] 插入 dp[i][j-1] dp[i][j] 時間複雜度: 動態規劃的遍歷過程需要計算和填充dp矩陣的每個元素，因此時間複雜度為O(m*n)，其中m和n分別為兩個字串的長度。 空間複雜度: 需要使用一個二維數組dp來保存中間結果，因此空間複雜度為O(m*n)。 解答 package weightededitdistance import \"fmt\" func WeightedEditDistance(word1, word2 string, weights map[rune]int) int { m, n := len(word1), len(word2) // 創建二維矩陣用於保存編輯距離 // dp，其中 dp[i][j] 表示將 word1[:i] 轉換為 word2[:j] 的最小操作代價 dp := make([][]int, m+1) for i := 0; i 相關 0072.Edit-Distance © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"CodeSignal/":{"url":"CodeSignal/","title":"Code Signal","keywords":"","body":"Code Signal Reference https://app.codesignal.com/arcade/intro/level-1 https://github.com/abrar-abu/golanee/main https://github.com/crusty0gphr/bank-request-processor https://github.com/abrar-mahedavi/challenges/tree/main © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"CodeSignal/Bank-Requests/":{"url":"CodeSignal/Bank-Requests/","title":"Bank Requests","summary":"Bank Requests","keywords":"","body":"Bank Requests tagsstart CodeSignal Go Bank Requests tagsstop A solution to one of my coding interview questions. Complete solution - written in GoLang Task: You've been asked to program a bot for a popular bank that will automate the management of incoming requests. There are three types of requests the bank can receive: transfer i j sum: request to transfer sum amount of money from the i-th account to the j-th one deposit i sum: request to deposit sum amount of money in the i-th account withdraw i sum: request to withdraw sum amount of money from the i-th account. Your bot should also be able to process invalid requests. There are two types of invalid requests: invalid account number in the requests; deposit / withdrawal of a larger amount of money than is currently available. For the given list of accounts and requests, return the state of accounts after all requests have been processed, or an array of a single element [- ] (please note the minus sign), where is the 1-based index of the first invalid request. Example for accounts = [10, 100, 20, 50, 30] and requests = [\"withdraw 2 10\", \"transfer 5 1 20\", \"deposit 5 20\", \"transfer 3 4 15\"], the output should be bankRequests(accounts, requests) = [30, 90, 5, 65, 30]. accounts = [10, 100, 20, 50, 30] : 代表 ID:1 有10元, ID:2 有100元 ... \"withdraw 2 10\" : 從ID:2 提領 10元, 所以100-10 最後得到accounts= [10, 90, 20, 50, 30] Here are the states of accounts after each request: \"withdraw 2 10\": [10, 90, 20, 50, 30] \"transfer 5 1 20\": [30, 90, 20, 50, 10] \"deposit 5 20\": [30, 90, 20, 50, 30] \"transfer 3 4 15\": [30, 90, 5, 65, 30], which is the answer For accounts = [20, 1000, 500, 40, 90] and requests = [\"deposit 3 400\", \"transfer 1 2 30\", \"withdraw 4 50\"], the output should be bankRequests(accounts, requests) = [-2]. After the first request, accounts becomes equal to [20, 1000, 900, 40, 90], but the second one turns it into [-10, 1030, 900, 40, 90], which is invalid. Thus, the second request is invalid, and the answer is [-2]. Note that the last request is also invalid, but it shouldn't be included in the answer. 中文意思: 你被要求為一家知名銀行編寫一個機器人，該機器人將自動處理來自客戶的請求。銀行可能會收到三種類型的請求： transfer i j sum：從第i個帳戶轉移sum金額到第j個帳戶的請求 deposit i sum：向第i個帳戶存入sum金額的請求 withdraw i sum：從第i個帳戶提取sum金額的請求。 你的機器人還應該能夠處理無效的請求。無效的請求有兩種類型：請求中的帳戶號碼無效；存款/提款金額大於當前可用金額。 對於給定的帳戶列表和請求，返回處理完所有請求後的帳戶狀態，或單一元素為[- ]的數組（請注意負號），其中 是第一個無效請求的從1開始的索引。 以accounts = [10, 100, 20, 50, 30] 和 requests = [\"withdraw 2 10\", \"transfer 5 1 20\", \"deposit 5 20\", \"transfer 3 4 15\"] 為例，輸出應為 bankRequests(accounts, requests) = [30, 90, 5, 65, 30]。 accounts = [10, 100, 20, 50, 30] 代表：ID:1 有10元, ID:2 有100元 ... \"withdraw 2 10\" 從ID:2 提領 10元，所以100-10 最後得到accounts= [10, 90, 20, 50, 30] 這是每個請求後帳戶的狀態： \"withdraw 2 10\": [10, 90, 20, 50, 30] \"transfer 5 1 20\": [30, 90, 20, 50, 10] \"deposit 5 20\": [30, 90, 20, 50, 30] \"transfer 3 4 15\": [30, 90, 5, 65, 30]，這是答案 對於accounts = [20, 1000, 500, 40, 90] 和 requests = [\"deposit 3 400\", \"transfer 1 2 30\", \"withdraw 4 50\"]，輸出應為 bankRequests(accounts, requests) = [-2]。 第一個請求後，帳戶變成 [20, 1000, 900, 40, 90]，但第二個請求將其變為 [-10, 1030, 900, 40, 90]，這是無效的。因此，第二個請求無效，答案為[-2]。請注意最後一個請求也是無效的，但不應包含在答案中。 解答 package bankrequests import ( \"errors\" \"fmt\" \"regexp\" \"strconv\" \"strings\" \"sync\" ) var ( errInvaldTransfer = errors.New(\"invalid transfer\") errInvaldWithdraw = errors.New(\"invalid withdraw\") errInvaldDeposit = errors.New(\"invalid deposit\") errUnknownAction = errors.New(\"unknown action\") ) var requestScheme = [][]string{ 3: {\"action\", \"from\", \"amount\"}, 4: {\"action\", \"from\", \"to\", \"amount\"}, } type BankService interface { getActionName() string transfer() error withdraw() error deposit() error } type Bank struct { BankService action string requestId int from int to int amount int balances []int requestFailed bool failedRequest []int mutex sync.RWMutex } func (bank *Bank) getActionName() string { return bank.action } func (bank *Bank) transfer() error { bank.mutex.Lock() defer bank.mutex.Unlock() invalidAmout := bank.balances[bank.from-1] ]`的數組（請注意負號） func (bank *Bank) failedAction() { bank.mutex.Lock() defer bank.mutex.Unlock() failed := []int{-bank.requestId} bank.balances = []int{} bank.requestFailed = true bank.failedRequest = failed } func (bank *Bank) Action() { var requestErr error action := bank.getActionName() // fmt.Println(\"action:\", action) switch action { case \"transfer\": requestErr = bank.transfer() case \"withdraw\": requestErr = bank.withdraw() case \"deposit\": requestErr = bank.deposit() default: requestErr = errUnknownAction } if requestErr != nil { fmt.Println(\"requestErr:\", requestErr) bank.failedAction() } } func extractRequestParams(request string) map[string]interface{} { res := map[string]interface{}{} reqSlice := strToSlice(request) fmt.Println(\"reqSlice:\", reqSlice) // len is 3: {\"action\", \"from\", \"amount\"}, // len is 4: {\"action\", \"from\", \"to\", \"amount\"}, scheme := requestScheme[len(reqSlice)] for i, v := range scheme { res[v] = reqSlice[i] } return res } func strToSlice(str string) []interface{} { var res []interface{} erp := strings.Fields(str) re, err := regexp.Compile(\"[0-9]+\") if err != nil { fmt.Println(\"Error compiling regex:\", err) return nil } for _, v := range erp { if isNum := re.MatchString(v); isNum { if n, _ := strconv.Atoi(v); n != 0 { res = append(res, n) } } else { res = append(res, v) } } return res } func bankRequests(requests []string, balances []int) []int { var res []int for index, request := range requests { reqParams := extractRequestParams(request) bank := NewBank() bank.requestId = index + 1 bank.action = reqParams[\"action\"].(string) bank.amount = reqParams[\"amount\"].(int) bank.from = reqParams[\"from\"].(int) if _, ok := reqParams[\"to\"]; ok { bank.to = reqParams[\"to\"].(int) } bank.balances = balances bank.Action() if bank.requestFailed { return bank.failedRequest } res = bank.balances } return res } unit test package bankrequests import ( \"reflect\" \"testing\" ) var tests = []struct { arg1 []string arg2 []int want []int }{ { []string{ \"transfer 1 4 10\", \"deposit 3 10\", \"withdraw 5 15\", }, []int{20, 30, 10, 90, 60}, []int{10, 30, 20, 100, 45}, }, { []string{ \"transfer 1 4 40\", \"deposit 3 10\", \"withdraw 5 65\", }, []int{20, 30, 10, 90, 60}, []int{-1}, }, { []string{ \"withdraw 2 10\", \"transfer 5 1 20\", \"deposit 5 20\", \"transfer 3 4 15\", }, []int{10, 100, 20, 50, 30}, []int{30, 90, 5, 65, 30}, }, { []string{ \"deposit 3 400\", \"transfer 1 2 30\", \"withdraw 4 50\", }, []int{20, 1000, 500, 40, 90}, []int{-2}, }, } func TestBankRequests(t *testing.T) { for _, tt := range tests { if got := bankRequests(tt.arg1, tt.arg2); !reflect.DeepEqual(got, tt.want) { t.Errorf(\"got = %v, want = %v\", got, tt.want) } } } Reference https://github.com/crusty0gphr/bank-request-processor/tree/master © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0001.Iterations/Binary-Gap/":{"url":"Codility/Lesson/0001.Iterations/Binary-Gap/","title":"Binary Gap","summary":"Binary Gap","keywords":"","body":"BinaryGap tagsstart Codility Go Iterations Painless Bitwise Manipulation tagsstop START Find longest sequence of zeros in binary representation of an integer. 題目 A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N. For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps. Write a function: func Solution(N int) int that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn't contain a binary gap. For example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation '100000' and thus no binary gaps. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..2,147,483,647]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 輸入正整數, 找出此數在二進位,兩個bit值為1中裡面隔著最多0的長度 解題思路 先找出bit 1的位子, 再開始算中間最長的長度 解題思路通常可以使用位運算來處理二進制數字。我們可以將N轉換為二進制表示，然後使用遍歷或迴圈來找到相鄰1之間的最大距離。可以使用兩個指針來記錄相鄰的1的 時間複雜度: 解題思路中的遍歷或迴圈需要將N轉換為二進制，因此時間複雜度取決於二進制表示的位數。假設N的位數為k，則時間複雜度為O(k)。 空間複雜度: 解題思路中不需要使用額外的數據結構，只需要使用幾個變數來保存位置和計算結果，因此空間複雜度為O(1)。 來源 https://app.codility.com/programmers/lessons/1-iterations/binary_gap/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0001.Iterations/Binary-Gap/Binary-Gap.go package binarygap // O(log n) func Solution(N int) int { maxLen, curLen := 0, 0 findOne := false for N > 0 { curBit := N & 1 if curBit == 1 { curLen = 0 findOne = true } else if curBit == 0 && findOne { curLen++ } if curLen > maxLen { maxLen = curLen } N = N >> 1 } return maxLen } // https://wandbox.org/permlink/totZwDAbL1wCgsqt func evil(x int) int { if x&(x+1) > 0 { return evil(x|(x>>1)) + 1 } else { return 0 } } func SolutionRecur(N int) int { for (N & 1) == 0 { N = N >> 1 } return evil(N) } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0002.Array/CyclicRotation/":{"url":"Codility/Lesson/0002.Array/CyclicRotation/","title":"Cyclic Rotation","summary":"Cyclic Rotation","keywords":"","body":"CyclicRotation tagsstart Codility Go Array Painless Multiple Pointers tagsstop An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place). The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times. Write a function: func Solution(A []int, K int) []int that, given an array A consisting of N integers and an integer K, returns the array A rotated K times. For example, given A = [3, 8, 9, 7, 6] K = 3 the function should return [9, 7, 6, 3, 8]. Three rotations were made: [3, 8, 9, 7, 6] -> [6, 3, 8, 9, 7] [6, 3, 8, 9, 7] -> [7, 6, 3, 8, 9] [7, 6, 3, 8, 9] -> [9, 7, 6, 3, 8] For another example, given A = [0, 0, 0] K = 1 the function should return [0, 0, 0] Given A = [1, 2, 3, 4] K = 4 the function should return [1, 2, 3, 4] Assume that: N and K are integers within the range [0..100]; each element of array A is an integer within the range [−1,000..1,000]. In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 CyclicRotation題目要求將給定的整數陣列按照給定的旋轉步數進行循環右移，並返回旋轉後的陣列。例如，如果陣列是[3, 8, 9, 7, 6]且旋轉步數是3，則右移後的陣列為[9, 7, 6, 3, 8]。 解題思路 解題思路可以使用多種方法。一種常見的方法是使用額外的陣列來存儲旋轉後的結果。另一種方法是通過循環右移的操作，直接在原始陣列上進行元素交換。根據旋轉步數，我們可以將陣列分為兩個部分，並進行相應的元素交換操作。 時間複雜度: 解題思路中的操作需要遍歷整個陣列，因此時間複雜度為O(N)，其中N是陣列的長度。 空間複雜度: 解題思路中使用了額外的陣列或進行原地交換，不需要使用額外的數據結構，因此空間複雜度為O(1)。 來源 https://app.codility.com/programmers/lessons/2-arrays/cyclic_rotation/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0002.Array/CyclicRotation/CyclicRotation.go package cyclicrotation func Solution(A []int, K int) []int { if K == 0 || len(A) len(A) { K = K % len(A) } return append(A[len(A)-K:], A[:len(A)-K]...) } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0002.Array/OddOccurrencesInArray/":{"url":"Codility/Lesson/0002.Array/OddOccurrencesInArray/","title":"Odd Occurrences In Array","keywords":"","body":"OddOccurrencesInArray A non-empty array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired. For example, in array A such that: A[0] = 9 A[1] = 3 A[2] = 9 A[3] = 3 A[4] = 9 A[5] = 7 A[6] = 9 the elements at indexes 0 and 2 have value 9, the elements at indexes 1 and 3 have value 3, the elements at indexes 4 and 6 have value 9, the element at index 5 has value 7 and is unpaired. Write a function: func Solution(A []int) int that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element. For example, given array A such that: A[0] = 9 A[1] = 3 A[2] = 9 A[3] = 3 A[4] = 9 A[5] = 7 A[6] = 9 the function should return 7, as explained in the example above. Write an efficient algorithm for the following assumptions: N is an odd integer within the range [1..1,000,000]; each element of array A is an integer within the range [1..1,000,000,000]; all but one of the values in A occur an even number of times. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 給定一個非空array A，包含有N個整數，找出只出現基數次的整式 解題思路 方法一: 可以用Map紀錄每個整數出現的次數, 在檢查是否是偶數 方法二: 所有的整數XOR起來, 若是兩個整數相同XOR得到0, 最後剩下基數次的數字 來源 https://app.codility.com/programmers/lessons/2-arrays/odd_occurrences_in_array/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0002.Array/OddOccurrencesInArray/OddOccurrencesInArray.go package oddoccurrencesinarray func Solution(A []int) int { intMap := make(map[int]int) for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0003.Time-Complexity/FrogJmp/":{"url":"Codility/Lesson/0003.Time-Complexity/FrogJmp/","title":"Frog Jmp","keywords":"","body":"FrogJmp A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D. Count the minimal number of jumps that the small frog must perform to reach its target. Write a function: func Solution(X int, Y int, D int) int that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y. For example, given: X = 10 Y = 85 D = 30 the function should return 3, because the frog will be positioned as follows: after the first jump, at position 10 + 30 = 40 after the second jump, at position 10 + 30 + 30 = 70 after the third jump, at position 10 + 30 + 30 + 30 = 100 Write an efficient algorithm for the following assumptions: X, Y and D are integers within the range [1..1,000,000,000]; X ≤ Y. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 解題思路 來源 https://app.codility.com/programmers/lessons/3-time_complexity/frog_jmp/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0003.Time-Complexity/FrogJmp/FrogJmp.go package frogjump import ( \"math\" ) func Solution(X int, Y int, D int) int { if Y © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0003.Time-Complexity/PermMissingElem/":{"url":"Codility/Lesson/0003.Time-Complexity/PermMissingElem/","title":"Perm Missing Elem","keywords":"","body":"PermMissingElem An array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing. Your goal is to find that missing element. Write a function: func Solution(A []int) int that, given an array A, returns the value of the missing element. For example, given array A such that: A[0] = 2 A[1] = 3 A[2] = 1 A[3] = 5 the function should return 4, as it is the missing element. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..100,000]; the elements of A are all distinct; each element of array A is an integer within the range [1..(N + 1)]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 解題思路 來源 https://app.codility.com/programmers/lessons/3-time_complexity/perm_missing_elem/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0003.Time-Complexity/PermMissingElem/PermMissingElem.go package permmissingelem func Solution(A []int) int { if len(A) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0003.Time-Complexity/TapeEquilibrium/":{"url":"Codility/Lesson/0003.Time-Complexity/TapeEquilibrium/","title":"Tape Equilibrium","keywords":"","body":"TapeEquilibrium Minimize the value |(A[0] + ... + A[P-1]) - (A[P] + ... + A[N-1])|. A non-empty array A consisting of N integers is given. Array A represents numbers on a tape. Any integer P, such that 0 The difference between the two parts is the value of: |(A[0] + A[1] + ... + A[P − 1]) − (A[P] + A[P + 1] + ... + A[N − 1])| In other words, it is the absolute difference between the sum of the first part and the sum of the second part. For example, consider array A such that: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3 We can split this tape in four places: P = 1, difference = |3 − 10| = 7 P = 2, difference = |4 − 9| = 5 P = 3, difference = |6 − 7| = 1 P = 4, difference = |10 − 3| = 7 Write a function: func Solution(A []int) int that, given a non-empty array A of N integers, returns the minimal difference that can be achieved. For example, given: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 4 A[4] = 3 the function should return 1, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [2..100,000]; each element of array A is an integer within the range [−1,000..1,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 解題思路 來源 https://app.codility.com/programmers/lessons/3-time_complexity/tape_equilibrium/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0003.Time-Complexity/TapeEquilibrium/TapeEquilibrium.go package TapeEquilibrium import \"math\" func Solution(A []int) int { totalSum := 0 for _, v := range A { totalSum += v } leftSum := A[0] rightSum := totalSum - leftSum result := math.MaxInt32 for i := 1; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0004.Counting-Elements/FrogRiverOne/":{"url":"Codility/Lesson/0004.Counting-Elements/FrogRiverOne/","title":"Frog River One","keywords":"","body":"FrogRiverOne Find the earliest time when a frog can jump to the other side of a river. A small frog wants to get to the other side of a river. The frog is initially located on one bank of the river (position 0) and wants to get to the opposite bank (position X+1). Leaves fall from a tree onto the surface of the river. You are given an array A consisting of N integers representing the falling leaves. A[K] represents the position where one leaf falls at time K, measured in seconds. The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to X (that is, we want to find the earliest moment when all the positions from 1 to X are covered by leaves). You may assume that the speed of the current in the river is negligibly small, i.e. the leaves do not change their positions once they fall in the river. For example, you are given integer X = 5 and array A such that: A[0] = 1 A[1] = 3 A[2] = 1 A[3] = 4 A[4] = 2 A[5] = 3 A[6] = 5 A[7] = 4 In second 6, a leaf falls into position 5. This is the earliest time when leaves appear in every position across the river. Write a function: func Solution(X int, A []int) int that, given a non-empty array A consisting of N integers and integer X, returns the earliest time when the frog can jump to the other side of the river. If the frog is never able to jump to the other side of the river, the function should return −1. For example, given X = 5 and array A such that: A[0] = 1 A[1] = 3 A[2] = 1 A[3] = 4 A[4] = 2 A[5] = 3 A[6] = 5 A[7] = 4 the function should return 6, as explained above. Write an efficient algorithm for the following assumptions: N and X are integers within the range [1..100,000]; each element of array A is an integer within the range [1..X]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 要X步才能到對面, 每一個走過的位子不能重複計算 解題思路 使用map存哪些地方走過 來源 https://app.codility.com/programmers/lessons/4-counting_elements/frog_river_one/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0004.Counting-Elements/FrogRiverOne/FrogRiverOne.go package FrogRiverOne func Solution(X int, A []int) int { intMap := make(map[int]bool) for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0004.Counting-Elements/MaxCounters/":{"url":"Codility/Lesson/0004.Counting-Elements/MaxCounters/","title":"Max Counters","keywords":"","body":"MaxCounters Calculate the values of counters after applying all alternating operations: increase counter by 1; set value of all counters to current maximum. You are given N counters, initially set to 0, and you have two possible operations on them: increase(X) − counter X is increased by 1, max counter − all counters are set to the maximum value of any counter. A non-empty array A of M integers is given. This array represents consecutive operations: if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X), if A[K] = N + 1 then operation K is max counter. For example, given integer N = 5 and array A such that: A[0] = 3 A[1] = 4 A[2] = 4 A[3] = 6 A[4] = 1 A[5] = 4 A[6] = 4 the values of the counters after each consecutive operation will be: (0, 0, 1, 0, 0) (0, 0, 1, 1, 0) (0, 0, 1, 2, 0) (2, 2, 2, 2, 2) (3, 2, 2, 2, 2) (3, 2, 2, 3, 2) (3, 2, 2, 4, 2) The goal is to calculate the value of every counter after all operations. Write a function: func Solution(N int, A []int) []int that, given an integer N and a non-empty array A consisting of M integers, returns a sequence of integers representing the values of the counters. Result array should be returned as an array of integers. For example, given: A[0] = 3 A[1] = 4 A[2] = 4 A[3] = 6 A[4] = 1 A[5] = 4 A[6] = 4 the function should return [3, 2, 2, 4, 2], as explained above. Write an efficient algorithm for the following assumptions: N and M are integers within the range [1..100,000]; each element of array A is an integer within the range [1..N + 1]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 如果A[i] 小於 N 則將計數器中對應位置的數+1, 如果A[i] 大於 N 則將計數器中所有的數更新為計數器當前的最大數值 解題思路 來源 https://app.codility.com/programmers/lessons/4-counting_elements/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0004.Counting-Elements/MaxCounters/MaxCounters.go package MaxCounters func Max(x, y int) int { if x > y { return x } return y } // 時間 O(N+M) , 空間 O(N) func Solution(N int, A []int) []int { result := make([]int, N) maxNum := 0 nowMaxNum := 0 for i := 0; i N { // 如果A[i] 大於 N 則將計數器中所有的數更新為計數器當前的最大數值 maxNum = nowMaxNum } else { // 如果A[i] 小於 N 則將計數器中對應位置的數+1, if result[A[i]-1] © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0004.Counting-Elements/MissingInteger/":{"url":"Codility/Lesson/0004.Counting-Elements/MissingInteger/","title":"Missing Integer","keywords":"","body":"MissingInteger Find the smallest positive integer that does not occur in a given sequence. This is a demo task. Write a function: func Solution(A []int) int that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A. For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5. Given A = [1, 2, 3], the function should return 4. Given A = [−1, −3], the function should return 1. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; each element of array A is an integer within the range [−1,000,000..1,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 找出該array沒出現的最小整數 解題思路 先講出現的數字記錄起來, 再依序從1開始往後找出最小的整數且沒出現過 來源 https://app.codility.com/programmers/lessons/4-counting_elements/missing_integer/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0004.Counting-Elements/MissingInteger/MissingInteger.go package MissingInteger func Solution(A []int) int { smallNum := 1 intMap := make(map[int]bool) // 將出現的數字塞入map for _, v := range A { if v > 0 && !intMap[v] { intMap[v] = true } } for i := 1; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0004.Counting-Elements/PermCheck/":{"url":"Codility/Lesson/0004.Counting-Elements/PermCheck/","title":"Perm Check","keywords":"","body":"PermCheck Check whether array A is a permutation. A non-empty array A consisting of N integers is given. A permutation(排列) is a sequence containing each element from 1 to N once, and only once. For example, array A such that: A[0] = 4 A[1] = 1 A[2] = 3 A[3] = 2 is a permutation, but array A such that: A[0] = 4 A[1] = 1 A[2] = 3 is not a permutation, because value 2 is missing. The goal is to check whether array A is a permutation. Write a function: func Solution(A []int) int that, given an array A, returns 1 if array A is a permutation and 0 if it is not. For example, given array A such that: A[0] = 4 A[1] = 1 A[2] = 3 A[3] = 2 the function should return 1. Given array A such that: A[0] = 4 A[1] = 1 A[2] = 3 the function should return 0. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; each element of array A is an integer within the range [1..1,000,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 如果是連續排列的array 回傳 1 反之回傳1 解題思路 類似lesson 4的MissingInteger. 先將現有的直寫入到map. 除了檢查是否有重複數字出現外,順便將總和算起來 最後檢查總時對不對 來源 https://app.codility.com/programmers/lessons/4-counting_elements/perm_check/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0004.Counting-Elements/PermCheck/PermCheck.go package PermCheck func Solution(A []int) int { intMap := make(map[int]bool) for _, v := range A { if !intMap[v] { intMap[v] = true } else { // 重複出現 return 0 } } for i := 1; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0005.Prefix-Sums/CountDiv/":{"url":"Codility/Lesson/0005.Prefix-Sums/CountDiv/","title":"Count Div","keywords":"","body":"CountDiv Compute number of integers divisible by k in range [a..b]. Write a function: func Solution(A int, B int, K int) int that, given three integers A, B and K, returns the number of integers within the range [A..B] that are divisible by K, i.e.: { i : A ≤ i ≤ B, i mod K = 0 } For example, for A = 6, B = 11 and K = 2, your function should return 3, because there are three numbers divisible by 2 within the range [6..11], namely 6, 8 and 10. Write an efficient algorithm for the following assumptions: A and B are integers within the range [0..2,000,000,000]; K is an integer within the range [1..2,000,000,000]; A ≤ B. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 A~B之間的數字 mod K 後為0 的數字有幾個 解題思路 B/K 找出最大的商, A/K 最小的商. 相減取得在此中間之商的數量. 如果A%K==0 需要在+1 來源 https://app.codility.com/programmers/lessons/5-prefix_sums/count_div/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0005.Prefix-Sums/CountDiv/CountDiv.go package CountDiv import \"math\" // 時間: O(n) func SolutionBurst(A int, B int, K int) int { result := 0 for i := A; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0005.Prefix-Sums/GenomicRangeQuery/":{"url":"Codility/Lesson/0005.Prefix-Sums/GenomicRangeQuery/","title":"Genomic Range Query","keywords":"","body":"GenomicRangeQuery Find the minimal nucleotide(核苷酸) from a range of sequence DNA. A DNA sequence can be represented as a string consisting of the letters A, C, G and T, which correspond to the types of successive nucleotides in the sequence. Each nucleotide has an impact factor, which is an integer. Nucleotides of types A, C, G and T have impact factors of 1, 2, 3 and 4, respectively. You are going to answer several queries of the form: What is the minimal impact factor of nucleotides contained in a particular part of the given DNA sequence? The DNA sequence is given as a non-empty string S = S[0]S[1]...S[N-1] consisting of N characters. There are M queries, which are given in non-empty arrays P and Q, each consisting of M integers. The K-th query (0 ≤ K For example, consider string S = CAGCCTA and arrays P, Q such that: P[0] = 2 Q[0] = 4 P[1] = 5 Q[1] = 5 P[2] = 0 Q[2] = 6 The answers to these M = 3 queries are as follows: The part of the DNA between positions 2 and 4 contains nucleotides G and C (twice), whose impact factors are 3 and 2 respectively, so the answer is 2. The part between positions 5 and 5 contains a single nucleotide T, whose impact factor is 4, so the answer is 4. The part between positions 0 and 6 (the whole string) contains all nucleotides, in particular nucleotide A whose impact factor is 1, so the answer is 1. Write a function: func Solution(S string, P []int, Q []int) []int that, given a non-empty string S consisting of N characters and two non-empty arrays P and Q consisting of M integers, returns an array consisting of M integers specifying the consecutive answers to all queries. Result array should be returned as an array of integers. For example, given the string S = CAGCCTA and arrays P, Q such that: P[0] = 2 Q[0] = 4 P[1] = 5 Q[1] = 5 P[2] = 0 Q[2] = 6 the function should return the values [2, 4, 1], as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; M is an integer within the range [1..50,000]; each element of arrays P, Q is an integer within the range [0..N − 1]; P[K] ≤ Q[K], where 0 ≤ K 題目大意 CAGCCTA A 代表1, C 代表2, G 代表3 ,T 代表4 K=0: P[0]=2, Q[0]=4 之間的核苷酸 DNA(GCC)因素分別是3和2, 最小的就是2. K=1: P[1]=5, Q[1]=5 DNA(T),最小的是4. K=2: P[2]=0, Q[2]=6 DNA(CAGCCTA),最小的是1. 解題思路 來源 https://app.codility.com/programmers/lessons/5-prefix_sums/genomic_range_query/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0005.Prefix-Sums/GenomicRangeQuery/GenomicRangeQuery.go package GenomicRangeQuery func Solution(S string, P []int, Q []int) []int { A, C, G, T := prefixSums(S) result := make([]int, len(P)) /* // fmt.Println(\"A: \", A) // fmt.Println(\"C: \", C) // fmt.Println(\"G: \", G) // fmt.Println(\"T: \", T) idx 0 1 2 3 4 5 6 7 S: [C A G C C T A] A: [0 0 1 1 1 1 1 2] C: [0 1 1 1 2 3 3 3] G: [0 0 0 1 1 1 1 1] T: [0 0 0 0 0 0 1 1] P: [2 5 0] Q: [4 5 6] */ for k, _ := range P { // 判斷 A[end of slice]-A[Begin of Slice]是否大於零 即可判斷是否 A 出現過 if A[Q[k]+1]-A[P[k]] > 0 { result[k] = 1 } else if C[Q[k]+1]-C[P[k]] > 0 { result[k] = 2 } else if G[Q[k]+1]-G[P[k]] > 0 { result[k] = 3 } else if T[Q[k]+1]-T[P[k]] > 0 { result[k] = 4 } } return result } // 數算從開始到每個固定索引的A,C,G,T個數. 開頭插入0 func prefixSums(S string) ([]int, []int, []int, []int) { n := len(S) A := make([]int, n+1) C := make([]int, n+1) G := make([]int, n+1) T := make([]int, n+1) for i := 1; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0005.Prefix-Sums/MinAvgTwoSlice/":{"url":"Codility/Lesson/0005.Prefix-Sums/MinAvgTwoSlice/","title":"Min Avg Two Slice","keywords":"","body":"MinAvgTwoSlice Find the minimal average of any slice containing at least two elements. A non-empty array A consisting of N integers is given. A pair of integers (P, Q), such that 0 ≤ P For example, array A such that: A[0] = 4 A[1] = 2 A[2] = 2 A[3] = 5 A[4] = 1 A[5] = 5 A[6] = 8 contains the following example slices: slice (1, 2), whose average is (2 + 2) / 2 = 2; slice (3, 4), whose average is (5 + 1) / 2 = 3; slice (1, 4), whose average is (2 + 2 + 5 + 1) / 4 = 2.5. The goal is to find the starting position of a slice whose average is minimal. Write a function: func Solution(A []int) int that, given a non-empty array A consisting of N integers, returns the starting position of the slice with the minimal average. If there is more than one slice with a minimal average, you should return the smallest starting position of such a slice. For example, given array A such that: A[0] = 4 A[1] = 2 A[2] = 2 A[3] = 5 A[4] = 1 A[5] = 5 A[6] = 8 the function should return 1, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [2..100,000]; each element of array A is an integer within the range [−10,000..10,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 找出array兩index中平均值最小 ,並回傳start的 index 解題思路 最小avg的slice(n,m)，m-n+1一定是2或者3，也就是這個最小avg的slice由2個或者3個元素組成 因為題目中說明 0 因此可以得出2個或者3個元素是最小的組合，比如length=3的數組，你無法一次分出2個slice，length=2的數組也一樣。為什麼要這麼去想呢？因為你要“比較”出最小的avg，怎麼才能\"比較\"？那就是必須一次至少有2個slice才能相互比較。那麼當N>=4時，我們就能一次最少分出2個slice 來源 https://app.codility.com/programmers/lessons/5-prefix_sums/min_avg_two_slice/ https://blog.csdn.net/dear0607/article/details/42581149 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0005.Prefix-Sums/MinAvgTwoSlice/MinAvgTwoSlice.go package MinAvgTwoSlice import \"math\" func Solution(A []int) int { min := math.MaxFloat64 minIndex := -1 for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0005.Prefix-Sums/PassingCars/":{"url":"Codility/Lesson/0005.Prefix-Sums/PassingCars/","title":"Passing Cars","keywords":"","body":"PassingCars A non-empty array A consisting of N integers is given. The consecutive(連續) elements of array A represent consecutive cars on a road. Array A contains only 0s and/or 1s: 0 represents a car traveling east, 1 represents a car traveling west. The goal is to count passing cars. We say that a pair of cars (P, Q), where 0 ≤ P For example, consider array A such that: A[0] = 0 // no.0 car trave to east A[1] = 1 // no.1 car trave to west A[2] = 0 // no.2 car trave to east A[3] = 1 // no.3 car trave to west A[4] = 1 // no.4 car trave to west We have five pairs of passing cars: (0, 1), (0, 3), (0, 4), (2, 3), (2, 4). Write a function: func Solution(A []int) int that, given a non-empty array A of N integers, returns the number of pairs of passing cars. The function should return −1 if the number of pairs of passing cars exceeds 1,000,000,000. For example, given: A[0] = 0 A[1] = 1 A[2] = 0 A[3] = 1 A[4] = 1 the function should return 5, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; each element of array A is an integer that can have one of the following values: 0, 1. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 每台車的車號為A[]的index, 0 代表往東, 1代表往西, 向東的車號需要小於向西的車號. 找出會車的幾種可能性 解題思路 每一個向東走的車, 都會跟向西的配對. 當遇到向西時組合+1. 所以車號0可以跟所有大於0的向西車配對. 車號2跟所有大於0的向西車配對 1號車前面只有車號0這選擇. 車號3跟4有車號0跟2這兩個選擇. 所以是1+2*2=5 來源 https://app.codility.com/programmers/lessons/5-prefix_sums/passing_cars/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0005.Prefix-Sums/PassingCars/PassingCars.go package PassingCars func Solution(A []int) int { addBase, result := 0, 0 for i := 0; i 1000000000 { return -1 } return result } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0006.Sorting/Distinct/":{"url":"Codility/Lesson/0006.Sorting/Distinct/","title":"Distinct","keywords":"","body":"Distinct Compute number of distinct values in an array. Write a function func Solution(A []int) int that, given an array A consisting of N integers, returns the number of distinct values in array A. For example, given array A consisting of six elements such that: A[0] = 2 A[1] = 1 A[2] = 1 A[3] = 2 A[4] = 3 A[5] = 1 the function should return 3, because there are 3 distinct values appearing in array A, namely 1, 2 and 3. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..100,000]; each element of array A is an integer within the range [−1,000,000..1,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 返回不重複的整數數量 解題思路 方法ㄧ: 先排序, 在檢查當前跟前一個是不是同一個整數. 不是的會結果+1 方法二: 建立一個set. 最後返回set的長度 來源 https://app.codility.com/programmers/lessons/6-sorting/distinct/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0006.Sorting/Distinct/Distinct.go package Distinct import \"sort\" func Solution(A []int) int { sort.Ints(A) if len(A) == 0 { return 0 } result := 1 for i := 1; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0006.Sorting/MaxProductOfThree/":{"url":"Codility/Lesson/0006.Sorting/MaxProductOfThree/","title":"Max Product Of Three","keywords":"","body":"MaxProductOfThree Maximize A[P] A[Q] A[R] for any triplet (P, Q, R). A non-empty array A consisting of N integers is given. The product of triplet (P, Q, R) equates to A[P] A[Q] A[R] (0 ≤ P For example, array A such that: A[0] = -3 A[1] = 1 A[2] = 2 A[3] = -2 A[4] = 5 A[5] = 6 contains the following example triplets: (0, 1, 2), product is −3 1 2 = −6 (1, 2, 4), product is 1 2 5 = 10 (2, 4, 5), product is 2 5 6 = 60 Your goal is to find the maximal product of any triplet. Write a function: func Solution(A []int) int that, given a non-empty array A, returns the value of the maximal product of any triplet. For example, given array A such that: A[0] = -3 A[1] = 1 A[2] = 2 A[3] = -2 A[4] = 5 A[5] = 6 the function should return 60, as the product of triplet (2, 4, 5) is maximal. Write an efficient algorithm for the following assumptions: N is an integer within the range [3..100,000]; each element of array A is an integer within the range [−1,000..1,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 給一整數陣列A，找出陣列中任意三數乘積的最大值 解題思路 先排序.然後比較 前兩個元素*最後一個元素的乘積 和 最後三個元素的乘積 取最大值 來源 https://app.codility.com/programmers/lessons/6-sorting/max_product_of_three/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0006.Sorting/MaxProductOfThree/MaxProductOfThree.go package MaxProductOfThree import \"sort\" func max(a, b int) int { if a > b { return a } return b } func Solution(A []int) int { sort.Ints(A) aLen := len(A) return max(A[0]*A[1]*A[aLen-1], A[aLen-1]*A[aLen-2]*A[aLen-3]) } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0006.Sorting/NumberOfDiscIntersections/":{"url":"Codility/Lesson/0006.Sorting/NumberOfDiscIntersections/","title":"Number Of Disc Intersections","keywords":"","body":"NumberOfDiscIntersections Compute the number of intersections(相交) in a sequence of discs(圓盤). We draw N discs on a plane. The discs are numbered from 0 to N − 1. An array A of N non-negative integers, specifying the radiuses(半徑) of the discs, is given. The J-th disc is drawn with its center at (J, 0) and radius A[J]. We say that the J-th disc and K-th disc intersect if J ≠ K and the J-th and K-th discs have at least one common point (assuming that the discs contain their borders). The figure below shows discs drawn for N = 6 and A as follows: A[0] = 1 A[1] = 5 A[2] = 2 A[3] = 1 A[4] = 4 A[5] = 0 There are eleven (unordered) pairs of discs that intersect, namely: discs 1 and 4 intersect, and both intersect with all the other discs; disc 2 also intersects with discs 0 and 3. Write a function: func Solution(A []int) int that, given an array A describing N discs as explained above, returns the number of (unordered) pairs of intersecting discs. The function should return −1 if the number of intersecting pairs exceeds 10,000,000. Given array A shown above, the function should return 11, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..100,000]; each element of array A is an integer within the range [0..2,147,483,647]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 A[0] = 1, 代表在(0,0)的位置上有一個半徑為1的圓. 找出圓相交的個數 解題思路 方法一: 對於第i，j個圓來說，如果兩個原要相交的話 參考SolutionDirect. 時間複雜度為O(n^2) 方法二 也就是將原來的二維的線段列表變為2個一維的列表 首先遍歷數組A得到A[i]+i組成的數組i_limit，以及j-A[j]組成的數組j_limit。然後再遍歷數組i_limit中的元素S，利用二分查找算法得到數組j_limit中不大於S的元素個數。前一個操作時間複雜度是O(N)，二分查找算法時間複雜度是O(LogN)，因此最終的時間複雜度為O(N*logN)。參考Solution。 來源 https://app.codility.com/programmers/lessons/6-sorting/number_of_disc_intersections/ https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L6_Sorting/6.4%20NumberOfDiscIntersections.md https://rafal.io/posts/codility-intersecting-discs.html https://github.com/tmpapageorgiou/algorithm/blob/master/number_disc_intersections.py 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0006.Sorting/NumberOfDiscIntersections/NumberOfDiscIntersections.go package NumberOfDiscIntersections import \"sort\" func max(a, b int) int { if a > b { return a } return b } func min(a, b int) int { if a > b { return b } return a } // 時間複雜 O(n^2) func SolutionDirect(A []int) int { count := 0 for indexI, valueI := range A { tmpArr := A[indexI+1:] for indexJ, valueJ := range tmpArr { if valueI+valueJ >= indexJ+indexI+1-indexI { count++ } } } return count } // 時間複雜 O(nlogn) or O(n) // TODO: 待研究 func Solution(A []int) int { iLimit := make([]int, len(A)) // 左 jLimit := make([]int, len(A)) // 右 result := 0 for i := 0; i end }) // 因為i=j時，A[i]+i 肯定不小於j-A[j],也就是說多算了一個，因此要減去1。 // 減去idx是因為圓盤A和圓盤B相交，次數加上1了，圓盤B和圓盤A相交就不用再加1了。 count = count - idx - 1 result += count if result > 10000000 { return -1 } } return result } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0006.Sorting/Triangle/":{"url":"Codility/Lesson/0006.Sorting/Triangle/","title":"Triangle","keywords":"","body":"Triangle Determine whether a triangle can be built from a given set of edges. An array A consisting of N integers is given. A triplet (P, Q, R) is triangular if 0 ≤ P A[P] + A[Q] > A[R], A[Q] + A[R] > A[P], A[R] + A[P] > A[Q]. For example, consider array A such that: A[0] = 10 A[1] = 2 A[2] = 5 A[3] = 1 A[4] = 8 A[5] = 20 Triplet (0, 2, 4) is triangular. Write a function: func Solution(A []int) int that, given an array A consisting of N integers, returns 1 if there exists a triangular triplet for this array and returns 0 otherwise. For example, given array A such that: A[0] = 10 A[1] = 2 A[2] = 5 A[3] = 1 A[4] = 8 A[5] = 20 the function should return 1, as explained above. Given array A such that: A[0] = 10 A[1] = 50 A[2] = 5 A[3] = 1 the function should return 0. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..100,000]; each element of array A is an integer within the range [−2,147,483,648..2,147,483,647]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 如果該array存在一個三角形的三元組,則返回1, 否則返回0 解題思路 從大到小排序, 如果前面的值小於後面兩數和, 則可以組成三角形. 三數皆不能為0或負數 來源 https://app.codility.com/programmers/lessons/6-sorting/triangle/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0006.Sorting/Triangle/Triangle.go package Triangle import \"sort\" func Solution(A []int) int { if len(A) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0007.Stacks-and-Queues/Brackets/":{"url":"Codility/Lesson/0007.Stacks-and-Queues/Brackets/","title":"Brackets","keywords":"","body":"Brackets Determine whether a given string of parentheses (multiple types) is properly nested. A string S consisting of N characters is considered to be properly nested if any of the following conditions is true: S is empty; S has the form \"(U)\" or \"[U]\" or \"{U}\" where U is a properly nested string; S has the form \"VW\" where V and W are properly nested strings. For example, the string \"{[()()]}\" is properly nested but \"([)()]\" is not. Write a function: func Solution(S string) int that, given a string S consisting of N characters, returns 1 if S is properly nested and 0 otherwise. For example, given S = \"{[()()]}\", the function should return 1 and given S = \"([)()]\", the function should return 0, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..200,000]; string S consists only of the following characters: \"(\", \"{\", \"[\", \"]\", \"}\" and/or \")\". Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 括號配對, 可配對回傳1 反之回傳0. 解題思路 將左括號都放入stack. 遇到右括號時將stack pop出來並檢查pop出來的左括號是否跟右括號配對. 來源 https://app.codility.com/programmers/lessons/7-stacks_and_queues/brackets/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0007.Stacks-and-Queues/Brackets/Brackets.go package Brackets import ( \"LeetcodeGolang/Utility/structures\" ) func Solution(S string) int { if len(S) == 0 { return 1 } if len(S)%2 != 0 { return 0 } BracketMap := map[string]string{ \")\": \"(\", \"]\": \"[\", \"}\": \"{\", } stack := structures.NewArrayStack() for _, v := range S { val := string(v) if val == \"(\" || val == \"[\" || val == \"{\" { stack.Push(val) } else if val == \")\" || val == \"]\" || val == \"}\" { if stack.IsEmpty() { return 0 } topVal := stack.Top() if topVal == BracketMap[val] { stack.Pop() } else { // 找不到可配對的括號 return 0 } } } if stack.IsEmpty() { return 1 } else { return 0 } } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0007.Stacks-and-Queues/Fish/":{"url":"Codility/Lesson/0007.Stacks-and-Queues/Fish/","title":"Fish","keywords":"","body":"Fish N voracious fish are moving along a river. Calculate how many fish are alive. You are given two non-empty arrays A and B consisting of N integers. Arrays A and B represent N voracious fish in a river, ordered downstream along the flow of the river. The fish are numbered from 0 to N − 1. If P and Q are two fish and P Fish number P is represented by A[P] and B[P]. Array A contains the sizes of the fish. All its elements are unique. Array B contains the directions of the fish. It contains only 0s and/or 1s, where: 0 represents a fish flowing upstream, 1 represents a fish flowing downstream. If two fish move in opposite directions and there are no other (living) fish between them, they will eventually meet each other. Then only one fish can stay alive − the larger fish eats the smaller one. More precisely, we say that two fish P and Q meet each other when P If A[P] > A[Q] then P eats Q, and P will still be flowing downstream, If A[Q] > A[P] then Q eats P, and Q will still be flowing upstream. We assume that all the fish are flowing at the same speed. That is, fish moving in the same direction never meet. The goal is to calculate the number of fish that will stay alive. For example, consider arrays A and B such that: A[0] = 4 B[0] = 0 A[1] = 3 B[1] = 1 A[2] = 2 B[2] = 0 A[3] = 1 B[3] = 0 A[4] = 5 B[4] = 0 Initially all the fish are alive and all except fish number 1 are moving upstream. Fish number 1 meets fish number 2 and eats it, then it meets fish number 3 and eats it too. Finally, it meets fish number 4 and is eaten by it. The remaining two fish, number 0 and 4, never meet and therefore stay alive. Write a function: func Solution(A []int, B []int) int that, given two non-empty arrays A and B consisting of N integers, returns the number of fish that will stay alive. For example, given the arrays shown above, the function should return 2, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; each element of array A is an integer within the range [0..1,000,000,000]; each element of array B is an integer that can have one of the following values: 0, 1; the elements of A are all distinct. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 最開始每個魚都有特定的起始位置 A: 活魚的大小, B: 魚游的方向. 如果於相遇的話大魚會吃掉小魚. 返回剩下魚的數量 解題思路 從 B 開始找, 當值為1 存入stack. 代表向下游的魚. 來進行把活魚吃掉. 如果把列表的活魚都吃掉. 則結果+1 如果值為0且stack為空, 代表沒遇到下游的魚所以活魚++ 來源 https://app.codility.com/programmers/lessons/7-stacks_and_queues/fish/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0007.Stacks-and-Queues/Fish/Fish.go package Fish import \"LeetcodeGolang/Utility/structures\" func Solution(A []int, B []int) int { stack := structures.NewArrayStack() aliveFish := 0 for idx, val := range B { if val == 1 { stack.Push(A[idx]) } else { // 繼續往下游 for !stack.IsEmpty() { if stack.Top().(int) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0007.Stacks-and-Queues/Nesting/":{"url":"Codility/Lesson/0007.Stacks-and-Queues/Nesting/","title":"Nesting","keywords":"","body":"Nesting Determine whether a given string of parentheses (single type) is properly nested. A string S consisting of N characters is called properly nested if: S is empty; S has the form \"(U)\" where U is a properly nested string; S has the form \"VW\" where V and W are properly nested strings. For example, string \"(()(())())\" is properly nested but string \"())\" isn't. Write a function: func Solution(S string) int that, given a string S consisting of N characters, returns 1 if string S is properly nested and 0 otherwise. For example, given S = \"(()(())())\", the function should return 1 and given S = \"())\", the function should return 0, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..1,000,000]; string S consists only of the characters \"(\" and/or \")\". Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 括號配對 解題思路 與Bracket類似 來源 https://app.codility.com/programmers/lessons/7-stacks_and_queues/nesting/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0007.Stacks-and-Queues/Nesting/Nesting.go package Nesting import \"LeetcodeGolang/Utility/structures\" func Solution(S string) int { if len(S) == 0 { return 1 } if len(S)%2 != 0 { return 0 } stack := structures.NewArrayStack() for _, v := range S { val := string(v) if val == \"(\" { stack.Push(val) } else if val == \")\" { stack.Pop() } } if stack.IsEmpty() { return 1 } else { return 0 } } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0007.Stacks-and-Queues/StoneWall/":{"url":"Codility/Lesson/0007.Stacks-and-Queues/StoneWall/","title":"Stone Wall","keywords":"","body":"StoneWall Cover \"Manhattan skyline\" using the minimum number of rectangles. You are going to build a stone wall. The wall should be straight and N meters long, and its thickness should be constant; however, it should have different heights in different places. The height of the wall is specified by an array H of N positive integers. H[I] is the height of the wall from I to I+1 meters to the right of its left end. In particular, H[0] is the height of the wall's left end and H[N−1] is the height of the wall's right end. The wall should be built of cuboid (長方體) stone blocks (that is, all sides of such blocks are rectangular). Your task is to compute the minimum number of blocks needed to build the wall. Write a function: func Solution(H []int) int that, given an array H of N positive integers specifying the height of the wall, returns the minimum number of blocks needed to build it. For example, given array H containing N = 9 integers: H[0] = 8 H[1] = 8 H[2] = 5 H[3] = 7 H[4] = 9 H[5] = 8 H[6] = 7 H[7] = 4 H[8] = 8 the function should return 7. The figure shows one possible arrangement of seven blocks. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; each element of array H is an integer within the range [1..1,000,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 如何用最少的數量來貼出符合 H 的牆呢 要建立一面長N米的強. 厚度固定, 每個地方的高度不同. H[I]代表牆從 I 到 I+1 米處的高度. H[0]大表牆最左到1米處的高度 H[N-1]大表牆N-1米處到最右的高度 解題思路 尋遍整個array, 當當前高度大於先前高度時,加入stack裡, 並視為一個矩形. 將結果+1 若當前高度小於先前,將先前高度pop出去.直到stack 為空或當前高度大於等於先前高度 來源 https://app.codility.com/programmers/lessons/7-stacks_and_queues/stone_wall/ https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L7_Stacks%20and%20Queues/7.4%20StoneWall.md 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0007.Stacks-and-Queues/StoneWall/StoneWall.go package StoneWall import \"LeetcodeGolang/Utility/structures\" func Solution(H []int) int { stack := structures.NewArrayStack() result := 0 for _, v := range H { for !stack.IsEmpty() && stack.Top().(int) > v { stack.Pop() } if stack.IsEmpty() || stack.Top().(int) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0008.Leader/Dominator/":{"url":"Codility/Lesson/0008.Leader/Dominator/","title":"Dominator","keywords":"","body":"Dominator Find an index of an array such that its value occurs at more than half of indices in the array. An array A consisting of N integers is given. The dominator of array A is the value that occurs in more than half of the elements of A. For example, consider array A such that A[0] = 3 A[1] = 4 A[2] = 3 A[3] = 2 A[4] = 3 A[5] = -1 A[6] = 3 A[7] = 3 The dominator of A is 3 because it occurs in 5 out of 8 elements of A (namely in those with indices 0, 2, 4, 6 and 7) and 5 is more than a half of 8. Write a function func Solution(A []int) int that, given an array A consisting of N integers, returns index of any element of array A in which the dominator of A occurs. The function should return −1 if array A does not have a dominator. For example, given array A such that A[0] = 3 A[1] = 4 A[2] = 3 A[3] = 2 A[4] = 3 A[5] = -1 A[6] = 3 A[7] = 3 the function may return 0, 2, 4, 6 or 7, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..100,000]; each element of array A is an integer within the range [−2,147,483,648..2,147,483,647]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 返回Array中的支配數. A的支配數是3，因為它出現在A的8個元素中的5個元素中(index為0、2、4、6和7). 而5是8的一半以上 可以返回 0,2,4,6,7中的任一數 解題思路 用map紀錄每筆數出現次數. 取最大次數看是否有超過一半以上. 是的話返回此數任一個index, 反之返回-1 來源 https://app.codility.com/programmers/lessons/8-leader/dominator/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0008.Leader/Dominator/Dominator.go package Dominator import ( \"math\" ) func Solution(A []int) int { mapInt := make(map[int]int, len(A)) for _, v := range A { if _, ok := mapInt[v]; !ok { mapInt[v] = 1 } else { mapInt[v]++ } } maxCount := 0 maxVal := 0 for k, v := range mapInt { if v > maxCount { maxCount = v maxVal = k } } minIndex := -1 for k, v := range A { if v == maxVal { minIndex = k break } } if maxCount > int(math.Floor(float64(len(A))/2.0)) { return minIndex } else { return -1 } } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0008.Leader/EquiLeader/":{"url":"Codility/Lesson/0008.Leader/EquiLeader/","title":"Equi Leader","keywords":"","body":"EquiLeader Find the index S such that the leaders of the sequences A[0], A[1], ..., A[S] and A[S + 1], A[S + 2], ..., A[N - 1] are the same. A non-empty array A consisting of N integers is given. The leader of this array is the value that occurs in more than half of the elements of A. An equi leader is an index S such that 0 ≤ S For example, given array A such that: A[0] = 4 A[1] = 3 A[2] = 4 A[3] = 4 A[4] = 4 A[5] = 2 we can find two equi leaders: 0, because sequences: (4) and (3, 4, 4, 4, 2) have the same leader, whose value is 4. 2, because sequences: (4, 3, 4) and (4, 4, 2) have the same leader, whose value is 4. The goal is to count the number of equi leaders. Write a function: func Solution(A []int) int that, given a non-empty array A consisting of N integers, returns the number of equi leaders. For example, given: A[0] = 4 A[1] = 3 A[2] = 4 A[3] = 4 A[4] = 4 A[5] = 2 the function should return 2, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; each element of array A is an integer within the range [−1,000,000,000..1,000,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 選定一個下標, 將一個數組分爲左右兩個子數組, 使得兩個子數組都有相同的leader, 則稱此下標爲EquiLeader, 要求返回給定數組中EquiLeader的個數n. 事實上, 若一個數同時是左子數組的leader, 它必然也是整個數組的leader. 解題思路 需要先找出序列中的leader, 記錄其出現的次數. 然後再遍歷整個數組，枚舉分割點，記錄下左子數組leader出現的次數s, 看s與n-s是否能使得leader在左右子數組中仍爲leader. 來源 https://app.codility.com/programmers/lessons/8-leader/equi_leader/ https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L8_Leader/8.1%20EquiLeader.md 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0008.Leader/EquiLeader/EquiLeader.go package EquiLeader func Solution(A []int) int { leaderDict := make(map[int]int) for i := 0; i times { times = v leader = k } } equiCount := 0 count := 0 // 超頻數已出現的次數 for index, v := range A { if v == leader { count++ } if count > (index+1)/2 && (times-count) > (len(A)-(index+1))/2 { equiCount++ } } return equiCount } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0009.Maximum-Slice-Problem/MaxDoubleSliceSum/":{"url":"Codility/Lesson/0009.Maximum-Slice-Problem/MaxDoubleSliceSum/","title":"Max Double Slice Sum","keywords":"","body":"MaxDoubleSliceSum Find the maximal sum of any double slice. A non-empty array A consisting of N integers is given. A triplet (X, Y, Z), such that 0 ≤ X The sum of double slice (X, Y, Z) is the total of A[X + 1] + A[X + 2] + ... + A[Y − 1] + A[Y + 1] + A[Y + 2] + ... + A[Z − 1]. For example, array A such that: A[0] = 3 A[1] = 2 A[2] = 6 A[3] = -1 A[4] = 4 A[5] = 5 A[6] = -1 A[7] = 2 contains the following example double slices: double slice (0, 3, 6), sum is 2 + 6 + 4 + 5 = 17, double slice (0, 3, 7), sum is 2 + 6 + 4 + 5 − 1 = 16, double slice (3, 4, 5), sum is 0. The goal is to find the maximal sum of any double slice. Write a function: func Solution(A []int) int that, given a non-empty array A consisting of N integers, returns the maximal sum of any double slice. For example, given: A[0] = 3 A[1] = 2 A[2] = 6 A[3] = -1 A[4] = 4 A[5] = 5 A[6] = -1 A[7] = 2 the function should return 17, because no double slice of array A has a sum of greater than 17. Write an efficient algorithm for the following assumptions: N is an integer within the range [3..100,000]; each element of array A is an integer within the range [−10,000..10,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 A[X+1]到A[Y-1] + A[Y+1]到A[Z-1] 最大的和 解題思路 正向尋過array, 獲得到達每個index可以得到的最大值序列, 然后反向尋過array獲得到達每個index可以得到的最大值序列， 反向的的最大值序列需要倒轉.然後間隔一個位置， 最後尋遍array起兩者相加最大值 來源 https://app.codility.com/programmers/lessons/9-maximum_slice_problem/max_double_slice_sum/ https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L9_Maximum%20Slice%20Problem/9.3%20%20MaxDoubleSliceSum.md 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0009.Maximum-Slice-Problem/MaxDoubleSliceSum/MaxDoubleSliceSum.go package MaxDoubleSliceSum import ( \"math\" ) func Solution(A []int) int { if len(A) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0009.Maximum-Slice-Problem/MaxProfit/":{"url":"Codility/Lesson/0009.Maximum-Slice-Problem/MaxProfit/","title":"Max Profit","keywords":"","body":"MaxProfit Given a log of stock prices compute the maximum possible earning. An array A consisting of N integers is given. It contains daily prices of a stock share for a period of N consecutive days. If a single share was bought on day P and sold on day Q, where 0 ≤ P ≤ Q For example, consider the following array A consisting of six elements such that: A[0] = 23171 A[1] = 21011 A[2] = 21123 A[3] = 21366 A[4] = 21013 A[5] = 21367 If a share was bought on day 0 and sold on day 2, a loss of 2048 would occur because A[2] − A[0] = 21123 − 23171 = −2048. If a share was bought on day 4 and sold on day 5, a profit of 354 would occur because A[5] − A[4] = 21367 − 21013 = 354. Maximum possible profit was 356. It would occur if a share was bought on day 1 and sold on day 5. Write a function, func Solution(A []int) int that, given an array A consisting of N integers containing daily prices of a stock share for a period of N consecutive days, returns the maximum possible profit from one transaction during this period. The function should return 0 if it was impossible to gain any profit. For example, given array A consisting of six elements such that: A[0] = 23171 A[1] = 21011 A[2] = 21123 A[3] = 21366 A[4] = 21013 A[5] = 21367 the function should return 356, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..400,000]; each element of array A is an integer within the range [0..200,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 計算股票可能獲得的最大利潤 解題思路 尋遍整個array, 找出最小的買入金額, 同時計算當前的賣出金額-最小買入金額, 得出最大利潤 來源 https://app.codility.com/programmers/lessons/9-maximum_slice_problem/max_profit/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0009.Maximum-Slice-Problem/MaxProfit/MaxProfit.go package MaxProfit import ( \"math\" ) func Solution(A []int) int { minBuyPrice := math.MaxFloat64 maxProfit := 0.0 for _, v := range A { minBuyPrice = math.Min(minBuyPrice, float64(v)) maxProfit = math.Max(maxProfit, float64(v)-minBuyPrice) } return int(maxProfit) } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0009.Maximum-Slice-Problem/MaxSliceSum/":{"url":"Codility/Lesson/0009.Maximum-Slice-Problem/MaxSliceSum/","title":"Max Slice Sum","keywords":"","body":"MaxSliceSum Find a maximum sum of a compact subsequence of array elements. A non-empty array A consisting of N integers is given. A pair of integers (P, Q), such that 0 ≤ P ≤ Q Write a function: func Solution(A []int) int that, given an array A consisting of N integers, returns the maximum sum of any slice of A. For example, given array A such that: A[0] = 3 A[1] = 2 A[2] = -6 A[3] = 4 A[4] = 0 the function should return 5 because: (3, 4) is a slice of A that has sum 4, (2, 2) is a slice of A that has sum −6, (0, 1) is a slice of A that has sum 5, no other slice of A has sum greater than (0, 1). Write an efficient algorithm for the following assumptions: N is an integer within the range [1..1,000,000]; each element of array A is an integer within the range [−1,000,000..1,000,000]; the result will be an integer within the range [−2,147,483,648..2,147,483,647]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 找出連續子序列最大的和 解題思路 長度如果為1, 回傳第一筆 當下的值跟當下的值加上先前的和, 取最大值. 再將剛剛算出的最大值跟紀錄中的最大值比較,取最大值 來源 https://app.codility.com/programmers/lessons/9-maximum_slice_problem/max_slice_sum/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0009.Maximum-Slice-Problem/MaxSliceSum/MaxSliceSum.go package MaxSliceSum import ( \"math\" ) func Solution(A []int) int { if len(A) == 1 { return A[0] } result := math.MinInt64 sum := math.MinInt64 for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0010.Prime-And-Composite-Numbers/CountFactors/":{"url":"Codility/Lesson/0010.Prime-And-Composite-Numbers/CountFactors/","title":"Count Factors","keywords":"","body":"CountFactors Count factors of given number n. A positive integer D is a factor of a positive integer N if there exists an integer M such that N = D * M. For example, 6 is a factor of 24, because M = 4 satisfies the above condition (24 = 6 * 4). Write a function: func Solution(N int) int that, given a positive integer N, returns the number of its factors. For example, given N = 24, the function should return 8, because 24 has 8 factors, namely 1, 2, 3, 4, 6, 8, 12, 24. There are no other factors of 24. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..2,147,483,647]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 找出該數的因子個數 解題思路 尋遍該數字平方根的整數, 每次可以獲得2個因子 來源 https://app.codility.com/programmers/lessons/10-prime_and_composite_numbers/count_factors/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0010.Prime-And-Composite-Numbers/CountFactors/CountFactors.go package CountFactors import ( \"math\" ) func Solution(N int) int { result := 0 for i := 1; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0010.Prime-And-Composite-Numbers/Flags/":{"url":"Codility/Lesson/0010.Prime-And-Composite-Numbers/Flags/","title":"Flags","keywords":"","body":"Flags Find the maximum number of flags that can be set on mountain peaks. A non-empty array A consisting of N integers is given. A peak is an array element which is larger than its neighbours. More precisely, it is an index P such that 0 A[P + 1]. For example, the following array A: A[0] = 1 A[1] = 5 //peaks A[2] = 3 A[3] = 4 //peaks A[4] = 3 A[5] = 4 //peaks A[6] = 1 A[7] = 2 A[8] = 3 A[9] = 4 A[10] = 6 //peaks A[11] = 2 has exactly four peaks: elements 1, 3, 5 and 10. You are going on a trip to a range of mountains whose relative heights are represented by array A, as shown in a figure below. You have to choose how many flags you should take with you. The goal is to set the maximum number of flags on the peaks, according to certain rules. Flags can only be set on peaks. What's more, if you take K flags, then the distance between any two flags should be greater than or equal to K. The distance between indices P and Q is the absolute value |P − Q|. For example, given the mountain range represented by array A, above, with N = 12, if you take: two flags, you can set them on peaks 1 and 5; three flags, you can set them on peaks 1, 5 and 10; four flags, you can set only three flags, on peaks 1, 5 and 10. You can therefore set a maximum of three flags in this case. Write a function: func Solution(A []int) int that, given a non-empty array A of N integers, returns the maximum number of flags that can be set on the peaks of the array. For example, the following array A: A[0] = 1 A[1] = 5 A[2] = 3 A[3] = 4 A[4] = 3 A[5] = 4 A[6] = 1 A[7] = 2 A[8] = 3 A[9] = 4 A[10] = 6 A[11] = 2 the function should return 3, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..400,000]; each element of array A is an integer within the range [0..1,000,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 計算可以在山峰上設置的最大旗標數量 旗標只能在山峰上設置, 如果帶了K個旗標, 則任意兩個旗標的索引距離不能小於K 解題思路 先找出peak的索引位置並存入array中. 根據peak array的第一個最後一個可以判斷理論上最多的旗標數為K: K*(K-1) 來源 https://app.codility.com/programmers/lessons/10-prime_and_composite_numbers/ https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L10_Prime%20and%20composite%20numbers/10.4%20Flags.md 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0010.Prime-And-Composite-Numbers/Flags/Flags.go package Flags import ( \"math\" ) func Solution(A []int) int { var peaksFlag []int for i := 1; i A[i-1] && A[i] > A[i+1] { peaksFlag = append(peaksFlag, i) } } if len(peaksFlag) == 0 { return 0 } if len(peaksFlag) == 1 { return 1 } maxFlag := int(math.Pow(float64(peaksFlag[len(peaksFlag)-1]-peaksFlag[0]), 0.5) + 1) for i := maxFlag; i > 1; i-- { addressFlag := []int{peaksFlag[0]} for _, val := range peaksFlag[1:] { if val-addressFlag[len(addressFlag)-1] >= i { addressFlag = append(addressFlag, val) if len(addressFlag) >= i { return i } } } } return 1 } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0010.Prime-And-Composite-Numbers/MinPerimeterRectangle/":{"url":"Codility/Lesson/0010.Prime-And-Composite-Numbers/MinPerimeterRectangle/","title":"Min Perimeter Rectangle","keywords":"","body":"MinPerimeterRectangle Find the minimal perimeter of any rectangle whose area equals N. An integer N is given, representing the area of some rectangle. The area of a rectangle whose sides are of length A and B is A B, and the perimeter is 2 (A + B). The goal is to find the minimal perimeter of any rectangle whose area equals N. The sides of this rectangle should be only integers. For example, given integer N = 30, rectangles of area 30 are: (1, 30), with a perimeter of 62, (2, 15), with a perimeter of 34, (3, 10), with a perimeter of 26, (5, 6), with a perimeter of 22. Write a function: func Solution(N int) int that, given an integer N, returns the minimal perimeter of any rectangle whose area is exactly equal to N. For example, given an integer N = 30, the function should return 22, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..1,000,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 給整數的面積N, 找出面積為N的最小周長 解題思路 從不大於N的平方根的數開始遍歷,只要找到N的因子 因為越往後所得的周長越大.邊長接近平方根的矩形的周長是最小的 來源 https://app.codility.com/programmers/lessons/10-prime_and_composite_numbers/min_perimeter_rectangle/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0010.Prime-And-Composite-Numbers/MinPerimeterRectangle/MinPerimeterRectangle.go package minperimeterrectangle import ( \"math\" ) // O(sqrt(N)) func Solution(N int) int { if N © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0010.Prime-And-Composite-Numbers/Peaks/":{"url":"Codility/Lesson/0010.Prime-And-Composite-Numbers/Peaks/","title":"Peaks","keywords":"","body":"Peaks Divide an array into the maximum number of same-sized blocks, each of which should contain an index P such that A[P - 1] A[P + 1]. A non-empty array A consisting of N integers is given. A peak is an array element which is larger than its neighbors. More precisely, it is an index P such that 0 A[P + 1]. For example, the following array A: A[0] = 1 A[1] = 2 A[2] = 3 A[3] = 4 A[4] = 3 A[5] = 4 A[6] = 1 A[7] = 2 A[8] = 3 A[9] = 4 A[10] = 6 A[11] = 2 has exactly three peaks: 3, 5, 10. We want to divide this array into blocks containing the same number of elements. More precisely, we want to choose a number K that will yield the following blocks: A[0], A[1], ..., A[K − 1], A[K], A[K + 1], ..., A[2K − 1], ... A[N − K], A[N − K + 1], ..., A[N − 1]. What's more, every block should contain at least one peak. Notice that extreme elements of the blocks (for example A[K − 1] or A[K]) can also be peaks, but only if they have both neighbors (including one in an adjacent blocks). The goal is to find the maximum number of blocks into which the array A can be divided. Array A can be divided into blocks as follows: one block (1, 2, 3, 4, 3, 4, 1, 2, 3, 4, 6, 2). This block contains three peaks. two blocks (1, 2, 3, 4, 3, 4) and (1, 2, 3, 4, 6, 2). Every block has a peak. three blocks (1, 2, 3, 4), (3, 4, 1, 2), (3, 4, 6, 2). Every block has a peak. Notice in particular that the first block (1, 2, 3, 4) has a peak at A[3], because A[2] A[4], even though A[4] is in the adjacent block. However, array A cannot be divided into four blocks, (1, 2, 3), (4, 3, 4), (1, 2, 3) and (4, 6, 2), because the (1, 2, 3) blocks do not contain a peak. Notice in particular that the (4, 3, 4) block contains two peaks: A[3] and A[5]. The maximum number of blocks that array A can be divided into is three. Write a function: func Solution(A []int) int that, given a non-empty array A consisting of N integers, returns the maximum number of blocks into which A can be divided. If A cannot be divided into some number of blocks, the function should return 0. For example, given: A[0] = 1 A[1] = 2 A[2] = 3 A[3] = 4 A[4] = 3 A[5] = 4 A[6] = 1 A[7] = 2 A[8] = 3 A[9] = 4 A[10] = 6 A[11] = 2 the function should return 3, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; each element of array A is an integer within the range [0..1,000,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 將 array 分成同樣長度的區塊, 買個區塊至少包含一個peak. 解題思路 先找出所有peak的index 寫入peaks array. \b從peaks的長度開始往下找, 將 A 拆成區塊, 每個區塊檢查是否有有找到peak 來源 https://app.codility.com/programmers/lessons/10-prime_and_composite_numbers/peaks/ https://www.martinkysel.com/codility-peaks-solution/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0010.Prime-And-Composite-Numbers/Peaks/Peaks.go package peaks /* expected worst-case time complexity is O(N*log(log(N))); expected worst-case space complexity is O(N) */ func Solution(A []int) int { // 先找出peaks peaks := []int{} for i := 1; i A[i+1] { peaks = append(peaks, i) } } if len(peaks) 0; size-- { if len(A)%size == 0 { // 每個區塊的size blockSize := len(A) / size found := make(map[int]bool, size) foundCnt := 0 for _, peak := range peaks { // 檢查每個區塊是否有找到 peak blockNr := peak / blockSize if ok := found[blockNr]; !ok { found[blockNr] = true foundCnt++ } } if foundCnt == size { return size } } } return 0 } /* def solution(A): peaks = [] for idx in range(1, len(A)-1): if A[idx-1] A[idx+1]: peaks.append(idx) if len(peaks) == 0: return 0 for size in range(len(peaks), 0, -1): if len(A) % size == 0: block_size = len(A) // size found = [False] * size found_cnt = 0 for peak in peaks: block_nr = peak//block_size if found[block_nr] == False: found[block_nr] = True found_cnt += 1 if found_cnt == size: return size return 0 */ © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0011.Sieve-of-Eratosthenes/CountNonDivisible/":{"url":"Codility/Lesson/0011.Sieve-of-Eratosthenes/CountNonDivisible/","title":"Count Non Divisible","keywords":"","body":"CountNonDivisible Calculate the number of elements of an array that are not divisors(因數) of each element. You are given an array A consisting of N integers. For each number A[i] such that 0 ≤ i For example, consider integer N = 5 and array A such that: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 3 A[4] = 6 For the following elements: A[0] = 3, the non-divisors are: 2, 6, A[1] = 1, the non-divisors are: 3, 2, 3, 6, A[2] = 2, the non-divisors are: 3, 3, 6, A[3] = 3, the non-divisors are: 2, 6, A[4] = 6, there aren't any non-divisors. Write a function: func Solution(A []int) []int that, given an array A consisting of N integers, returns a sequence of integers representing the amount of non-divisors. Result array should be returned as an array of integers. For example, given: A[0] = 3 A[1] = 1 A[2] = 2 A[3] = 3 A[4] = 6 the function should return [2, 4, 3, 2, 0], as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..50,000]; each element of array A is an integer within the range [1..2 * N]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 算出array中所有元素的非因子數的個數 解題思路 先算數每個數字出現的次數存入map 遍歷A, 對於每個元素從1到sqrt(i)中找出因子,如果是因子,就去字典找出出現次數 最後用總長度減去因子數就可得出非因子數, 並將結果存入map, 空間換取時間 factor 來源 https://app.codility.com/programmers/lessons/11-sieve_of_eratosthenes/count_non_divisible/ https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L11_Sieve%20of%20Eratosthenes/11.1%20CountNonDivisible.md 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0011.Sieve-of-Eratosthenes/CountNonDivisible/CountNonDivisible.go package countnondivisible import ( \"math\" ) /* Task Score 100% Correctness 100% Performance 100% */ func Solution(A []int) []int { // write your code in Go 1.4 result := []int{} if len(A) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0011.Sieve-of-Eratosthenes/CountSemiprimes/":{"url":"Codility/Lesson/0011.Sieve-of-Eratosthenes/CountSemiprimes/","title":"Count Semiprimes","keywords":"","body":"CountSemiprimes Count the semiprime(半質數:兩個質數的乘積所得的自然數我們稱之為半質數) numbers in the given range [a..b] A prime is a positive integer X that has exactly two distinct divisors: 1 and X. The first few prime integers are 2, 3, 5, 7, 11 and 13. A semiprime is a natural number that is the product of two (not necessarily distinct) prime numbers. The first few semiprimes are 4, 6, 9, 10, 14, 15, 21, 22, 25, 26. You are given two non-empty arrays P and Q, each consisting of M integers. These arrays represent queries about the number of semiprimes within specified ranges. Query K requires you to find the number of semiprimes within the range (P[K], Q[K]), where 1 ≤ P[K] ≤ Q[K] ≤ N. For example, consider an integer N = 26 and arrays P, Q such that: P[0] = 1 Q[0] = 26 P[1] = 4 Q[1] = 10 P[2] = 16 Q[2] = 20 The number of semiprimes within each of these ranges is as follows: (1, 26) is 10, (4, 10) is 4, (16, 20) is 0. Write a function: func Solution(N int, P []int, Q []int) []int that, given an integer N and two non-empty arrays P and Q consisting of M integers, returns an array consisting of M elements specifying the consecutive answers to all the queries. For example, given an integer N = 26 and arrays P, Q such that: P[0] = 1 Q[0] = 26 P[1] = 4 Q[1] = 10 P[2] = 16 Q[2] = 20 the function should return the values [10, 4, 0], as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..50,000]; M is an integer within the range [1..30,000]; each element of arrays P, Q is an integer within the range [1..N]; P[i] ≤ Q[i]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 計算[a,b]區間得半質數的個數 解題思路 先把半質數列表找出來. (半質數:兩個質數的乘積所得的自然數我們稱之為半質數ㄝ開始的幾個半質數是4, 6, 9, 10, 14, 15, 21, 22, 25, 26, ... （OEIS中的數列A001358）它們包含1及自己在內合共有3或4個因數) 計算當前array和前面一共有幾個半質數 遍歷P arry 算出 Q跟P 之前的半質數總和差, 並寫入結果 來源 https://app.codility.com/programmers/lessons/11-sieve_of_eratosthenes/count_semiprimes/ https://github.com/Luidy/codility-golang/blob/master/Lesson11/02_countSemiprimes.go https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L11_Sieve%20of%20Eratosthenes/11.2%20CountSemiprimes.md 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0011.Sieve-of-Eratosthenes/CountSemiprimes/CountSemiprimes.go package countsemiprimes func Solution(N int, P []int, Q []int) []int { semiPrime := []int{} // 半質數:兩個質數的乘積所得的自然數我們稱之為半質數. // 4, 6, 9, 10, 14, 15, 21,22,25,26,33,34,35,38,39,46,49,51,55,57,58,62,65,69,74,77,82,85,86,87,91,93,94,95,106, ... // 它們包含1及自己在內合共有3或4個因數 for i := 1; i 4 { sign = 1 semiPrime = append(semiPrime, 0) break } } if sign != 1 { if factorCount >= 3 { semiPrime = append(semiPrime, i) } else { semiPrime = append(semiPrime, 0) } } } // idx 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // semiPrime 0 0 0 4 0 6 0 0 9 10 0 0 0 14 15 0 0 0 0 0 21 22 0 0 25 26 // fmt.Println(\"semiPrime\", semiPrime) // 當前array和前面一共有幾個半質數 indexMap := make(map[int]int) // 如果是半質數添加到 map semiMap := make(map[int]struct{}) count := 0 for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0012.Euclidean-Algorithm/ChocolatesByNumbers/":{"url":"Codility/Lesson/0012.Euclidean-Algorithm/ChocolatesByNumbers/","title":"Chocolates By Numbers","keywords":"","body":"ChocolatesByNumbers There are N chocolates in a circle. Count the number of chocolates you will eat. Two positive integers N and M are given. Integer N represents the number of chocolates arranged in a circle, numbered from 0 to N − 1. You start to eat the chocolates. After eating a chocolate you leave only a wrapper. You begin with eating chocolate number 0. Then you omit(忽略) the next M − 1 chocolates or wrappers on the circle, and eat the following one. More precisely(恰恰), if you ate chocolate number X, then you will next eat the chocolate with number (X + M) modulo N (remainder of division). You stop eating when you encounter an empty wrapper. For example, given integers N = 10 and M = 4. You will eat the following chocolates: 0, 4, 8, 2, 6. The goal is to count the number of chocolates that you will eat, following the above rules. Write a function: func Solution(N int, M int) int that, given two positive integers N and M, returns the number of chocolates that you will eat. For example, given integers N = 10 and M = 4. the function should return 5, as explained above. Write an efficient algorithm for the following assumptions: N and M are integers within the range [1..1,000,000,000]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 N塊巧克力,如果吃的是X號 下一個是吃 (X + M) modulo N 號 總共可以吃幾顆. 解題思路 方法ㄧ: 從0號開始吃, 下一個號碼+M-1號. 迴圈去跑 方法二: 可以吃到的巧克力的數量就是總的巧克力顆數 N 除以 N 和 M 的最大公因數. 計算 N和M的最大公因數P, N除以P得到商即為答案 來源 https://app.codility.com/programmers/lessons/12-euclidean_algorithm/chocolates_by_numbers/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0012.Euclidean-Algorithm/ChocolatesByNumbers/ChocolatesByNumbers.go package chocolatesbynumbers func gcd(N int, M int) int { if N%M == 0 { return M } else { return gcd(M, N%M) } } /* 可以吃到的巧克力的數量就是總的巧克力顆數 N 除以 N 和 M 的最大公因數 計算 N和M的最大公因數P, N除以P得到商即為答案 O(log(N + M)) */ func Solution(N int, M int) int { return N / gcd(N, M) } /* Task Score 75% Correctness 100% Performance 50% input (947853, 4453) the solution exceeded the time limit. 從0號開始吃, 下一個號碼+M-1號 */ func SolutionBurst(N int, M int) int { eaten := make(map[int]struct{}) eatCount := 0 if N == 1 || M == 1 { return N } for { sumNum := eatCount * M startNum := sumNum % N if _, ok := eaten[startNum]; !ok { eaten[startNum] = struct{}{} eatCount++ } else { // 找到已吃過的巧克力 break } } return eatCount } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0012.Euclidean-Algorithm/CommonPrimeDivisors/":{"url":"Codility/Lesson/0012.Euclidean-Algorithm/CommonPrimeDivisors/","title":"Common Prime Divisors","keywords":"","body":"CommonPrimeDivisors Check whether two numbers have the same prime divisors. A prime is a positive integer X that has exactly two distinct divisors: 1 and X. The first few prime integers are 2, 3, 5, 7, 11 and 13. A prime D is called a prime divisor(質因數) of a positive integer P if there exists a positive integer K such that D * K = P. For example, 2 and 5 are prime divisors of 20. You are given two positive integers N and M. The goal is to check whether the sets of prime divisors of integers N and M are exactly the same. For example, given: N = 15 and M = 75, the prime divisors are the same: {3, 5}; N = 10 and M = 30, the prime divisors aren't the same: {2, 5} is not equal to {2, 3, 5}; N = 9 and M = 5, the prime divisors aren't the same: {3} is not equal to {5}. Write a function: func Solution(A []int, B []int) int that, given two non-empty arrays A and B of Z integers, returns the number of positions K for which the prime divisors of A[K] and B[K] are exactly the same. For example, given: A[0] = 15 B[0] = 75 A[1] = 10 B[1] = 30 A[2] = 3 B[2] = 5 the function should return 1, because only one pair (15, 75) has the same set of prime divisors. Write an efficient algorithm for the following assumptions: Z is an integer within the range [1..6,000]; each element of arrays A, B is an integer within the range [1..2,147,483,647]. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 判斷兩個數是否有相同的質因數 解題思路 先判斷兩數的最大公因數, 再判斷兩個數是含有最大公因數沒有的因子 15 , 75 的最大公因數為 35 15= 35 75= 355 來源 https://app.codility.com/programmers/lessons/12-euclidean_algorithm/common_prime_divisors/ https://github.com/Anfany/Codility-Lessons-By-Python3/blob/master/L12_Euclidean%20algorithm/12.2%20CommonPrimeDivisors.md https://github.com/Luidy/codility-golang/blob/master/Lesson12/02_commonPrimeDivisors.go 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0012.Euclidean-Algorithm/CommonPrimeDivisors/CommonPrimeDivisors.go package commonprimedivisors /* func gcd(a, b int) int { for b != 0 { t := b b = a % b a = t } return a } */ func gcd(N int, M int) int { if N%M == 0 { return M } else { return gcd(M, N%M) } } func Solution(A []int, B []int) int { result := 0 for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0013.Fibonacci-Numbers/FibFrog/":{"url":"Codility/Lesson/0013.Fibonacci-Numbers/FibFrog/","title":"Fib Frog","keywords":"","body":"FibFrog The Fibonacci sequence is defined using the following recursive formula: F(0) = 0 F(1) = 1 F(M) = F(M - 1) + F(M - 2) if M >= 2 A small frog wants to get to the other side of a river. The frog is initially located at one bank of the river (position −1) and wants to get to the other bank (position N). The frog can jump over any distance F(K), where F(K) is the K-th Fibonacci number. Luckily, there are many leaves on the river, and the frog can jump between the leaves, but only in the direction of the bank at position N. The leaves on the river are represented in an array A consisting of N integers. Consecutive(連續的) elements of array A represent consecutive positions from 0 to N − 1 on the river. Array A contains only 0s and/or 1s: 0 represents a position without a leaf; 1 represents a position containing a leaf. The goal is to count the minimum number of jumps in which the frog can get to the other side of the river (from position −1 to position N). The frog can jump between positions −1 and N (the banks of the river) and every position containing a leaf. For example, consider array A such that: A[0] = 0 A[1] = 0 A[2] = 0 A[3] = 1 A[4] = 1 A[5] = 0 A[6] = 1 A[7] = 0 A[8] = 0 A[9] = 0 A[10] = 0 The frog can make three jumps of length F(5) = 5, F(3) = 2 and F(5) = 5. Write a function: func Solution(A []int) int that, given an array A consisting of N integers, returns the minimum number of jumps by which the frog can get to the other side of the river. If the frog cannot reach the other side of the river, the function should return −1. For example, given: A[0] = 0 A[1] = 0 A[2] = 0 A[3] = 1 A[4] = 1 A[5] = 0 A[6] = 1 A[7] = 0 A[8] = 0 A[9] = 0 A[10] = 0 the function should return 3, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [0..100,000]; each element of array A is an integer that can have one of the following values: 0, 1. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. 題目大意 一只小青蛙想到對岸。它開始位於河的另一邊 位置-1, 想要到對面的河岸 位置N . 青蛙可以跳任意距離 F(K). 其中F(K)是第K個斐波那契數. 且河上有許多樹葉 A[0] = 0 代表位置 0 沒有樹葉, 1 代表有樹葉 青蛙可以在樹葉之間跳, 但只能朝河岸 N 的方向跳 找出最小跳的次數 解題思路 廣度優先搜尋 (Breadth-First Search, BFS) 問題. 對於河上有樹葉的位置index, 則遍歷比index小的斐波那契數f, 只要 index - f 這個位置可以達到, 這index的位置就可以經過一次跳躍長度為f 來源 https://app.codility.com/programmers/lessons/13-fibonacci_numbers/fib_frog/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0013.Fibonacci-Numbers/FibFrog/FibFrog.go package fibfrog /** * @description: 產生不大於n的斐波那契數的列表 * @param {int} N * @return {*} */ func Fib(N int) (fibArr []int) { fibArr = append(fibArr, 0) fibArr = append(fibArr, 1) fibArr = append(fibArr, 1) i := 2 for fibArr[i] 0 { continue } // get the optimal jump count to reach this leaf if A[i] == 1 { // 有樹葉 // 遍歷斐波那契數列, 尋找最少的跳躍次數 minJump := i + 1 canJump := false for _, f := range fibArr { previousIdx := i - f if previousIdx reachable[previousIdx] { // 此 previousIdx 位置可以到達 // fmt.Printf(\"%d :previousIdx = %d reachable = %v \\n\", i, previousIdx, reachable) minJump = reachable[previousIdx] canJump = true } } if canJump { reachable[i] = minJump + 1 } } // fmt.Printf(\"i=%d , reachable = %v \\n\", i, reachable) } if reachable[len(reachable)-1] == 0 { return -1 } return reachable[len(reachable)-1] } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Codility/Lesson/0015.Caterpillar-Method/AbsDistinct/":{"url":"Codility/Lesson/0015.Caterpillar-Method/AbsDistinct/","title":"Abs Distinct","keywords":"","body":"AbsDistinct A non-empty array A consisting of N numbers is given. The array is sorted in non-decreasing order. The absolute distinct count of this array is the number of distinct absolute values among the elements of the array. For example, consider array A such that: A[0] = -5 A[1] = -3 A[2] = -1 A[3] = 0 A[4] = 3 A[5] = 6 The absolute distinct count of this array is 5, because there are 5 distinct absolute values among the elements of this array, namely 0, 1, 3, 5 and 6. Write a function: func Solution(A []int) int that, given a non-empty array A consisting of N numbers, returns absolute distinct count of array A. For example, given array A such that: A[0] = -5 A[1] = -3 A[2] = -1 A[3] = 0 A[4] = 3 A[5] = 6 the function should return 5, as explained above. Write an efficient algorithm for the following assumptions: N is an integer within the range [1..100,000]; each element of array A is an integer within the range [−2,147,483,648..2,147,483,647]; array A is sorted in non-decreasing order. Copyright 2009–2021 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited. \"有序數組中絕對值不同的數的個數\"指的是，一個已經排好序的整數數組中絕對值不相同的數字的個數， 例如： A[0] = -5 A[1] = -3 A[2] = -1 A[3] = 0 A[4] = 3 A[5] = 6 絕對值不同的數的個數為 5， 因為其中有 5 個不同的絕對值： 0, 1, 3, 5, 6 編寫一個函數： func Solution(A []int) int 請返回給定有序數組中絕對值不同的數的個數。 例如，給出數組A： A[0] = -5 A[1] = -3 A[2] = -1 A[3] = 0 A[4] = 3 A[5] = 6 函數應返回5。 假定: N 是 [1..100,000] 內的 整數; 數組 A 每個元素是取值範圍 [−2,147,483,648..2,147,483,647] 內的 整數 ; 數組 A 是 非-遞增 序列. 題目大意 解題思路 來源 https://app.codility.com/programmers/lessons/15-caterpillar_method/abs_distinct/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Codility/Lesson/0015.Caterpillar-Method/AbsDistinct/AbsDistinct.go © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"GeeksforGeeks/SortingAlgorithms/0031.Find-Minimum-Difference-Between-Any-Two-Elements/":{"url":"GeeksforGeeks/SortingAlgorithms/0031.Find-Minimum-Difference-Between-Any-Two-Elements/","title":"0031.Find-Minimum-Difference-Between-Any-Two-Elements","keywords":"","body":"0031. Find Minimum Difference Between Any Two Elements 題目 Given an unsorted array, find the minimum difference between any pair in given array. Examples : Input : {1, 5, 3, 19, 18, 25}; Output : 1 Minimum difference is between 18 and 19 Input : {30, 5, 20, 9}; Output : 4 Minimum difference is between 5 and 9 Input : {1, 19, -4, 31, 38, 25, 100}; Output : 5 Minimum difference is between 1 and -4 來源 https://www.geeksforgeeks.org/find-minimum-difference-pair/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/GeeksforGeeks/SortingAlgorithms/0031.Find-Minimum-Difference-Between-Any-Two-Elements/Find-Minimum-Difference-Between-Any-Two-Elements.go package findminimumdifferencebetweenanytwoelements import ( \"math\" \"sort\" ) /* https://yourbasic.org/golang/absolute-value-int-float/ http://cavaliercoder.com/blog/optimized-abs-for-int64-in-go.html fmt.Println(abs(math.MinInt64)) // Output: -9223372036854775808 // 似乎比較快 func WithTwosComplement(n int64) int64 { y := n >> 63 // y ← x ⟫ 63 return (n ^ y) - y // (x ⨁ y) - y } */ func abs(n int) int { if n > 63 // y ← x ⟫ 63 return (n ^ y) - y // (x ⨁ y) - y } // O(n Log n) func FindMinDiff(nums []int) int { if len(nums) tmp { minSize = tmp } } if minSize == math.MaxInt32 { minSize = 0 } return minSize } func FindMinDiff2(nums []int) int { if len(nums) tmp { minSize = tmp } } if minSize == math.MaxInt32 { minSize = 0 } return minSize } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0000.xxxx/":{"url":"Leetcode/0000.xxxx/","title":"NUM.LEETCODETITLE","summary":"NUM.FOLDERPATH","keywords":"","body":"NUM.LEETCODETITLE tagsstart LeetCode Go Easy/Medium/Hard LEETCODETITLE tagsstop 題目 題目大意 解題思路 Big O 時間複雜 : `` 空間複雜 : `` 來源 LEETCODELINK https://leetcode.cn/problems/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/NUM.FOLDERPATH/main.go Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0001.Two-Sum/Merging-2-Packages/":{"url":"Leetcode/0001.Two-Sum/Merging-2-Packages/","title":"Merging 2 Packages","keywords":"","body":"Given a package with a weight limit limit and an array arr of item weights, implement a function getIndicesOfItemWeights that finds two items whose sum of weights equals the weight limit. The function should return a pair [i, j] of the indices of the item weights, ordered such that i > j. If such a pair doesn’t exist, return an empty array. input: arr = [4, 6, 10, 15, 16], lim = 21 output: [3, 1] # since these are the indices of the weights 6 and 15 whose sum equals to 21 © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0001.Two-Sum/":{"url":"Leetcode/0001.Two-Sum/","title":"0001.Two Sum","summary":null,"keywords":"","body":"1. Two Sum tagsstart Easy tagsstop 题目 Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 題目大意 在數組中找到 2 個數之和等於給定值的數字, 結果返回 2 個數字在數組中的下標. 解題思路 暴力解: 時間複雜 O(n^2), 空間複雜 O(1) 這道題最優的做法時間複雜度是 O(n) 順序掃描數組, 對每一個元素，在 map 中找能組合給定值的另一半數字, 如果找到了, 直接返回 2 個數字的下標即可. 如果找不到, 就把這個數字存入 map 中, 等待掃到“另一半”數字的時候, 再取出來返回結果. 如果nums是有序 可以使用左右指針 來源 https://leetcode-cn.com/problems/two-sum/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0001.Two-Sum/twosum.go package twosum // 時間複雜 O(n^2), 空間複雜 O(1) func Twosum(nums []int, target int) []int { for i, _ := range nums { for j := i + 1; j target { // right-- // } // } // return []int{0, 0} // } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0002.Add-Two-Numbers/":{"url":"Leetcode/0002.Add-Two-Numbers/","title":"0002.Add Two Numbers","summary":"0002.Add-Two-Numbers","keywords":"","body":"0002.Add Two Numbers tagsstart LeetCode Go Medium Add Two Numbers Linked List Math Recursion Amazon Apple Facebook Microsoft Bloomberg tagsstop 題目 題目大意 解題思路 鏈表雙指標技巧 和加法運算過程中對進位的處理。 注意這個 carry 變數的處理，在我們手動類比加法過程的時候會經常用到。 遍歷 l1跟 l2. 講兩個list的val相加, 並且記錄進位的值給next使用 最後如果 carry 還有的話, 需要產生一個新的節點 Big O 時間複雜 : O(max⁡(m,n) 時間複雜度： O(max⁡(m,n)) ，其中 m 和 n 分別為兩個鏈表的長度。 我們要遍歷兩個鏈表的全部位置，而處理每個位置只需要 O(1) 的時間 空間複雜 : O(1) O(1) 。 注意返回值不計入空間複雜度 來源 https://leetcode.com/problems/add-two-numbers/description/ https://leetcode.cn/problems/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0002.Add-Two-Numbers/main.go package addtwonumbers // 時間複雜 O(max(m,n)), 空間複雜 O(1) /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 遍歷 l1跟 l2. 講兩個list的val相加, 並且記錄進位的值給next使用 // 最後如果 carry 還有的話, 需要產生一個新的節點 func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { var result, tail *ListNode carry := 0 for l1 != nil || l2 != nil { n1, n2 := 0, 0 if l1 != nil { n1 = l1.Val l1 = l1.Next } if l2 != nil { n2 = l2.Val l2 = l2.Next } sum := n1 + n2 + carry sum, carry = sum%10, sum/10 if result == nil { result = &ListNode{Val: sum, Next: nil} tail = result } else { tail.Next = &ListNode{Val: sum, Next: nil} tail = tail.Next } } // 最後如果 carry 還有的話, 需要產生一個新的節點 if carry > 0 { tail.Next = &ListNode{Val: carry, Next: nil} } return result } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0003.Longest-Substring-Without-Repeating-Characters/":{"url":"Leetcode/0003.Longest-Substring-Without-Repeating-Characters/","title":"0003.Longest Substring Without Repeating Characters","summary":"0003.Longest Substring Without Repeating Characters","keywords":"","body":"3. Longest Substring Without Repeating Characters tagsstart LeetCode Go Medium Longest Substring Without Repeating Characters Sliding Window Array Hash Table String tagsstop 题目 Given a string, find the length of the longest substring without repeating characters. Example 1: Input: \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: Input: \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: Input: \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Note that the answer must be a substring, \"pwke\" is a subsequence and not a substring. 題目大意 在一個字符串重尋找沒有重複字母的最長子串。 解題思路 這一題和第 438 題，第 3 題，第 76 題，第 567 題類似，用的思想都是\"滑動窗口\"。 滑動窗口的右邊界不斷的右移，只要沒有重複的字符，就持續向右擴大窗口邊界。一旦出現了重複字符，就需要縮小左邊界，直到重複的字符移出了左邊界，然後繼續移動滑動窗口的右邊界。以此類推，每次移動需要計算當前長度，並判斷是否需要更新最大長度，最終最大的值就是題目中的所求。 O(n) 用空間換取時間, map紀錄已出現過的字符, 如果map效能不好時可使用數組(Slice)來改善 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0003.Longest-Substring-Without-Repeating-Characters/ https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0003.Longest-Substring-Without-Repeating-Characters/Longest-Substring-Without-Repeating-Characters.go package longestSubstringwithoutrepeatingcharacters // LengthOfLongestSubstring 暴力解 func LengthOfLongestSubstring(s string) int { slength := len(s) if slength == 0 || slength == 1 { return slength } tmpLen := 1 var maxLen = 1 for i := 1; i maxLen { maxLen = tmpLen } } return maxLen } // LengthOfLongestSubstringMap 用map 紀錄是否重複. func LengthOfLongestSubstringMap(s string) int { slength := len(s) if slength == 0 || slength == 1 { return slength } charMap := make(map[byte]bool) maxLen, left, right := 0, 0, 0 for left = slength || right >= len(s) { break } } return maxLen } // LengthOfLongestSubstringBit 用map效能不好時可使用數組改善 func LengthOfLongestSubstringBit(s string) int { slength := len(s) if slength == 0 || slength == 1 { return slength } // ASCII 0~255 charMap := [256]bool{} maxLen, left, right := 0, 0, 0 for left = slength || right >= len(s) { break } } return maxLen } Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0003.Longest-Substring-Without-Repeating-Characters cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkLengthOfLongestSubstring-8 66143602 19.08 ns/op 0 B/op 0 allocs/op BenchmarkLengthOfLongestSubstringMap-8 2524627 397.8 ns/op 0 B/op 0 allocs/op BenchmarkLengthOfLongestSubstringBit-8 65099846 21.37 ns/op 0 B/op 0 allocs/op PASS ok LeetcodeGolang/Leetcode/0003.Longest-Substring-Without-Repeating-Characters 4.193s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0005.Longest-Palindromic-Substring/":{"url":"Leetcode/0005.Longest-Palindromic-Substring/","title":"0005. Longest Palindromic Substring","summary":"0005. Longest Palindromic Substring","keywords":"","body":"0005.Longest Palindromic Substring tagsstart LeetCode Go Medium DP Amazon Microsoft Google Adobe Facebook tagsstop 題目 Given a string s, return the longest palindromic substring in s. A string is called a palindrome string if the reverse of that string is the same as the original string. Example 1: Input: s = \"babad\" Output: \"bab\" Explanation: \"aba\" is also a valid answer. Example 2: Input: s = \"cbbd\" Output: \"bb\" Constraints: 1 s consist of only digits and English letters. 題目大意 給你一個字符串 s，找到 s 中最長的回文子串。 解題思路 每一個字符本身都是回文 長度為 2, 且首尾字符相同則為回文 長度>=3, 如果頭尾相同, 則去掉頭尾後可看是合是回文. 如果頭尾不同則不是回文 來源 https://leetcode.com/problems/longest-palindromic-substring/ https://leetcode.cn/problems/longest-palindromic-substring/solutions/1348874/s-by-xext-5zk3/ 解答 package longestpalindromicsubstring func longestPalindrome(s string) string { dp := make([][]bool, len(s)) result := s[0:1] for i := 0; i len(result) { result = s[start : end+1] } } } return result } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0011.Container-With-Most-Water/":{"url":"Leetcode/0011.Container-With-Most-Water/","title":"0011.Container With Most Water","summary":"0011.Container-With-Most-Water","keywords":"","body":"0011.Container With Most Water tagsstart LeetCode Go Medium Container With Most Water Amazon Microsoft Adobe Facebook Google Array Two Pointers Greedy tagsstop 題目 題目大意 解題思路 利用雙指針, 找出最小的高並乘上兩指針距離, 得出面積 當左指針高度比右指針高度高時, 將右指針往左移, 反之將左指針往右移. Big O 時間複雜 : O(n) 空間複雜 : O(1) 來源 https://leetcode.com/problems/container-with-most-water/description/ https://leetcode.cn/problems/container-with-most-water/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0011.Container-With-Most-Water/main.go package containerwithmostwater // 時間複雜 O(n), 空間複雜 O(1) func maxArea(height []int) int { left, right := 0, len(height)-1 result := 0 for left height[right] { right-- } else { left++ } } return result } func min(a, b int) int { if a b { return a } return b } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0015.3Sum/":{"url":"Leetcode/0015.3Sum/","title":"0015. 3Sum","summary":"0015.3Sum","keywords":"","body":"15. 3Sum tagsstart LeetCode Go Medium 3Sum Array Two Pointers Sorting tagsstop 題目 Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 題目大意 給定一個數組，要求在這個數組中找出 3 個數之和為 0 的所有組合。 解題思路 用 map 提前計算好任意 2 個數字之和，保存起來，可以將時間複雜度降到 O(n^2)。這一題比較麻煩的一點在於，最後輸出解的時候，要求輸出不重複的解。數組中同一個數字可能出現多次，同一個數字也可能使用多次，但是最後輸出解的時候，不能重複。例如[-1，-1，2] 和[2, -1, -1]、[-1, 2, -1] 這3 個解是重複的，即使-1 可能出現100 次，每次使用的-1 的數組下標都是不同的。 這裡就需要去重和排序了。 map 記錄每個數字出現的次數，然後對 map 的 key 數組進行排序，最後在這個排序以後的數組裡面掃，找到另外 2 個數字能和自己組成 0 的組合。 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0015.3Sum/ https://leetcode-cn.com/problems/3sum/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0015.3Sum/3Sum.go package threesum import ( \"sort\" ) // ThreeSumBurst : 暴力解 : O(n^3) func ThreeSumBurst(nums []int) [][]int { result := [][]int{} sort.Ints(nums) // O(n log n) for i := 0; i 0 && nums[i] == nums[i-1] { continue } for j := i + 1; j i+1 && nums[j] == nums[j-1] { continue } for k := j + 1; k 1 && nums[i] == nums[i-1] { // 去掉重複 start = i - 1 } for start i { if start > 0 && nums[start] == nums[start-1] { // 去掉重複 start++ continue } if end 0 { end-- } else { start++ } } } return result } func ThreeSumHashTable(nums []int) [][]int { result := [][]int{} if len(nums) 0 && nums[i] == nums[i-1] { continue } seen := make(map[int]bool) target := -nums[i] // 目標值為當前元素的相反數 for j := i + 1; j 0 && nums[i] == nums[i-1] { continue } target, l, r := -nums[i], i+1, len(nums)-1 for l target { r-- } else if sum goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0015.3Sum cpu: Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz BenchmarkThreeSumBurst-4 9838000 121.4 ns/op 48 B/op 2 allocs/op BenchmarkThreeSumDoublePoint-4 9069201 112.8 ns/op 48 B/op 2 allocs/op BenchmarkThreeSumHashTable-4 7935907 147.1 ns/op 48 B/op 2 allocs/op BenchmarkThreeSumTwoPointer-4 10888315 103.5 ns/op 48 B/op 2 allocs/op PASS ok LeetcodeGolang/Leetcode/0015.3Sum 5.055s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0019.Remove-Nth-Node-From-End-of-List/":{"url":"Leetcode/0019.Remove-Nth-Node-From-End-of-List/","title":"0019. Remove Nth Node From End of List","summary":"0015.3Sum","keywords":"","body":"19. Remove Nth Node From End of List tagsstart LeetCode Go Medium Linked List Two Pointers Facebook Amazon Microsoft Google Bloomberg tagsstop 題目 Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2: Input: head = [1], n = 1 Output: [] Example 3: Input: head = [1,2], n = 1 Output: [1] Constraints: The number of nodes in the list is sz. 1 0 1 題目大意 找尋單linked list的 倒數第 n 個元素並刪除. 返回該 linked list的頭節點 解題思路 先讓 fast走 k 步, 然後 fast slow 同速前進 這樣當fast走到nil時, slow所在位置就是在倒數第 k 的節點 來源 https://leetcode.com/problems/remove-nth-node-from-end-of-list/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0019.Remove-Nth-Node-From-End-of-List/main.go package removenthnodefromendoflist /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ type ListNode struct { Val int Next *ListNode } // 產生 dummyHead,跟 preslow // 使用雙指針, 先讓 fast走 `k` 步, 然後 `fast slow 同速前進` // 這樣當fast走到nil時, slow所在位置就是在倒數第 k 的節點 // 將 slow的前一步(preslow)的next 指向 slow.Next func RemoveNthFromEnd(head *ListNode, n int) *ListNode { dummyHead := &ListNode{Next: head} preSlow, slow, fast := dummyHead, head, head for fast != nil { if n tags: Medium Leetcode Two Pointers © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0020.Valid-Parentheses/":{"url":"Leetcode/0020.Valid-Parentheses/","title":"0020. Valid Parentheses","summary":"0020.Valid-Parentheses","keywords":"","body":"0020. Valid Parentheses tagsstart LeetCode Go Easy Valid Parentheses tagsstop 題目 Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type. Example 1: Input: s = \"()\" Output: true Example 2: Input: s = \"()[]{}\" Output: true Example 3: Input: s = \"(]\" Output: false Constraints: 1 題目大意 解題思路 Big O 時間複雜 : 空間複雜 : 來源 https://leetcode.com/problems/valid-parentheses/ https://leetcode.cn/problems/valid-parentheses/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0020.Valid-Parentheses/main.go package validparentheses type Stack struct { runes []rune } func NewStack() *Stack { return &Stack{runes: []rune{}} } func (s *Stack) Push(str rune) { s.runes = append(s.runes, str) } func (s *Stack) Pop() rune { str := s.runes[len(s.runes)-1] s.runes = s.runes[:len(s.runes)-1] return str } // 時間複雜 O(n), 空間複雜 O(n) func IsValid(s string) bool { runeStack := NewStack() for _, v := range s { // fmt.Println(string(v)) if v == '(' || v == '[' || v == '{' { runeStack.Push(v) } else if (v == ')' && len(runeStack.runes) > 0 && runeStack.runes[len(runeStack.runes)-1] == '(') || (v == ']' && len(runeStack.runes) > 0 && runeStack.runes[len(runeStack.runes)-1] == '[') || (v == '}' && len(runeStack.runes) > 0 && runeStack.runes[len(runeStack.runes)-1] == '{') { runeStack.Pop() } else { return false } } return len(runeStack.runes) == 0 } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0021.Merge-Two-Sorted-Lists/":{"url":"Leetcode/0021.Merge-Two-Sorted-Lists/","title":"0021. Merge Two Sorted Lists","summary":"0021.Merge-Two-Sorted-Lists","keywords":"","body":"0021. Merge Two Sorted Lists tagsstart LeetCode Go Easy/Medium/Hard Merge Two Sorted Lists tagsstop 題目 題目大意 解題思路 Big O 時間複雜 : O( log n) 空間複雜 : O(1) 來源 https://leetcode.com/problems/merge-two-sorted-lists/description/ https://leetcode.cn/problems/merge-two-sorted-lists/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0021.Merge-Two-Sorted-Lists/main.go package mergetwosortedlists type ListNode struct { Val int Next *ListNode } // 時間複雜 O(log n), 空間複雜 O(1) func MergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { head := &ListNode{Next: nil} cur := head for list1 != nil && list2 != nil { if list1.Val Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0027.Remove-Element/":{"url":"Leetcode/0027.Remove-Element/","title":"0027.Remove Element","summary":null,"keywords":"","body":"27. Remove Element tagsstart Easy Array tagsstop 題目 Given an array nums and a value val, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn't matter what you leave beyond the new length. Example 1: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. It doesn't matter what you leave beyond the returned length. Example 2: Given nums = [0,1,2,2,3,0,4,2], val = 2, Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4. Note that the order of those five elements can be arbitrary. It doesn't matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this: // nums is passed in by reference. (i.e., without making a copy) int len = removeElement(nums, val); // any modification to nums in your function would be known by the caller. // using the length returned by your function, it prints the first len elements. for (int i = 0; i 題目大意 給定一個數組 nums 和一個數值 val，將數組中所有等於 val 的元素刪除，並返回剩餘的元素個數。 解題思路 這道題和第 283 題很像。這道題和第 283 題基本一致，283 題是刪除 0，這一題是給定的一個 val，實質是一樣的。 這里數組的刪除並不是真的刪除，只是將刪除的元素移動到數組後面的空間內，然後返回數組實際剩餘的元素個數，OJ 最終判斷題目的時候會讀取數組剩餘個數的元素進行輸出。 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0027.Remove-Element/ https://leetcode-cn.com/problems/remove-element/ https://mp.weixin.qq.com/s/wj0T-Xs88_FHJFwayElQlA 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0027.Remove-Element/Remove-Element.go package removeelement /* 雙指針法 雙指針法（快慢指針法）在數組和鍊錶的操作中是非常常見的，很多考察數組和鍊錶操作的面試題，都使用雙指針法 */ func RemoveElementDoublePoint(nums []int, val int) int { if len(nums) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0028.Find-the-Index-of-the-First-Occurrence-in-a-String/":{"url":"Leetcode/0028.Find-the-Index-of-the-First-Occurrence-in-a-String/","title":"0028. Find the Index of the First Occurrence in a String","summary":"0028.Find-the-Index-of-the-First-Occurrence-in-a-String","keywords":"","body":"0028. Find the Index of the First Occurrence in a String tagsstart LeetCode Go Easy Find the Index of the First Occurrence in a String Two Pointers String String Matching tagsstop 題目 題目大意 解題思路 Big O 時間複雜 : `` 空間複雜 : `` 來源 https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/ https://leetcode.cn/problems/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0028.Find-the-Index-of-the-First-Occurrence-in-a-String/main.go package findtheindexofthefirstoccurrenceinastring // 暴力解 // 時間複雜 O(M*N), 空間複雜 O() func strStr(haystack string, needle string) int { haystackLen := len(haystack) needleLen := len(needle) index := 0 for i := 0; i Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0033.Search-in-Rotated-Sorted-Array/":{"url":"Leetcode/0033.Search-in-Rotated-Sorted-Array/","title":"33. Search in Rotated Sorted Array","summary":"0033.Search-in-Rotated-Sorted-Array","keywords":"","body":"33. Search in Rotated Sorted Array tagsstart LeetCode Go Medium Array Binary Search 33. Search in Rotated Sorted Array Amazon Facebook Microsoft LinkedIn Apple tagsstop 題目 There is an integer array nums sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Example 3: Input: nums = [1], target = 0 Output: -1 Constraints: 1 題目大意 整個數組按照升序排序, 值不相同 在傳遞給函數之前， nums 在預先未知的某個下標 k （ 0 給你 旋轉後 的陣列 nums 和一個整數 target ，如果 nums 中存在這個目標值 target ，則返回它的下標，否則返回 -1 。 你必須設計一個時間複雜度為 O(log n) 的演演算法解決此問題。 解題思路 先判斷mid位於上半部還是下半部, 再來找target位於哪邊 最後看target是否有在左或右端點 Big O 時間複雜 : O(log n) 空間複雜 : O(1) 來源 https://leetcode.com/problems/search-in-rotated-sorted-array/description/ https://leetcode.cn/problems/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0033.Search-in-Rotated-Sorted-Array/main.go package searchinrotatedsortedarray // 時間複雜 O(), 空間複雜 O() func search(nums []int, target int) int { if nums == nil || len(nums) == 0 { return -1 } left, right := 0, len(nums)-1 for left > 1) if nums[mid] == target { return mid } if nums[mid] >= nums[left] { // mid在上半區 if nums[left] Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/":{"url":"Leetcode/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/","title":"0034. Find First and Last Position of Element in Sorted Array","summary":"0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array","keywords":"","body":"0034. Find First and Last Position of Element in Sorted Array tagsstart LeetCode Go Medium Find First and Last Position of Element in Sorted Array Array Binary Search tagsstop 題目 題目大意 解題思路 Big O 時間複雜 : O(log(n)) 空間複雜 : O(1) 來源 https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/ https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/main.go package findfirstandlastpositionofelementinsortedarray // 時間複雜 O(log(n)), 空間複雜 O(1) func searchRange(nums []int, target int) []int { result := []int{} // first index left, right := 0, len(nums)-1 for left > 1) // [0,1] => 0 if nums[mid] target { right = mid - 1 } else { right = mid } } if left == right && nums[left] == target { result = append(result, left) } else { result = append(result, -1) } // last index left, right = 0, len(nums)-1 for left > 1) // [0,1] => 1 if nums[mid] target { right = mid - 1 } else { left = mid } } if left == right && nums[left] == target { result = append(result, left) } else { result = append(result, -1) } return result } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0035.Search-Insert-Position/":{"url":"Leetcode/0035.Search-Insert-Position/","title":"0035.Search Insert Position","summary":null,"keywords":"","body":"35. Search Insert Position tagsstart Easy Array tagsstop 題目 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You may assume no duplicates in the array. Example 1: Input: [1,3,5,6], 5 Output: 2 Example 2: Input: [1,3,5,6], 2 Output: 1 Example 3: Input: [1,3,5,6], 7 Output: 4 Example 4: Input: [1,3,5,6], 0 Output: 0 題目大意 給定一個排序數組和一個目標值，在數組中找到目標值，並返回其索引。如果目標值不存在於數組中，返回它將會被按順序插入的位置。 你可以假設數組中無重複元素。 解題思路 給出一個已經從小到大排序後的數組，要求在數組中找到插入 target 元素的位置。 這一題是經典的二分搜索的變種題，在有序數組中找到最後一個比 target 小的元素。 \b- 只要看到面試題裡給出的數組是有序數組，都可以想一想是否可以使用二分法 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0035.Search-Insert-Position/ https://leetcode-cn.com/problems/search-insert-position/ 數組：每次遇到二分法，都是一看就會，一寫就廢 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0035.Search-Insert-Position/Search-Insert-Position.go package searchinsertposition // 暴力解 時間複雜 O(n) 空間複雜 O(1) func SearchInsertBurst(nums []int, target int) int { for i := 0; i = target { return i } } return len(nums) } //二分法 時間複雜 O(log n) 空間複雜 O(1) func SearchInsertBisection(nums []int, target int) int { left, right := 0, len(nums)-1 for left >1 if nums[mid] >= target { right = mid - 1 } else if nums[mid] >1 if nums[mid] >= target { right = mid - 1 } else { left = mid + 1 } } return left } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0046.Permutations/":{"url":"Leetcode/0046.Permutations/","title":"0046.Permutations","summary":null,"keywords":"","body":"46. Permutations tagsstart Medium Backtracking tagsstop 題目 Given a collection of distinct integers, return all possible permutations(排列). Example: Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 題目大意 給定一個沒有重複數字的序列，返回其所有可能的全排列。 解題思路 解決回朔問題可用一個決策樹的遍歷過程 路徑: 也就是已經做的選擇 選擇列表: 也就是當前可以做的選擇 結束條件: 也就是達到決策樹底層, 無法再做選擇的條件 result = [] def backtrack(路徑, 選擇列表): if 滿足結束條件: result.add(路徑) return for 選擇 in 選擇列表: 做選擇 backtrack(路徑, 選擇列表) 撤銷選擇 選擇:[1,2,3] [] [1]/ |[2] \\[3] [2]/ \\[3] [1]/ \\[3] [1]/ \\[2] |[3] |[2] |[3] |[1] |[2] |[1] 結果 [1,2,3] [1,3,2] [2,1,3] [2,3,1] [3,1,2] [3,2,1] 求出一個數組的排列組合中的所有排列，用 DFS 深搜即可。 這個問題可以看作有 ñ 個排列成一行的空格，我們需要從左往右依此填入題目給定的 ñ個數，每個數只能使用一次。 那麼很直接的可以想到一種窮舉的算法，即從左往右每一個位置都依此嘗試填入一個數， 看能不能填完這ñ 個空格，在程序中我們可以用「回溯法」來模擬這個過程 回溯法： 一種通過探索所有可能的候選解來找出所有的解的算法。如果候選解被確認不是一個解（或者至少不是最後一個解）， 回溯算法會通過在上一步進行一些變化拋棄該解，即回溯並且再次嘗試。 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/permutations/solution/quan-pai-lie-by-leetcode-solution-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0046.Permutations/ https://leetcode-cn.com/problems/permutations/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0046.Permutations/Permutations.go 時間複雜 O(n) package permutations func Permute(nums []int) [][]int { numsLen := len(nums) if numsLen == 0 { return [][]int{} } used, path, res := make([]bool, numsLen), []int{}, [][]int{} dfs(nums, numsLen, 0, path, &used, &res) return res } /* generatePermutation: (輸入數組, 數組長度, 遞迴到第幾層depth, path, 使用過的, 結果) 找最短路徑用**BFS**, 其他時用**DFS**用得多一些, 因為遞迴較好寫 假設有棵滿的二叉樹,節點數為 N. 對DFS來說空間複雜度就是遞迴, 最壞的情況就是樹的高度 O(log N) BFS算法, Queue每次都會存二叉樹一層的節點, 最壞的情況下空間複雜度應該就是樹的最下層的數量, 也就是 N/2. 空間複雜度 O(N) DFS（深度優先搜索）通常使用堆棧（Stack）來實現。在DFS中，您首先處理一個節點，然後將其子節點按某種順序推入堆棧中，接著繼續處理堆棧頂部的節點，直到堆棧為空。 */ func generatePermutation(nums []int, numsLen int, depth int, path []int, used *[]bool, res *[][]int) { if depth == numsLen { temp := make([]int, len(path)) copy(temp, path) *res = append(*res, temp) return } for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0049.Group-Anagrams/":{"url":"Leetcode/0049.Group-Anagrams/","title":"0049.Group Anagrams","summary":"Group Anagrams","keywords":"","body":"0049.Grop Anagrams tagsstart LeetCode Go Medium Group Anagrams tagsstop 題目 Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] Example 2: Input: strs = [\"\"] Output: [[\"\"]] Example 3: Input: strs = [\"a\"] Output: [[\"a\"]] Constraints: 1 0 strs[i] consists of lowercase English letters. 題目大意 分組出只用同樣字符產生的的單字 解題思路 方法一: 計數 由於互為字母異位詞的兩個字串包含的字母相同，因此兩個字串中的相同字母出現的次數一定是相同的，故可以將每個字母出現的次數使用字串表示，作為哈希表的鍵。 方法二: 排序 由於互為字母異位詞的兩個字串包含的字母相同，因此對兩個字串分別進行排序之後得到的字串一定是相同的，故可以將排序之後的字串作為哈希表的鍵。 來源 https://leetcode.com/problems/group-anagrams/ https://leetcode.com/problems/group-anagrams/solutions/3645797/hash-solution-with-explanation-smart-solution-o-n-m/ https://leetcode.cn/problems/group-anagrams/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0049.Group-Anagams/main.go package groupanagrams import \"sort\" // 使用計數: 時間複雜 O(nk), 空間複雜 O(nk) // n 是單詞的個數 , k是單字的最大長度 // O(n)遍歷單詞, 遍歷字符O(nk) func GroupAnagrams(strs []string) [][]string { m := make(map[[26]int][]string, len(strs)) for _, str := range strs { // 建立每一個string的特徵`count`, 藉由統計每個字母出現的次數 count := [26]int{} for _, b := range str { count[b-'a']++ } // 將同樣的次數的string放置在 map中 m[count] = append(m[count], str) } // 把map中的string放入到結果的 `[][]string` array 中 ans := [][]string{} for _, v := range m { ans = append(ans, v) } return ans } // 排序: 時間複雜 O(nklog(k)), 空間複雜 O(klog(k)) // n 是單詞的個數 , k是單字的最大長度 // 遍歷單詞 O(n) // 排序字符 O(klog(k)) func GroupAnagramsBySort(strs []string) [][]string { m := make(map[string][]string, len(strs)) for _, str := range strs { // 建立每一個string的特徵, 藉由統計排序 s := []byte(str) sort.Slice(s, func(i, j int) bool { return s[i] Benchmark go test -benchmem -run=none LeetcodeGolang/Leetcode/0049.Group-Anagrams -bench=. goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0049.Group-Anagrams cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkGroupAnagrams-8 899431 1615 ns/op 968 B/op 12 allocs/op BenchmarkGroupAnagramsBySort-8 592148 3566 ns/op 776 B/op 33 allocs/op PASS ok LeetcodeGolang/Leetcode/0049.Group-Anagrams 3.611s package groupanagrams import ( \"reflect\" \"sort\" \"testing\" ) var tests = []struct { arg1 []string want [][]string }{ { []string{\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"}, [][]string{ {\"bat\"}, {\"nat\", \"tan\"}, {\"ate\", \"eat\", \"tea\"}}, }, { []string{}, [][]string{}, }, { []string{\"a\"}, [][]string{ {\"a\"}}, }, } // 創建一個輔助函數，將字符串數組排序，以便比較 func sortSubStrings(groups [][]string) { for _, group := range groups { sort.Strings(group) } // 排序整個切片 sort.Slice(groups, func(i, j int) bool { return groups[i][0] © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0053.Maximum-Subarray/":{"url":"Leetcode/0053.Maximum-Subarray/","title":"0053.Maximum Subarray","summary":"0053.Maximum-Subarray","keywords":"","body":"53. Maximum Subarray tagsstart LeetCode Go Medium Array Dynamic Programming Blind75 tagsstop 題目 Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. 題目大意 給定一個整數數組 nums ，找到一個具有最大和的連續子數組（子數組最少包含一個元素），返回其最大和。 解題思路 這一題可以用 DP 求解也可以不用 DP。 題目要求輸出數組中某個區間內數字之和最大的那個值。 dp[i] 表示[0,i] 區間內各個子區間和的最大值，狀態轉移方程是dp[i] = nums[i] + dp[i-1] (dp[i- 1] > 0)，dp[i] = nums[i] (dp[i-1] ≤ 0)。 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0053.Maximum-Subarray/ https://leetcode-cn.com/problems/maximum-subarray/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0053.Maximum-Subarray/Maximum-Subarray.go package maximumsubarray // MaxSubArrayDP : DP (dynamic programming) func MaxSubArrayDP(nums []int) int { if len(nums) == 0 { return 0 } if len(nums) == 1 { return nums[0] } dp, res := make([]int, len(nums)), nums[0] dp[0] = nums[0] for i := 1; i 0 { // 前一個和是正的 繼續加下去 dp[i] = nums[i] + dp[i-1] } else { // 前一個和是小於等於0 直接拿現在值取代 dp[i] = nums[i] } res = max(res, dp[i]) } return res } // MaxSubArray1 : 模擬, 比DP快 func MaxSubArray1(nums []int) int { if len(nums) == 1 { return nums[0] } maxSum := 0 tmp := 0 for i := 0; i maxSum { maxSum = tmp } if tmp b { return a } return b } //TODO: 分治法\b, 這個分治方法類似於「線段樹求解最長公共上升子序列問題」的pushUp操作 © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0059.Spiral-Matrix-II/":{"url":"Leetcode/0059.Spiral-Matrix-II/","title":"0059.Spiral Matrix II","summary":null,"keywords":"","body":"59. Spiral Matrix II tagsstart Medium Array tagsstop 題目 Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order. Example: Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 題目大意 給定一個正整數 n，生成一個包含 1 到 n^2 所有元素，且元素按順時針順序螺旋排列的正方形矩陣。 解題思路 給出一個數組 n，要求輸出一個 n n 的二維數組，裡面元素是 1 - nn，且數組排列順序是螺旋排列的 這一題是第 54 題的加強版，沒有需要注意的特殊情況，直接模擬即可。 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0059.Spiral-Matrix-II/ https://leetcode-cn.com/problems/spiral-matrix-ii/ 數組：這個循環可以轉懵很多人！ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0059.Spiral-Matrix-II/Spiral-Matrix-II.go package spiralmatrixii // GenerateMatrix : 按層模擬, 時間複雜 O(n^2) 空間複雜 O(1) func GenerateMatrix(n int) [][]int { result := make([][]int, n) for i := range result { result[i] = make([]int, n) } left, right, top, botton := 0, n-1, 0, n-1 num := 1 target := n * n for num = left; i-- { result[botton][i] = num num++ } botton-- // 左層 botton to top, 左層邊界++ for i := botton; i >= top; i-- { result[i][left] = num num++ } left++ } return result } // 模擬 : O(n) // https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0059.Spiral-Matrix-II/ func GenerateMatrix2(n int) [][]int { if n == 0 { return [][]int{} } if n == 1 { return [][]int{{1}} } result, visit, round, x, y, spDir := make([][]int, n), make([][]int, n), 0, 0, 0, [][]int{ {0, 1}, // 朝右 {1, 0}, // 朝下 {0, -1}, // 朝左 {-1, 0}, // 朝上 } for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0070.Climbing-Stairs/":{"url":"Leetcode/0070.Climbing-Stairs/","title":"0070.Climbing Stairs","summary":"0070.Climbing-Stairs","keywords":"","body":"0070.Climbing Stairs tagsstart LeetCode Go Easy Climbing Stairs DP tagsstop 題目 You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? Example 1: Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1 step + 1 step 2 steps Example 2: Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1 step + 1 step + 1 step 1 step + 2 steps 2 steps + 1 step Constraints: 1 Accepted: 2.8M Submissions: 5.4M Acceptance Rate: 52.3% 題目大意 類似 Fibonacci Number 解題思路 簡單的 DP，經典的爬樓梯問題. 一個樓梯可以由 n-1 和 n-2 的樓梯爬上來。 這一題求解的值就是斐波那契數列。 Big O 時間複雜 : 空間複雜 : 來源 https://leetcode.com/problems/climbing-stairs/ https://leetcode.cn/problems/climbing-stairs/ https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0070.Climbing-Stairs/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0070.Climbing-Stairs/main.go package climbingstairs // 時間複雜 O(n), 空間複雜 O(n) func ClimbStairs(n int) int { dp := make([]int, n+1) dp[0], dp[1] = 1, 1 for i := 2; i Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0070.Climbing-Stairs cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkClimbStairs-8 10386211 112.1 ns/op 320 B/op 1 allocs/op BenchmarkClimbStairsCache-8 10184984 118.8 ns/op 320 B/op 1 allocs/op BenchmarkClimbStairsRecursive-8 4 281980486 ns/op 320 B/op 1 allocs/op PASS ok LeetcodeGolang/Leetcode/0070.Climbing-Stairs 5.591s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0072.Edit-Distance/":{"url":"Leetcode/0072.Edit-Distance/","title":"0072. Edit Distance","summary":"","keywords":"","body":"0072. Edit Distance tagsstart Golang Hard Dynamic Programming Edit Distance tagsstop 题目 Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2. You have the following three operations permitted on a word: Insert a character Delete a character Replace a character Example 1: Input: word1 = \"horse\", word2 = \"ros\" Output: 3 Explanation: horse -> rorse (replace 'h' with 'r') rorse -> rose (remove 'r') rose -> ros (remove 'e') Example 2: Input: word1 = \"intention\", word2 = \"execution\" Output: 5 Explanation: intention -> inention (remove 't') inention -> enention (replace 'i' with 'e') enention -> exention (replace 'n' with 'x') exention -> exection (replace 'n' with 'c') exection -> execution (insert 'u') Constraints: 0 word1 and word2 consist of lowercase English letters. 題目大意 可以對一個字符串進行三種操作, 插入, 刪除, 替換 現在給你兩個字符串word1,word2, 計算出word1轉換成word2最少需要多少次操作 解題思路 https://mp.weixin.qq.com/s/ShoZRjM8OyvDbZwoXh6ygg 解決兩個字符串的動態規劃問題, 一班都是用兩個指針 i, j 分別指向兩個字符串的最後, 然後一步步往前走, 縮小問題的規模 if word1[i] == word2[j]: skip i,j同時往前 else: # insert # delete # replace dp = [ [0,1,2,3,4,5], [1,1,2,2,3,4], [2,2,1,2,3,4], [3,3,2,2,2,3] ] word1 \\ word2 \"\" h o r s e \"\" 0 1 2 3 4 5 r 1 1 2 2 3 4 o 2 2 1 2 3 4 s 3 3 2 2 2 3 dp(i,j) 返回值, 就是 word1[0..i] 和 word2[0..j]的最小編輯距離 dp(1,0) \"ro\" , \"h\" 最小編輯距離 2 dp[i-1][j-1] dp[i-1][j] dp[i][j-1] dp[i][j] 替換/跳過 刪除 插入 來源 https://leetcode.com/problems/edit-distance/ https://labuladong.gitee.io/algo/3/25/77/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0072.Edit-Distance/main.go package editdistance import \"fmt\" // 遞迴 (暴力解) func MinDistance(word1 string, word2 string) int { var dp func(int, int) int dp = func(i, j int) int { // base case if i == -1 { return j + 1 } if j == -1 { return i + 1 } if word1[i] == word2[j] { // word1[0..i] 和 word2[0..j]的最小編輯距離等於 word1[0..i-1] 和 word2[0..j-1] // 本來就相等所以不需要任何操作 // 也就是說 dp(i,j)等於 dp(i-1,j-1) return dp(i-1, j-1) } else { return min( dp(i, j-1)+1, // insert: 直接在 word1[i]中插入一個和word2[j]一樣的字符, 那麼word2[j]就被匹配了,往前j, 繼續和i對比, 操作次數+1 dp(i-1, j)+1, // delete: 直接把 word1[i] 這個字符串刪除, 往前 i 繼續和 j 對比, 操作次數+1 dp(i-1, j-1)+1, // replace: 直接把 word1[i] 替換成 word2[j], 這樣他們就匹配了, 同時往前 i, j 繼續對比, 操作次數+1 ) } } return dp(len(word1)-1, len(word2)-1) } // Memo優化 func MinDistanceMemo(word1 string, word2 string) int { var dp func(int, int) int memo := map[string]int{} dp = func(i, j int) int { key := fmt.Sprintf(\"%d,%d\", i, j) // 查詢備忘錄 避免重複 if _, ok := memo[key]; ok == true { return memo[key] } // base case if i == -1 { return j + 1 } if j == -1 { return i + 1 } if word1[i] == word2[j] { // word1[0..i] 和 word2[0..j]的最小編輯距離等於 word1[0..i-1] 和 word2[0..j-1] // 本來就相等所以不需要任何操作 // 也就是說 dp(i,j)等於 dp(i-1,j-1) memo[key] = dp(i-1, j-1) } else { memo[key] = min( dp(i, j-1)+1, // insert: 直接在 word1[i]中插入一個和word2[j]一樣的字符, 那麼word2[j]就被匹配了,往前j, 繼續和i對比, 操作次數+1 dp(i-1, j)+1, // delete: 直接把 word1[i] 這個字符串刪除, 往前 i 繼續和 j 對比, 操作次數+1 dp(i-1, j-1)+1, // replace: 直接把 word1[i] 替換成 word2[j], 這樣他們就匹配了, 同時往前 i, j 繼續對比, 操作次數+1 ) } return memo[key] } return dp(len(word1)-1, len(word2)-1) } // DP table 優化, DP table 是自底向上求解, 遞迴是自頂向下求解 func MinDistanceDP(word1 string, word2 string) int { m, n := len(word1), len(word2) // 初始化 dp table : [][]int{} dp := make([][]int, m+1) for i := 0; i i { min = i } } return min } go test -benchmem -run=none LeetcodeGolang/Leetcode/0072.Edit-Distance -bench=. goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0072.Edit-Distance cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkMinDistance-8 398260 3748 ns/op 0 B/op 0 allocs/op BenchmarkMinDistanceMemo-8 102272 10796 ns/op 2211 B/op 69 allocs/op BenchmarkMinDistanceDP-8 1944886 794.2 ns/op 688 B/op 9 allocs/op PASS ok LeetcodeGolang/Leetcode/0072.Edit-Distance 5.717s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0074.Search-a-2D-Matrix/":{"url":"Leetcode/0074.Search-a-2D-Matrix/","title":"74. Search a 2D Matrix","summary":"0074.Search-a-2D-Matrix","keywords":"","body":"74. Search a 2D Matrix tagsstart LeetCode Go Medium Search a 2D Matrix Array Binary Search Matrix Facebook Amazon Microsoft Bloomberg tagsstop 題目 題目大意 編寫一個高效的演算法來判斷 m x n 矩陣中，是否存在一個目標值。 該矩陣具有如下特性： 每行中的整數從左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 解題思路 可以將二維轉成一維矩陣 Big O 時間複雜 : O(log⁡mn) 其中 m 和 n 分別是矩陣的行數和列數 空間複雜 : O(1) 來源 https://leetcode.com/problems/search-a-2d-matrix/description/ https://leetcode.cn/problems/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0074.Search-a-2D-Matrix/main.go package searcha2dmatrix // 時間複雜 O(logmn), 空間複雜 O(1) func searchMatrix(matrix [][]int, target int) bool { m := len(matrix) if m > 1) //left + (right-left)/2 val := getMatrix(matrix, mid) if val == target { return true } else if val Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0075.Sort-Colors/":{"url":"Leetcode/0075.Sort-Colors/","title":"0075.Sort Colors","summary":null,"keywords":"","body":"75. Sort Colors tagsstart Medium Sort tagsstop 题目 Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library's sort function for this problem. Example 1: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space? 給定一個包含紅色、白色和藍色，一共 n 個元素的數組，原地對它們進行排序，使得相同顏色的元素相鄰，並按照紅色、白色、藍色順序排列。 此題中，我們使用整數 0、 1 和 2 分別表示紅色、白色和藍色。 範例 1： 輸入：nums = [2,0,2,1,1,0] 輸出：[0,0,1,1,2,2] 範例 2： 輸入：nums = [2,0,1] 輸出：[0,1,2] 範例 3： 輸入：nums = [0] 輸出：[0] 範例 4： 輸入：nums = [1] 輸出：[1] 提示： n == nums.length 1 nums[i] 為 0、1 或 2 進階： 你可以不使用代碼庫中的排序函數來解決這道題嗎？ 你能想出一個僅使用常數空間的一趟掃描算法嗎？ 來源：力扣（LeetCode） 鏈接：https://leetcode-cn.com/problems/sort-colors 著作權歸領扣網絡所有。商業轉載請聯繫官方授權，非商業轉載請註明出處。 題目大意 抽象題意其實就是排序。這題可以用快排一次通過。 解題思路 題目末尾的 Follow up 提出了一個更高的要求，能否用一次循環解決問題？這題由於數字只會出現 0，1，2 這三個數字，所以用游標移動來控制順序也是可以的。具體做法：0 是排在最前面的，所以只要添加一個 0，就需要放置 1 和 2。1 排在 2 前面，所以添加 1 的時候也需要放置 2 。至於最後的 2，只用移動游標即可。 這道題可以用計數排序，適合待排序數字很少的題目。用一個 3 個容量的數組分別計數，記錄 0，1，2 出現的個數。然後再根據個數排列 0，1，2 即可。時間複雜度 O(n)，空間複雜度 O(K)。這一題 K = 3。 這道題也可以用一次三路快排。數組分為 3 部分，第一個部分都是 0，中間部分都是 1，最後部分都是 2 。 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0075.Sort-Colors/ https://leetcode-cn.com/problems/sort-colors/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0075.Sort-Colors/0075.Sort-Colors.go package sortcolors func sortColors(nums []int) { if len(nums) == 0 { return } var index0, index1, index2 = 0, 0, 0 for _, num := range nums { switch num { case 0: nums[index2] = 2 index2++ nums[index1] = 1 index1++ nums[index0] = 0 index0++ case 1: nums[index2] = 2 index2++ nums[index1] = 1 index1++ case 2: index2++ } } } /* 二路快排與三路快排 先掌握二路快排， https://leetcode-cn.com/problems/sort-an-array/solution/golang-er-lu-kuai-pai-by-rqb-2/ 三路快排稍微改下即可 區別： 二路快排，分兩部分：小於等於、大於二部分。 三路快排分為，小於、等於、大於三部分。 三路快排： 相比二路快排增加一個變量記錄相等的起始元素。 假設選擇數組第一個元素作為參考元素。則起始下邊為0，即為equalHead 作者：hibrq 链接：https://leetcode-cn.com/problems/sort-an-array/solution/golang-san-lu-kuai-pai-by-rqb-2/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 */ func sortColorsQuickSort(nums []int) { if len(nums) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0078.Subsets/":{"url":"Leetcode/0078.Subsets/","title":"0078. Subsets","summary":"0078.Subsets","keywords":"","body":"0078. Subsets tagsstart LeetCode Go Medium Subsets tagsstop 題目 Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] Example 2: Input: nums = [0] Output: [[],[0]] Constraints: 1 題目大意 給定一組不含重複元素的整數陣列 nums，返回該陣列所有可能的子集（冪集）。 說明：解集不能包含重複的子集。 解題思路 找出一個集合中的所有子集，空集也算是子集。 且陣列中的數位不會出現重複。 用 DFS 暴力枚舉即可。 這一題和第 90 題，第 491 題類似，可以一起解答和複習 Big O 時間複雜 : O(n^2) 空間複雜 : O(n) 來源 https://leetcode.com/problems/subsets/description/ https://leetcode.cn/problems/subsets/description/ https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0078.Subsets/ https://github.com/suntong/lang/blob/master/lang/Go/src/ds/Recursion/LC-0B-Subsets-2.go 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0078.Subsets/main.go package subsets // 時間複雜 O(n^2) , 空間複雜 O(n) func Subsets(nums []int) [][]int { path, result := []int{}, [][]int{} for i := 0; i Benchmark go test -benchmem -run=none LeetcodeGolang/Leetcode/0354.Russian-Doll-Envelopes -bench=. -cover goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0354.Russian-Doll-Envelopes cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkMaxEnvelopes-8 7799131 160.3 ns/op 88 B/op 3 allocs/op BenchmarkMaxEnvelopes2-8 5800399 195.6 ns/op 80 B/op 4 allocs/op PASS coverage: 96.0% of statements ok LeetcodeGolang/Leetcode/0354.Russian-Doll-Envelopes 3.726s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0088.Merge-Sorted-Array/":{"url":"Leetcode/0088.Merge-Sorted-Array/","title":"0088.Merge Sorted Array","summary":null,"keywords":"","body":"88. Merge Sorted Array tagsstart Easy Array tagsstop 題目 Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array. Note: You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively. Example: Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Constraints: -10^9 題目大意 合併兩個已經有序的數組，結果放在第一個數組中，第一個數組假設空間足夠大。要求算法時間複雜度足夠低。 解題思路 為了不大量移動元素，就要從2個數組長度之和的最後一個位置開始，依次選取兩個數組中大的數，從第一個數組的尾巴開始往頭放，只要循環一次以後，就生成了合併以後的數組了。 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0088.Merge-Sorted-Array/ https://leetcode-cn.com/problems/merge-sorted-array/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0088.Merge-Sorted-Array/Merge-Sorted-Array.go package mergesortedarray func Merge(nums1 []int, m int, nums2 []int, n int) { if m == 0 { copy(nums1, nums2) return } num1Idx, num2Idx, tail := m-1, n-1, m+n-1 // 從每一個array的後面開始比較, 並放入最後面的位子. 這樣只要跑一次 for ; num1Idx >= 0 && num2Idx >= 0; tail-- { if nums1[num1Idx] > nums2[num2Idx] { nums1[tail] = nums1[num1Idx] num1Idx-- } else { nums1[tail] = nums2[num2Idx] num2Idx-- } } // 將尚未跑完的補齊 for ; num2Idx > 0; tail-- { nums1[tail] = nums2[num2Idx] num2Idx-- } } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0094.Binary-Tree-Inorder-Traversal/":{"url":"Leetcode/0094.Binary-Tree-Inorder-Traversal/","title":"0094.Binary Tree Inorder Traversal","summary":null,"keywords":"","body":"94. Binary Tree Inorder Traversal tagsstart Medium Stack tagsstop 題目 Given a binary tree, return the inorder traversal of its nodes' values. Example : Input: [1,null,2,3] 1 \\ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively? 題目大意 中序遍歷一顆樹 解題思路 深度優先 中序遍歷 若二元樹為空回傳空, 否則從根結點開始, 先走訪根節點的左子樹 -> 根節點 -> 右子樹 深度優先, 前序遍歷 若二元樹為空回傳空, 否則先根節點-> 左子樹 -> 右子樹 深度優先, 後序遍歷 若二元樹為空回傳空, 否則從左到右誒並從葉子節點後續走訪左子樹到右子樹, 最後是拜訪根節點 來源 https://books.halfrost.com/leetcode/ChapterFour/0001~0099/0094.Binary-Tree-Inorder-Traversal/ https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0094.Binary-Tree-Inorder-Traversal/Binary-Tree-Inorder-Traversal.go package binarytreeinordertraversal import ( \"LeetcodeGolang/Utility/structures\" ) type TreeNode = structures.TreeNode func InorderTraversalStack(root *TreeNode) []int { var result []int inorderStack(root, &result) return result } func InorderTraversalRecursion(root *TreeNode) []int { var result []int inorderRecursion(root, &result) return result } func inorderRecursion(root *TreeNode, r *[]int) { if root != nil { inorderRecursion(root.Left, r) *r = append(*r, root.Val) inorderRecursion(root.Right, r) } } func inorderStack(root *TreeNode, r *[]int) { s := structures.NewArrayStack() p := root for !s.IsEmpty() || p != nil { if p != nil { // 把中間放入stack, 往左節點繼續往下找 s.Push(p) p = p.Left } else { // 找不到時,印出 tmp := s.Pop().(*TreeNode) *r = append(*r, tmp.Val) p = tmp.Right } } } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0100.Same-Tree/":{"url":"Leetcode/0100.Same-Tree/","title":"100. Same Tree","summary":"0100.Same-Tree","keywords":"","body":"100. Same Tree tagsstart LeetCode Go Easy Same Tree Tree tagsstop 題目 Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. Example 1: Input: p = [1,2,3], q = [1,2,3] Output: true Example 2: Input: p = [1,2], q = [1,null,2] Output: false Example 3: Input: p = [1,2,1], q = [1,1,2] Output: false Constraints: The number of nodes in both trees is in the range [0, 100]. -104 Accepted: 1.8M Submissions: 3.1M Acceptance Rate: 60.3% 題目大意 判斷 2 顆樹是否是完全相等的 解題思路 遞歸判斷即可 Big O 時間複雜 : O(n) 空間複雜 : O(1) 來源 https://leetcode.com/problems/same-tree/ https://leetcode.cn/problems/same-tree/ https://books.halfrost.com/leetcode/ChapterFour/0100~0199/0100.Same-Tree/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0100.Same-Tree/main.go package sametree import \"LeetcodeGolang/structures\" /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type TreeNode = structures.TreeNode // 時間複雜 O(n), 空間複雜 O(1) func IsSameTree(p *TreeNode, q *TreeNode) bool { if p == nil && q == nil { return true } else if p != nil && q != nil { if p.Val == q.Val { return IsSameTree(p.Left, q.Left) && IsSameTree(p.Right, q.Right) } return false } else { return false } } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0104.Maximum-Depth-of-Binary-Tree/":{"url":"Leetcode/0104.Maximum-Depth-of-Binary-Tree/","title":"0104.Maximum Depth of Binary Tree","summary":"0104.Maximum-Depth-of-Binary-Tree","keywords":"","body":"0104.Maximum Depth of Binary Tree tagsstart LeetCode Go Easy LEETCODETITLE tagsstop 題目 Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 Constraints: The number of nodes in the tree is in the range [0, 104]. -100 Accepted 2.7M Submissions 3.6M Acceptance Rate 74.7% 題目大意 解題思路 Big O 時間複雜 : 空間複雜 : 來源 https://leetcode.com/problems/maximum-depth-of-binary-tree/description/ https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0104.Maximum-Depth-of-Binary-Tree/main.go Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/":{"url":"Leetcode/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","title":"105. Construct Binary Tree from Preorder and Inorder Traversal","summary":"0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","keywords":"","body":"105. Construct Binary Tree from Preorder and Inorder Traversal tagsstart LeetCode Go Medium Construct Binary Tree from Preorder and Inorder Traversal Array Hash Table Divide and Conquer Tree Binary Tree tagsstop 題目 題目大意 解題思路 Big O 時間複雜 : O(n) n個樹節點 空間複雜 : O(n) 遞迴調用的Stack空間是 O(h)，其中 h 是樹的高度。 在每個遞迴層級中，都創建了一個 TreeNode 對象，因此空間複雜度也是 O(n)，其中 n 是節點的數量。 h 來源 https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/ https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/main.go /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 時間複雜 O(), 空間複雜 O() func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } result := &TreeNode{preorder[0], nil, nil} i := 0 for ; i Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0110.Balanced-Binary-Tree/":{"url":"Leetcode/0110.Balanced-Binary-Tree/","title":"110. Balanced Binary Tree","summary":"0110.Balanced-Binary-Tree","keywords":"","body":"110. Balanced Binary Tree tagsstart LeetCode Go Easy Balanced Binary Tree DFS tagsstop 題目 Given a binary tree, determine if it is height-balanced . Example 1: Input: root = [3,9,20,null,null,15,7] Output: true Example 2: Input: root = [1,2,2,3,3,null,null,4,4] Output: false Example 3: Input: root = [] Output: true Constraints: The number of nodes in the tree is in the range [0, 5000]. -104 題目大意 判斷一棵樹是不是平衡二叉樹。 平衡二叉樹的定義是：樹中每個節點都滿足左右兩個子樹的高度差 解題思路 高度運算可使用 0104.Maximum-Depth-of-Binary-Tree 平衡二叉樹（Balanced Binary Tree）是一種二叉樹，其左右子樹的高度差不超過一的二叉樹。換句話說，對於樹中的每個節點，其左子樹和右子樹的高度差不得大於1。 平衡二叉樹的主要目的是確保樹的高度平衡，這有助於保持在最壞情況下的查找、插入和刪除操作的時間複雜度在O(log n)範圍內，其中n是樹中節點的數量。這種平衡性有助於確保樹的性能良好，並減少操作的平均時間複雜度。 Big O 時間複雜 : O(n) 空間複雜 : O(1) 來源 https://leetcode.com/problems/balanced-binary-tree/ https://leetcode.cn/problems/balanced-binary-tree/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0110.Balanced-Binary-Tree/main.go package balancedbinarytree import \"LeetcodeGolang/structures\" // 時間複雜 O(), 空間複雜 O() /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type TreeNode = structures.TreeNode func IsBalanced(root *TreeNode) bool { if root == nil { return true } leftHight := depth(root.Left) rightHight := depth(root.Right) return abs(leftHight-rightHight) b { return a } return b } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0121.Best-Time-to-Buy-and-Sell-Stock/":{"url":"Leetcode/0121.Best-Time-to-Buy-and-Sell-Stock/","title":"0121.Best Time to Buy and Sell Stock","summary":"0121.Best-Time-to-Buy-and-Sell-Stock","keywords":"","body":"0121.Best Time to Buy and Sell Stock) tagsstart LeetCode Go Easy Slide Windows DP Best Time to Buy and Sell Stock array Blind75 amazon bloomberg facebook microsoft uber tagsstop 題目 You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: 1 題目大意 解題思路 Big O 時間複雜 : O(n) 空間複雜 : O(1) 來源 https://leetcode.com/problems/valid-parentheses/ https://leetcode.cn/problems/valid-parentheses/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0121.Best-Time-to-Buy-and-Sell-Stock/main.go package besttimetobuyandsellstock type numbers interface { int | int8 | int16 | int32 | int64 | float32 | float64 } func max[T numbers](a T, b T) T { if a > b { return a } return b } // 時間複雜 O(n), 空間複雜 O(1) // Slide windows func MaxProfit(prices []int) int { left, right := 0, 1 maxProfit := 0 for right maxProfit { maxProfit = profit } } } return maxProfit } // 時間複雜 O(), 空間複雜 O() // DP func MaxProfitDP2(prices []int) int { n := len(prices) dp := make([][]int, n) for i := 0; i Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0121.Best-Time-to-Buy-and-Sell-Stock cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkMaxProfit-8 208734571 8.156 ns/op 0 B/op 0 allocs/op BenchmarkMaxProfitDP-8 240880467 5.720 ns/op 0 B/op 0 allocs/op BenchmarkMaxProfitDP2-8 4095866 282.6 ns/op 240 B/op 7 allocs/op PASS ok LeetcodeGolang/Leetcode/0121.Best-Time-to-Buy-and-Sell-Stock 6.732s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0125.Valid-Palindrome/":{"url":"Leetcode/0125.Valid-Palindrome/","title":"0125. Valid Palindrome","summary":"Valid Palindrome","keywords":"","body":"0125. Valid Palindrome tagsstart LeetCode Go Easy Valid Palindrome tagsstop 題目 A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. Example 2: Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome. Example 3: Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. Constraints: 1 題目大意 解題思路 左右指針 Big O 時間複雜 : O(n) 空間複雜 : O(1) 來源 https://leetcode.com/problems/valid-palindrome https://leetcode.cn/problems/valid-palindrome 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0125.Valid-Palindrome/main.go package validpalindrome import ( \"strings\" \"unicode\" ) // 時間複雜 O(), 空間複雜 O() func IsPalindrome(s string) bool { // 將字符轉成小寫, s = strings.ToLower(s) // 使用雙指針, 一左一右相向而行, 判斷回文 left, right := 0, len(s)-1 for left Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0125.Valid-Palindrome cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkIsPalindrome-8 3840048 552.2 ns/op 32 B/op 1 allocs/op BenchmarkIsPalindromeStrBuilder-8 3164848 439.0 ns/op 88 B/op 4 allocs/op PASS ok LeetcodeGolang/Leetcode/0125.Valid-Palindrome 5.242s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0128.Longest-Consecutive-Sequence/":{"url":"Leetcode/0128.Longest-Consecutive-Sequence/","title":"128. Longest Consecutive Sequence","summary":"0128.Longest-Consecutive-Sequence","keywords":"","body":"128. Longest Consecutive Sequence tagsstart LeetCode Go Medium Longest Consecutive Sequence Array Hash Table Union Find Amazon Microsoft Google Adobe Spotify tagsstop 題目 給定一個未排序的整數數位列 nums ，找出數字連續的最長序列（不要求序列元素在原陣列中連續）的長度。 請你設計並實現時間複雜度為 O(n) 的演演算法解決此問題。 題目大意 解題思路 Big O 時間複雜 : O(n) 空間複雜 : O(n) 來源 https://leetcode.com/problems/longest-consecutive-sequence/description/ https://leetcode.cn/problems/longest-consecutive-sequence/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0128.Longest-Consecutive-Sequence/main.go package longestconsecutivesequence // 時間複雜 O(), 空間複雜 O() func longestConsecutive(nums []int) int { m := make(map[int]struct{}, len(nums)) for _, num := range nums { m[num] = struct{}{} } result := 0 for v := range m { // 如果沒找到該數字的前一個數字, 則把該數字刀做連續序列的第一個數 if _, ok := m[v-1]; !ok { length := 1 for _, exit := m[v+length]; exit; _, exit = m[v+length] { length++ } if result Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0138.Copy-List-with-Random-Pointer/":{"url":"Leetcode/0138.Copy-List-with-Random-Pointer/","title":"138. Copy List with Random Pointer","summary":"0138.Copy-List-with-Random-Pointer","keywords":"","body":"138. Copy List with Random Pointer tagsstart LeetCode Go Medium Copy List with Random Pointer Facebook Amazon Microsoft Bloomberg Google tagsstop 題目 題目大意 解題思路 對於數據結構複製，甭管他怎麼變，你就記住最簡單的方式：一個哈希表 + 兩次遍歷 第一次遍歷專門clone節點，藉助 Hash表把原始節點和clone節點的映射存儲起來; 第二次專門組裝節點，照著原數據結構的樣子，把clone節點的指標組裝起來。 Big O 時間複雜 : O(n) ，其中 n 是鏈表的長度。 對於每個節點，我們至多訪問其「後繼節點」和「隨機指標指向的節點」各一次，均攤每個點至多被訪問兩次。 空間複雜 : O(n) 其中 n 是鏈表的長度。 為哈希表的空間開銷 來源 https://leetcode.com/problems/copy-list-with-random-pointer/description/ https://leetcode.cn/problems/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0138.Copy-List-with-Random-Pointer/main.go package copylistwithrandompointer /** * Definition for a Node. * type Node struct { * Val int * Next *Node * Random *Node * } */ var cacheMap map[*Node]*Node // 時間複雜 O(n), 空間複雜 O(n) func copyRandomList(head *Node) *Node { cacheMap = make(map[*Node]*Node) return deepCopy(head) } func deepCopy(node *Node) *Node { if node == nil { return nil } if n, ok := cacheMap[node]; ok { return n } newNode := &Node{Val: node.Val} cacheMap[node] = newNode newNode.Next = deepCopy(node.Next) newNode.Random = deepCopy(node.Random) return newNode } func copyRandomList2(head *Node) *Node { cMap := make(map[*Node]*Node) cur := head // 第一次遍歷專門clone節點，藉助 Hash表把原始節點和clone節點的映射存儲起來; for cur != nil { newNode := &Node{Val: cur.Val} cMap[cur] = newNode cur = cur.Next } // 第二次專門組裝節點，照著原數據結構的樣子，把clone節點的指標組裝起來。 newHead := cMap[head] for head != nil { node := cMap[head] node.Next = cMap[head.Next] node.Random = cMap[head.Random] head = head.Next } return newHead } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0141.Linked-List-Cycle/":{"url":"Leetcode/0141.Linked-List-Cycle/","title":"0141.Linked List Cycle","summary":null,"keywords":"","body":"141. Linked List Cycle tagsstart Easy Linked List Two Pointers tagsstop 題目 Given a linked list, determine if it has a cycle in it. Follow up: Can you solve it without using extra space? 題目大意 判斷鍊表是否有環，不能使用額外的空間。 解題思路 給 2 個指針，一個指針是另外一個指針的下一個指針。快指針一次走 2 格，慢指針一次走 1 格。如果存在環，那麼前一個指針一定會經過若干圈之後追上慢的指針。 來源 https://books.halfrost.com/leetcode/ChapterFour/0100~0199/0141.Linked-List-Cycle/ https://leetcode-cn.com/problems/linked-list-cycle/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0141.Linked-List-Cycle/Linked-List-Cycle.go package linkedlistcycle type ListNode struct { Val int Next *ListNode } func HasCycle(head *ListNode) bool { fast := head slow := head for slow != nil && fast != nil && fast.Next != nil { fast = fast.Next.Next slow = slow.Next if slow == fast { return true } } return false } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0142.Linked-List-CycleII/":{"url":"Leetcode/0142.Linked-List-CycleII/","title":"0142.Linked List Cycle II","summary":null,"keywords":"","body":"142. Linked List Cycle II tagsstart Medium Linked List Two Pointers tagsstop 題目 Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Example 1: Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Constraints: The number of the nodes in the list is in the range [0, 104]. -105 pos is -1 or a valid index in the linked-list. 題目大意 已知linked list 中有含有環, 返回這個環的起始位置 解題思路 假設第一次相遇, slow 走了k步, 那麼 fast就走了 2k, 也就是說fast比slow多走了k步(環長度的整數倍) 設相遇點與環的起點距離為 m, 那麼環的起點與Head的距離為 k-m 來源 https://leetcode.com/problems/linked-list-cycle-ii/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0142.Linked-List-CycleII/main.go package linkedlistcycleII /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ type ListNode struct { Val int Next *ListNode } func DetectCycle(head *ListNode) *ListNode { fast, slow := head, head for fast != nil && fast.Next != nil { fast = fast.Next.Next slow = slow.Next if slow == fast { // 找到相遇點 break } } slow = head for slow != fast { fast = fast.Next slow = slow.Next } return slow } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0143.Reorder-List/":{"url":"Leetcode/0143.Reorder-List/","title":"143. Reorder List","summary":"0143.Reorder-List","keywords":"","body":"143. Reorder List tagsstart LeetCode Go /Medium 143. Reorder List Amazon Microsoft Adobe Facebook Bloomberg Linked List Two Pointers Stack Recursion tagsstop 題目 題目大意 解題思路 Big O 時間複雜 : `` 空間複雜 : `` 來源 https://leetcode.com/problems/reorder-list/description/ https://leetcode.cn/problems/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0143.Reorder-List/main.go package reorderlist /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 時間複雜 O(), 空間複雜 O() // 先用快慢指針找出Linked list的中間點 // 然後把Linked list分成兩半 // 再把後半的Linked list反轉 // 再把兩半的Linked list merge 起來 func reorderList(head *ListNode) { mid := middleNode(head) // 2.反轉中間節點的下一個節點 right := resverseNode(mid.Next) mid.Next = nil left := head mergeNode(left, right) } // [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) func middleNode(head *ListNode) *ListNode { slow, fast := head, head for fast != nil && fast.Next != nil { slow = slow.Next fast = fast.Next.Next } return slow } // [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/) func resverseNode(head *ListNode) *ListNode { var pre *ListNode for head != nil { tmp := head.Next head.Next = pre pre = head head = tmp } return pre } func mergeNode(l1, l2 *ListNode) { lcur, rcur := l1, l2 for lcur != nil && rcur != nil { lcur.Next, rcur.Next, lcur, rcur = rcur, lcur.Next, lcur.Next, rcur.Next } } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0153.Find-Minimum-in-Rotated-Sorted-Array/":{"url":"Leetcode/0153.Find-Minimum-in-Rotated-Sorted-Array/","title":"0153.Find-Minimum-in-Rotated-Sorted-Array","summary":"0153.Find-Minimum-in-Rotated-Sorted-Array","keywords":"","body":"0153.Find-Minimum-in-Rotated-Sorted-Array tagsstart LeetCode Go Medium LEETCODETITLE Amazon Facebook Microsoft Adobe Goldman Sachs tagsstop 題目 題目大意 解題思路 Big O 時間複雜 : O(logN) 空間複雜 : O(1) 來源 https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/ https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0153.Find-Minimum-in-Rotated-Sorted-Array/main.go package findminimuminrotatedsortedarray // 時間複雜 O(logN), 空間複雜 O(1) func findMin(nums []int) int { left, right := 0, len(nums)-1 for left > 1) if nums[mid] >= nums[left] { // mid 一定不是最小值了 left = mid + 1 } else { right = mid } } return nums[left] } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0167.Two-Sum-II-Input-Array-Is-Sorted/":{"url":"Leetcode/0167.Two-Sum-II-Input-Array-Is-Sorted/","title":"0167.Two Sum II Input Array Is Sorted","summary":"0167.Two-Sum-II-Input-Array-Is-Sorted","keywords":"","body":"0167.Two Sum II Input Array Is Sorted tagsstart LeetCode Go Medium Two Sum II Input Array Is Sorted Array Two Pointers Binary Search tagsstop 題目 Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1: Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2: Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3: Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. Constraints: 2 題目大意 找出兩個數之和等於 target 的兩個數位，要求輸出它們的下標。 注意一個數位不能使用 2 次。 下標從小到大輸出。 假定題目一定有一個解。 解題思路 Big O 使用1. Two Sun來解 O(n^2) 的時間複雜度和 O(1)的空間複雜度暴力 藉助哈希表使用 O(n) 的時間複雜度和 O(n) 的空間複雜度求解 雙指針 時間複雜度： O(n)，其中 n 是陣列的長度。 兩個指標移動的總次數最多為 n 次。 空間複雜度： O(1) 時間複雜 : 空間複雜 : 來源 https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/ https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0167.Two-Sum-II-Input-Array-Is-Sorted/main.go package twosumiiinputarrayissorted // 雙指針. 時間複雜度： O(n)，其中 n 是陣列的長度。 兩個指標移動的總次數最多為 n 次。 // 空間複雜度： O(1) func TwoSum(numbers []int, target int) []int { left, right := 0, len(numbers)-1 for left Benchmark go test -benchmem -run=none LeetcodeGolang/Leetcode/0167.Two-Sum-II-Input-Array-Is-Sorted -bench=. goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0167.Two-Sum-II-Input-Array-Is-Sorted cpu: Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz BenchmarkTwoSum-4 35161128 39.74 ns/op 16 B/op 1 allocs/op BenchmarkTwoSum2-4 19309680 70.21 ns/op 16 B/op 1 allocs/op PASS ok LeetcodeGolang/Leetcode/0167.Two-Sum-II-Input-Array-Is-Sorted 2.866s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0203.Remove-Linked-List-Elements/":{"url":"Leetcode/0203.Remove-Linked-List-Elements/","title":"0203.Remove Linked List Elements","summary":null,"keywords":"","body":"203. Remove Linked List Elements tagsstart Easy Linked List tagsstop 題目 Remove all elements from a linked list of integers that have value val. Example : Input: 1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5 題目大意 刪除鍊錶中所有指定值的結點。 解題思路 按照題意做即可 來源 https://books.halfrost.com/leetcode/ChapterFour/0200~0299/0203.Remove-Linked-List-Elements/ https://leetcode-cn.com/problems/remove-linked-list-elements/ https://mp.weixin.qq.com/s/slM1CH5Ew9XzK93YOQYSjA 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0203.Remove-Linked-List-Elements/Remove-Linked-List-Elements.go package removelinkedlistelements import ( \"LeetcodeGolang/structures\" ) /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ type ListNode = structures.ListNode // 方法一: 另外考慮刪除head節點 func RemoveElements(head *ListNode, val int) *ListNode { // 刪除值相同的head for head != nil && head.Val == val { head = head.Next } if head == nil { return head } tmpHead := head for tmpHead.Next != nil { if tmpHead.Next.Val == val { tmpHead.Next = tmpHead.Next.Next } else { tmpHead = tmpHead.Next } } return head } /* 方法二 添加虛擬節點, 效能較好 可以設置一個虛擬頭結點」，這樣原鍊錶的所有節點就都可以按照統一的方式進行移除了 return newHead.Next */ func RemoveElementsVirtualNode(head *ListNode, val int) *ListNode { if head == nil { return head } // 建立一個虛擬 Head 節點 newHead := &ListNode{Val: 0, Next: head} preHead := newHead curHead := head for curHead != nil { if curHead.Val == val { preHead.Next = curHead.Next } else { preHead = curHead } curHead = curHead.Next } return newHead.Next } /* 方法二 遞迴 */ func RemoveElementsRecurse(head *ListNode, val int) *ListNode { if head == nil { return head } head.Next = RemoveElementsRecurse(head.Next, val) if head.Val == val { return head.Next } else { return head } } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0206.Reverse-Linked-List/":{"url":"Leetcode/0206.Reverse-Linked-List/","title":"206. Reverse Linked List","summary":"Reverse Linked List","keywords":"","body":"206. Reverse Linked List tagsstart LeetCode Go Easy Reverse Linked List tagsstop 題目 Given the head of a singly linked list, reverse the list, and return the reversed list. Example 1: Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] Example 2: Input: head = [1,2] Output: [2,1] Example 3: Input: head = [] Output: [] Constraints: The number of nodes in the list is the range [0, 5000]. -5000 Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both? 題目大意 將 Linked List 反向 解題思路 來源 https://leetcode.com/problems/Reverse Linked List/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0000.kkkk/main.go package reverselinkedlist import ( . \"LeetcodeGolang/structures\" ) /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func ReverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } var prev *ListNode for head != nil { next := head.Next head.Next = prev prev = head head = next } return prev } func ReverseListRecursively(head *ListNode) *ListNode { return ListRecursivelyChild(head, nil) } func ListRecursivelyChild(current *ListNode, prev *ListNode) *ListNode { if current == nil { return prev } next := current.Next current.Next = prev return ListRecursivelyChild(next, current) } Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0206.Reverse-Linked-List cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkReverseList-8 1000000000 0.7960 ns/op 0 B/op 0 allocs/op BenchmarkReverseListRecursively-8 276534334 4.374 ns/op 0 B/op 0 allocs/op PASS ok LeetcodeGolang/Leetcode/0206.Reverse-Linked-List 2.597s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0209.Minimum-Size-Subarray-Sum/":{"url":"Leetcode/0209.Minimum-Size-Subarray-Sum/","title":"0209. Minimum Size Subarray Sum","summary":null,"keywords":"","body":"209. Minimum Size Subarray Sum tagsstart Medium Sliding Window tagsstop 题目 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn't one, return 0 instead. Example 1: Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Input: s = 4, nums = [1,4,4] Output: 1 Input: s = 11, nums = [1,1,1,1,1,1,1,1] Output: 0 Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 題目大意 給定一個整型數組和一個數字 s，找到數組中最短的一個連續子數組，使得連續子數組的數字之和 sum>=s，返回最短的連續子數組的返回值。 解題思路 這一題的解題思路是用滑動窗口。在滑動窗口[i,j]之間不斷往後移動，如果總和小於s，就擴大右邊界j，不斷加入右邊的值，直到sum > s，之和再縮小i 的左邊界，不斷縮小直到sum 進階 如果你已經實現 O(n) 時間複雜度的解法, 請嘗試設計一個 O(n log(n)) 時間複雜度的解法。 來源 https://books.halfrost.com/leetcode/ChapterFour/0200~0299/0209.Minimum-Size-Subarray-Sum/ https://leetcode-cn.com/problems/minimum-size-subarray-sum/ https://mp.weixin.qq.com/s/UrZynlqi4QpyLlLhBPglyg 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0209.Minimum-Size-Subarray-Sum/Minimum-Size-Subarray-Sum.go package minimumsizesubarraysum import ( \"math\" \"sort\" ) // MinSubArrayLenBurst : 暴力解 時間複雜 O(n^2), 空間複雜 O(1) func MinSubArrayLenBurst(target int, nums []int) int { lens := len(nums) if lens = target { minSize = min(minSize, j-i+1) } } } if minSize == math.MaxInt32 { minSize = 0 } return minSize } // MinSubArrayLenSlidingWindow : 滑動視窗 時間複雜 O(n), 空間複雜 O(1) // 滑動窗口的精妙之處在於根據當前子序列和大小的情況，不斷調節子序列的起始位置。從而將O(n^2)的暴力解法降為O(n) func MinSubArrayLenSlidingWindow(target int, nums []int) int { lens := len(nums) if lens = target { minSize = min(minSize, end-start+1) sum -= nums[start] start++ } end++ } if minSize == math.MaxInt32 { minSize = 0 } return minSize } /* MinSubArrayLenBinarysearch : 前缀和 + 二分查找 O(nlog(n)) 為了使用二分查找，需要額外創建一個數組 sums 用於存儲數組nums 的前綴和，其中 sums[i] 表示從 nums[0] 到 nums[i−1] 的元素和。 得到前綴和之後，對於每個開始下標i，可通過二分查找得到大於或等於 i 的最小下標 bound， 使得 sums[bound]-sums[i-1] >= s， 並更新子數組的最小長度（此時子數組的長度是 bound -(i-1) )。 C++ 的 lower_bound，Java 的 Arrays.binarySearch 因為這道題保證了數組中每個元素都為正，所以前綴和一定是遞增的，這一點保證了二分的正確性。如果題目沒有說明數組中每個元素都為正，這裡就不能使用二分來查找這個位置了。 */ func MinSubArrayLenBinarysearch(target int, nums []int) int { lens := len(nums) if lens © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0215.Kth-Largest-Element-in-an-Array/":{"url":"Leetcode/0215.Kth-Largest-Element-in-an-Array/","title":"0215. Kth Largest Element in an Array","summary":"Kth Largest Element in an Array","keywords":"","body":"0215. Kth Largest Element in an Array tagsstart LeetCode Go Medium Kth Largest Element in an Array Heap Priority Queue Sorting tagsstop 題目 Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Can you solve it without sorting? Example 1: Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Example 2: Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints: 1 -104 題目大意 數組中的第K個最大元素 (Kth Largest Element in an Array) 給定一個未排序的整數數組，找到其中第K個最大的元素。 解題思路 一種常見的解法是使用堆數據結構。我們可以維護一個大小為K的最小堆，初始時將數組的前K個元素加入堆中。然後遍歷數組的剩餘元素，如果當前元素比堆頂元素大，則將堆頂元素出堆，並將當前元素加入堆中。最後堆頂元素即為第K個最大的元素。 時間複雜度: 構建堆的時間複雜度為O(K)，遍歷數組的時間複雜度為O((N-K)logK)，因此總的時間複雜度為O(NlogK)。 空間複雜度: 使用了大小為K的最小堆來存儲元素，因此空間複雜度為O(K)。 在快速選擇 quickselect 的 partition 操作中，每次 partition 操作結束都會返回一個點，這個標定點的下標和最終排序之後有序數組中這個元素所在的下標是一致的。利用這個特性，我們可以不斷的劃分數組區間，最終找到第 K 大的元素。執行一次 partition 操作以後，如果這個元素的下標比 K 小，那麼接著就在後邊的區間繼續執行 partition 操作；如果這個元素的下標比 K 大，那麼就在左邊的區間繼續執行 partition 操作；如果相等就直接輸出這個下標對應的數組元素即可。 快速選擇 quickselect 的思路實現的算法時間複雜度為 O(n)，空間複雜度為 O(logn) 來源 https://leetcode.com/problems/kth-largest-element-in-an-array/ https://books.halfrost.com/leetcode/ChapterFour/0200~0299/0215.Kth-Largest-Element-in-an-Array/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0215.Kth-Largest-Element-in-an-Array/main.go package kthlargestelementinanarray import ( \"container/heap\" \"sort\" ) // 解法一：用Heap資料結構 // container/heap包可以用来構造優先級Queue。 // Heap(堆積)其實是一個Complete Binary Tree(完全二元樹). // Go的Heap特性是 各個節點都自己是其子樹的根, 且值是最小的(index = 0 的值是最小的). // 同個根節點的左子樹的值會小於右子樹 func FindKthLargestHeap(nums []int, k int) int { if k len(nums) { return 0 } // 初始化最小堆 h := &MinHeap{} heap.Init(h) // 遍歷集合 for _, num := range nums { if h.Len() (*h)[0] { heap.Pop(h) heap.Push(h, num) } } // fmt.Println(h) return (*h)[0] } // 自定義最小 Heap 結構體 type MinHeap []int func (h MinHeap) Len() int { return len(h) } func (h MinHeap) Less(i, j int) bool { // 小到大排序 return h[i] Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0215.Kth-Largest-Element-in-an-Array cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkFindKthLargestHeap-8 6112726 184.9 ns/op 48 B/op 3 allocs/op BenchmarkFindKthLargestSort-8 18023403 60.38 ns/op 24 B/op 1 allocs/op PASS ok LeetcodeGolang/Leetcode/0215.Kth-Largest-Element-in-an-Array 3.383s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0217.Contains-Duplicate/":{"url":"Leetcode/0217.Contains-Duplicate/","title":"0217.Contains-Duplicate","summary":"Contains Duplicate","keywords":"","body":"0217.Contains-Duplicate tagsstart LeetCode Go Easy Contains Duplicate Array Blind75 tagsstop 題目 Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: Input: nums = [1,2,3,1] Output: true Example 2: Input: nums = [1,2,3,4] Output: false Example 3: Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true Constraints: 1 -109 題目大意 解題思路 來源 https://leetcode.com/problems/contains-duplicate/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0217.Contains-Duplicate/main.go package containsduplicate func ContainsDuplicate(nums []int) bool { numsMap := make(map[int]bool, len(nums)) for _, v := range nums { if numsMap[v] { return true } numsMap[v] = true } return false } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0226.Invert-Binary-Tree/":{"url":"Leetcode/0226.Invert-Binary-Tree/","title":"226. Invert Binary Tree","summary":"226. Invert Binary Tree","keywords":"","body":"226. Invert Binary Tree tagsstart LeetCode Go Easy Invert Binary Tree BFS tagsstop 題目 Given the root of a binary tree, invert the tree, and return its root. Example 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2: Input: root = [2,1,3] Output: [2,3,1] Example 3: Input: root = [] Output: [] Constraints: The number of nodes in the tree is in the range [0, 100]. -100 題目大意 反轉二叉樹 解題思路 用遞歸來解決，先遞歸調用反轉根節點的左children，然後遞歸調用反轉根節點的右children，然後左右交換根節點的左children和右children。 有點像是BFS BFS（廣度優先搜索）則使用隊列（Queue）來實現。在BFS中，您首先處理一個節點，然後將其子節點按某種順序排隊，接著繼續處理隊列的前端節點，直到隊列為空。 來源 https://leetcode.com/problems/invert-binary-tree/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0226.Invert-Binary-Tree/main.go package invertbinarytree import ( \"LeetcodeGolang/Utility/structures\" ) /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // type TreeNode struct { // Val int // Left *TreeNode // Right *TreeNode // } func InvertTree(root *structures.TreeNode) *structures.TreeNode { if root == nil { return nil } InvertTree(root.Left) InvertTree(root.Right) root.Left, root.Right = root.Right, root.Left return root } func InvertTree2(root *structures.TreeNode) *structures.TreeNode { if root != nil { root.Left, root.Right = InvertTree2(root.Right), InvertTree2(root.Left) } return root } func InvertTree3(root *structures.TreeNode) *structures.TreeNode { queue := make([]*structures.TreeNode, 0) queue = append(queue, root) for len(queue) > 0 { current := queue[0] queue = queue[1:] current.Left, current.Right = current.Right, current.Left if current.Left != nil { queue = append(queue, current.Left) } if current.Right != nil { queue = append(queue, current.Right) } } return root } func BuildTree(nums []int, index int) *TreeNode { if index >= len(nums) || nums[index] == -1 { return nil } root := &TreeNode{Val: nums[index]} root.Left = BuildTree(nums, 2*index+1) root.Right = BuildTree(nums, 2*index+2) return root } func IntsToTree(nums []int) *TreeNode { return BuildTree(nums, 0) } Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0226.Invert-Binary-Tree cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkInvertTree-8 2533011 398.7 ns/op 168 B/op 7 allocs/op BenchmarkInvertTree2-8 2667645 392.4 ns/op 168 B/op 7 allocs/op BenchmarkInvertTree3-8 1403001 727.5 ns/op 296 B/op 13 allocs/op PASS ok LeetcodeGolang/Leetcode/0226.Invert-Binary-Tree 4.889s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0238.Product-of-Array-Except-Self/":{"url":"Leetcode/0238.Product-of-Array-Except-Self/","title":"238. Product of Array Except Self","summary":"0238.Product-of-Array-Except-Self","keywords":"","body":"238. Product of Array Except Self tagsstart LeetCode Go Medium Product of Array Except Self Array Prefix Sum Blind75 tagsstop 題目 Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] Constraints: 2 Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) 題目大意 解題思路 Big O 時間複雜 : O(n) 空間複雜 : `` 來源 https://leetcode.com/problems/product-of-array-except-self/description/ https://leetcode.cn/problems/product-of-array-except-self/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0238.Product-of-Array-Except-Self/main.go package productofarrayexceptself // 時間複雜 O(), 空間複雜 O() func productExceptSelf(nums []int) []int { result, left, right := make([]int, len(nums)), make([]int, len(nums)), make([]int, len(nums)) // left 為左側所有的成績 // 索引為'0' 的元素, 因為左側沒有元素,所以left[0]=1 left[0] = 1 for i := 1; i = 0; i-- { right[i] = right[i+1] * nums[i+1] } for i := 0; i = 0; i-- { result[i] = result[i] * rightProduct rightProduct = rightProduct * nums[i] } return result } Benchmark go test -benchmem -run=none LeetcodeGolang/Leetcode/0238.Product-of-Array-Except-Self -bench=. goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0238.Product-of-Array-Except-Self cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkProductExceptSelf-8 12772174 158.4 ns/op 96 B/op 3 allocs/op BenchmarkProductExceptSelf2-8 32292304 63.74 ns/op 32 B/op 1 allocs/op PASS ok LeetcodeGolang/Leetcode/0238.Product-of-Array-Except-Self 4.228s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0242.Valid-Anagram/":{"url":"Leetcode/0242.Valid-Anagram/","title":"0242.Valid-Anagram","summary":"Valid Anagram","keywords":"","body":"0242.Valid-Anagram tagsstart LeetCode Go Easy Valid Anagram tagsstop 驗證回文串 題目 Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: s = \"anagram\", t = \"nagaram\" Output: true Example 2: Input: s = \"rat\", t = \"car\" Output: false Constraints: 1 Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case? 我們使用 rune 數據類型來處理 Unicode 字元，並使用 map[rune]int 來統計這些字符的出現次數。其餘的邏輯保持不變。 題目大意 解題思路 只要先把所有字符轉換成小寫，並過濾掉空格和標點這類字符，然後對剩下的字符執行 數組雙指針技巧匯總 中提到的兩端向中心的雙指針演算法即可 來源 https://leetcode.com/problems/valid-anagram/description/ https://leetcode.cn/problems/valid-anagram/description/ 數組雙指針技巧匯總 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0242.Valid-Anagram/main.go package validanagram func IsAnagram(s string, t string) bool { if len(s) != len(t) { return false } record := make(map[rune]int, len(s)) for _, v := range s { record[v]++ } for _, v := range t { record[v]-- if record[v] Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0242.Valid-Anagram cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkIsAnagram-8 6703497 276.3 ns/op 0 B/op 0 allocs/op BenchmarkIsAnagram2-8 3660909 318.9 ns/op 48 B/op 2 allocs/op PASS ok LeetcodeGolang/Leetcode/0242.Valid-Anagram 4.498s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0283.Move-Zeroes/":{"url":"Leetcode/0283.Move-Zeroes/","title":"0283. Move Zeroes","summary":"0283. Move Zeroes","keywords":"","body":"283. Move Zeroes tagsstart LeetCode Go Easy Move Zeroes tagsstop 題目 Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2: Input: nums = [0] Output: [0] Constraints: 1 -231 Follow up: Could you minimize the total number of operations done? 題目大意 題目要求不能利用額外的輔助空間，將數字組中 0 元素都移到數字組的末尾，並與維持所有非 0 元素的相對位置。 解題思路 非零交換數據, 左右指針都往右移 零, 右指針右移 來源 https://leetcode.com/problems/move-zeroes/ https://books.halfrost.com/leetcode/ChapterFour/0200~0299/0283.Move-Zeroes/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0283.Move-Zeroes/main.go package movezeroes // 時間O(n^2) func MoveZeroes(nums []int) { for i := 0; i Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0283.Move-Zeroes cpu: Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz BenchmarkMoveZeroes-4 145544966 9.164 ns/op 0 B/op 0 allocs/op BenchmarkMoveZeroes2point-4 183269922 6.149 ns/op 0 B/op 0 allocs/op PASS ok LeetcodeGolang/Leetcode/0283.Move-Zeroes 3.975s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0300.Longest-Increasing-Subsequence/":{"url":"Leetcode/0300.Longest-Increasing-Subsequence/","title":"0300.Longest Increasing Subsequence","summary":null,"keywords":"","body":"300.Longest-Increasing-Subsequence tagsstart Medium Dynamic Programming Patience Sorting Binary Search tagsstop 最長遞增子序列(Longest Increasing Subsequence, LIS) 題目 Given an integer array nums, return the length of the longest strictly increasing subsequence. A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7]. Example 1: Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Example 2: Input: nums = [0,1,0,3,2,3] Output: 4 Example 3: Input: nums = [7,7,7,7,7,7,7] Output: 1 Constraints: 1 -104 Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity? 題目大意 給你一個整事的數組 nums\b\b, 找到其中最長遞增子序列的長度 子序列不一定是連續的 子串一定是連續的 解題思路 方法一: DP dp[i]表示nums[i]這個數結尾的最長遞增子序列的長度 譬如要找dp[5]的直, 也就是球nums[5]為結尾的最長遞增子序列 只要找到結尾比nums[5]小的子序列, 然後把 nums[5]接到最後, 就可以形成新的遞增子序列, 而這個新子序列長度+1 方法二: DP + 二分搜尋 patience sorting (耐心排序) 給一組 [6, 3 ,5 ,10, 11, 2, 9, 14, 13, 7, 4, 8, 12] 只能把數字小的放在數字大的堆上, 如果當前數字太大沒有可以放置的堆, 則新建一個堆, 如果當前排有很多堆可以選擇, 則選擇最左邊的那一堆放, 因為這樣可以確保堆頂是有序的(2,4,7,8,12) 6 5 10 11 14 3 4 9 8 13 2 7 12 堆數就是最長遞增子序列的長度 [3,5,7,8,12] 來源 https://leetcode.com/problems/longest-increasing-subsequence/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0300.Longest-Increasing-Subsequence/main.go package longestincreasingsubsequence import \"fmt\" func max(a, b int) int { if a > b { return a } return b } // DP 解法 O(n^2) func LengthOfLIS(nums []int) int { dp := make([]int, len(nums)) for idx := 0; idx nums[j] { // 找到下一個數值比現在的大 dp[i] = max(dp[i], dp[j]+1) } } res = max(res, dp[i]) } // fmt.Println(dp) return res } func LengthOfLIS2(nums []int) int { dp := make([]int, len(nums)+1) dp[0] = 0 res := 0 for i := 1; i nums[j-1] { // 找到前面比現在結尾還小的子序列 dp[i] = max(dp[i], dp[j]) } } dp[i] = dp[i] + 1 res = max(res, dp[i]) } // fmt.Println(dp) return res } // DP + 二分搜尋:patience sorting. O(nlogn) func LengthOfLISPatience(nums []int) int { top := make([]int, len(nums)) // 牌堆數初始化為0 piles := 0 for i := 0; i poker { // 現在的牌比堆小, 縮小範圍 right = mid } else if top[mid] go test -benchmem -run=none LeetcodeGolang/Leetcode/300.Longest-Increasing-Subsequence -bench=. goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/300.Longest-Increasing-Subsequence cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkLengthOfLIS-8 18300901 64.77 ns/op 64 B/op 1 allocs/op BenchmarkLengthOfLIS2-8 17410562 68.98 ns/op 80 B/op 1 allocs/op BenchmarkLengthOfLISPatience-8 20768851 58.47 ns/op 64 B/op 1 allocs/op PASS ok LeetcodeGolang/Leetcode/300.Longest-Increasing-Subsequence 3.812s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0310.Minimum-Height-Trees/":{"url":"Leetcode/0310.Minimum-Height-Trees/","title":"0310.Minimum Height Trees","summary":null,"keywords":"","body":"310. Minimum Height Trees tagsstart Medium Breadth First Search tagsstop 題目 A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h)) are called minimum height trees (MHTs). Return a list of all MHTs' root labels. You can return the answer in any order. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Example 1: Input: n = 4, edges = [[1,0],[1,2],[1,3]] Output: [1] Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT. Example 2: Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] Output: [3,4] Constraints: 1 edges.length == n - 1 0 ai != bi All the pairs (ai, bi) are distinct. The given input is guaranteed to be a tree and there will be no repeated edges. 題目大意 輸入一個n個節點的二叉樹, 計算出最小高度(root到left的最短距離) 解題思路 用BFS來解. Queue 起點就是root, 終點就是最靠近root的那個葉節點(就是兩個子節點都是null) 來源 https://leetcode.com/problems/minimum-height-trees/ https://leetcode-cn.com/problems/minimum-height-trees/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0310.Minimum-Height-Trees/main.go package minimumheighttrees import \"fmt\" func FindMinHeightTrees(n int, edges [][]int) []int { if n == 1 { return []int{0} } graph := make(map[int][]int) degree := make(map[int]int, n) //出度: 出度是指從該節點（頂點）出發的邊的條數 // 建立對應關係 for _, v := range edges { if _, ok := graph[v[0]]; ok { graph[v[0]] = append(graph[v[0]], v[1]) } else { // 沒找到 graph[v[0]] = []int{v[1]} } if _, ok := graph[v[1]]; ok { graph[v[1]] = append(graph[v[1]], v[0]) } else { // 沒找到 graph[v[1]] = []int{v[0]} } degree[v[0]]++ degree[v[1]]++ } fmt.Printf(\"graph: %+v \\n\", graph) fmt.Printf(\"degree: %+v \\n\", degree) var queue []int for key, value := range degree { //先找到出度為1的點, 加到Queue if value == 1 { queue = append(queue, key) } } fmt.Printf(\"queue: %+v \\n\", queue) leaves := []int{} for len(queue) != 0 { leaves = leaves[0:0] size := len(queue) for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0322.Coin-Change/":{"url":"Leetcode/0322.Coin-Change/","title":"0322.Coin Change","summary":"0322.Coin Change","keywords":"","body":"322. Coin Change tagsstart LeetCode Go Coin Change Medium Dynamic Programming tagsstop 題目 You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money. Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1. You may assume that you have an infinite number of each kind of coin. Example 1: Input: coins = [1,2,5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2: Input: coins = [2], amount = 3 Output: -1 Example 3: Input: coins = [1], amount = 0 Output: 0 Constraints: 1 題目大意 給妳 k 種面值的硬幣, 面值分別為 c1,c2 ...,ck, 每種硬幣的數量無限. 再給你一個總金額. 求出最少 需要幾枚硬幣湊出這個金額, 如果不能湊出 return -1. 解題思路 dp(n) 的定義: 輸入一個目標金額n, 返回湊出目標金額n的最少硬幣數量 來源 https://books.halfrost.com/leetcode/ChapterFour/0300~0399/0322.Coin-Change/ https://leetcode.com/problems/coin-change/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0322.Coin-Change/Coin-Change.go package coinchange import ( \"math\" ) func min(a, b int) int { if a > b { return b } return a } var memo = map[int]int{} func dp(coins []int, n int) int { // 查詢備忘錄 避免重複 if _, vok := memo[n]; vok { return memo[n] } if n == 0 { return 0 } if n amount { return -1 } return dp[amount] } func CoinChange(coins []int, n int) int { var dpClosure func(n int) int dpClosure = func(n int) int { if n == 0 { return 0 } if n go test -benchmem -run=none LeetcodeGolang/Leetcode/0322.Coin-Change -bench=. goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0322.Coin-Change cpu: Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz BenchmarkCoinChange-4 273376 4452 ns/op 0 B/op 0 allocs/op BenchmarkCoinChangeDP-4 11071686 128.1 ns/op 96 B/op 1 allocs/op BenchmarkCoinChangeMemoryTableRecursion-4 57663068 23.69 ns/op 0 B/op 0 allocs/op PASS ok LeetcodeGolang/Leetcode/0322.Coin-Change 4.194s amount = 11. k=[1,2,5] amount 0 1 2 3 4 5 ... 9 10 11 index 0 1 2 3 4 5 ... 9 10 11 dp 0 1 1 2 2 1 ... 3 2 3 dp[5] = 1+min(dp[5-1],dp[5-2],dp[5-5]) dp[11] = 1+min(dp[10],dp[9],dp[6]) © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0344.Reverse-String/":{"url":"Leetcode/0344.Reverse-String/","title":"0344.Reverse String","summary":null,"keywords":"","body":"344. Reverse String tagsstart Easy Two Pointers tagsstop 題目 Write a function that reverses a string. The input string is given as an array of characters char[]. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. You may assume all the characters consist of printable ascii characters. Example 1: Input: [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] Example 2: Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 題目大意 題目要求我們反轉一個字符串。 解題思路 這一題的解題思路是用 2 個指針，指針對撞的思路，來不斷交換首尾元素，即可。 來源 https://books.halfrost.com/leetcode/ChapterFour/0300~0399/0344.Reverse-String/ https://leetcode-cn.com/problems/reverse-string/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0344.Reverse-Stringm/Reverse-String.go package reversestring func ReverseString(s []byte) { for i, j := 0, len(s)-1; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0347.Top-K-Frequent-Elements/":{"url":"Leetcode/0347.Top-K-Frequent-Elements/","title":"347. Top K Frequent Elements","summary":"0347.Top-K-Frequent-Elements","keywords":"","body":"347. Top K Frequent Elements tagsstart LeetCode Go Medium Top K Frequent Elements heap tagsstop 題目 Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Constraints: 1 Follow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size. Seen this question in a real interview before? 1/4 Accepted 1.9M Submissions 3M Acceptance Rate 62.7% 題目大意 解題思路 方法一：heap 方法一：堆 思路與演算法 首先遍歷整個數組，並使用哈希表記錄每個數字出現的次數，並形成一個「出現次數數組」。 找出原數組的前 k 個高頻元素，就等於找出「出現次數數組」的前 k 大的值。 最簡單的做法是為「出現次數數組」排序。 但由於可能有O(N) 個不同的出現次數（其中N 為原數組長度），故總的演算法複雜度會達到O(Nlog⁡N)，不符合題目的要求。 在這裡，我們可以利用堆的想法：建立一個小頂堆，然後遍歷「出現次數數組」： 如果堆的元素個數小於 k，就可以直接插入堆中。 如果堆的元素個數等於 k，則檢查堆頂與目前出現次數的大小。 如果堆頂較大，表示至少有 k 個數字的出現次數比目前值大，故捨棄目前值；否則，就彈出堆頂，並將目前值插入堆中。 遍歷完成後，堆中的元素就代表了「出現次數數組」中前 k 大的值。 複雜度分析 時間複雜度：O(Nlog⁡k)， 其中 N 為陣列的長度。 我們先遍歷原數組，並使用雜湊表記錄出現次數，每個元素需要O(1) 的時間，共需O(N) 的時間 。 隨後，我們遍歷「出現次數數組」，由於堆的大小至多為k，因此每次堆操作需要O(log⁡k)的時間，共需O(Nlog⁡k)的時間。 二者之和為 O(Nlog⁡k)。 空間複雜度：O(N)。 雜湊表的大小為O(N)，而堆的大小為O(k)，共為O(N)。 方法二： Quick Sort Name Best Average Worst Memory Stable Quick sort n log(n) n log(n) n^2 log(n) No 使用基於快速排序的方法，求出「出現次數陣列」的前 k 大的值。 Big O 方法一：heap 時間複雜 : O(Nlog⁡k) 空間複雜 : O(N) 方法二： Quick Sort 時間複雜 : 空間複雜 : 來源 https://leetcode.com/problems/top-k-frequent-elements/description/ https://leetcode.cn/problems/top-k-frequent-elements/description/ https://books.halfrost.com/leetcode/ChapterFour/0300~0399/0347.Top-K-Frequent-Elements/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0347.Top-K-Frequent-Elements/main.go package topkfrequentelements import ( \"container/heap\" \"sort\" ) // 方法一: 使用 PriorityQueue // 時間複雜 O(Nlog⁡k), 空間複雜 O(N) // 首先遍歷整個數組，並使用哈希表記錄每個數字出現的次數，並形成一個「出現次數數組」 // 建立一個 PriortyQueue, 將「出現次數數組」丟進去 // 在把 PriortyQueue pop的值丟到 result func TopKFrequent(nums []int, k int) []int { m := make(map[int]int) for i := 0; i pq[j].count } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] } func (pg *PriorityQueue) Push(v interface{}) { item := v.(*Item) *pg = append(*pg, item) } func (pg *PriorityQueue) Pop() interface{} { n := len(*pg) item := (*pg)[n-1] *pg = (*pg)[:n-1] return item } func (pg *PriorityQueue) PushPQ(v *Item) { heap.Push(pg, v) } func (pg *PriorityQueue) PopPQ() *Item { return heap.Pop(pg).(*Item) } // 方法二: 使用 Quick Sort // 時間複雜 O(), 空間複雜 O() func TopKFrequentQuickSort(nums []int, k int) []int { m := make(map[int]int) for i := 0; i s[j][1] } func (s sortValue) Swap(i, j int) { s[i], s[j] = s[j], s[i] } Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0347.Top-K-Frequent-Elements cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkTopKFrequent-8 1875834 648.6 ns/op 200 B/op 11 allocs/op BenchmarkTopKFrequentQuickSort-8 1830498 704.2 ns/op 312 B/op 11 allocs/op PASS ok LeetcodeGolang/Leetcode/0347.Top-K-Frequent-Elements 3.831s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0354.Russian-Doll-Envelopes/":{"url":"Leetcode/0354.Russian-Doll-Envelopes/","title":"0354. Russian Doll Envelope","summary":null,"keywords":"","body":"354. Russian Doll Envelope tagsstart Hard Dynamic Programming Binary Search tagsstop 題目 You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope. One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height. Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other). Note: You cannot rotate an envelope. Example 1: Input: envelopes = [[5,4],[6,4],[6,7],[2,3]] Output: 3 Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]). Example 2: Input: envelopes = [[1,1],[1,1],[1,1]] Output: 1 Constraints: 1 envelopes[i].length == 2 1 題目大意 給一些信封, 每個信封用寬度和高度的整數對形式(w,h)表示, 當一個信封A的寬度和高度都比另一個信封B大的時候, 則B就可以放進A裡. 計算出最多有多少信封能組成一組 解題思路 先對寬度w進行升序排序, 如果遇到w相同的情況, 則按照高度進行降序排序. 之後把所有的h最為一個array, 對此array做 最長遞增子序列(Longest Increasing Subsequence, LIS)的長度就是答案 此題是二維的LIS問題, 一維LIS參考 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0300.Longest-Increasing-Subsequence/main.go 三維 Leetcode No.1691 來源 https://leetcode.com/problems/russian-doll-envelopes/ https://leetcode-cn.com/problems/russian-doll-envelopes/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0354.Russian-Doll-Envelopes/main.go package russiandollenvelopes import ( longestincreasingsubsequence \"LeetcodeGolang/Leetcode/0300.Longest-Increasing-Subsequence\" \"sort\" ) type sortEnvelopes [][]int func (s sortEnvelopes) Len() int { return len(s) } func (s sortEnvelopes) Less(i, j int) bool { if s[i][0] == s[j][0] { // 遇到w相同的情況, 則按照高度進行降序排序 return s[i][1] > s[j][1] } // 對寬度w進行升序排序 return s[i][0] e[1] { // 現在的牌比堆小, 所小範圍 right = mid } else if dp[mid] go test -benchmem -run=none LeetcodeGolang/Leetcode/0354.Russian-Doll-Envelopes -bench=. goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0354.Russian-Doll-Envelopes cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkMaxEnvelopes-8 9067520 167.0 ns/op 88 B/op 3 allocs/op BenchmarkMaxEnvelopes2-8 6726646 214.9 ns/op 80 B/op 4 allocs/op PASS ok LeetcodeGolang/Leetcode/0354.Russian-Doll-Envelopes 6.237s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0380.Insert-Delete-GetRandom-O1/":{"url":"Leetcode/0380.Insert-Delete-GetRandom-O1/","title":"380. Insert Delete GetRandom O(1)","summary":"0380.Insert-Delete-GetRandom-O(1)","keywords":"","body":"380. Insert Delete GetRandom O(1) tagsstart LeetCode Go Medium Insert Delete GetRandom O(1) Array Hash tagsstop 題目 Implement the RandomizedSet class: RandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity. Example 1: Input [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2] Explanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Constraints: -231 題目大意 解題思路 用map紀錄每個元素的index Big O 時間複雜 : O(1) 空間複雜 : O(n) 來源 https://leetcode.com/problems/insert-delete-getrandom-o1/description/ https://leetcode.cn/problems/insert-delete-getrandom-o1/description/ https://www.youtube.com/watch?v=46dZH7LDbf8 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0380.Insert-Delete-GetRandom-O1/main.go package insertdeletegetrandom import \"math/rand\" // 時間複雜 O(1), 空間複雜 O(n) type RandomizedSet struct { arr []int set map[int]int size int } func Constructor() RandomizedSet { arr := make([]int, 0) set := make(map[int]int) size := 0 return RandomizedSet{arr, set, size} } func (this *RandomizedSet) Insert(val int) bool { if _, ok := this.set[val]; ok { return false } this.set[val] = this.size this.size++ this.arr = append(this.arr, val) return true } func (this *RandomizedSet) Remove(val int) bool { index, ok := this.set[val] if !ok { return false } // swapping lastValue := this.arr[this.size-1] this.arr[index] = lastValue this.set[lastValue] = index // Remove last value this.arr = this.arr[:this.size-1] delete(this.set, val) this.size-- return true } func (this *RandomizedSet) GetRandom() int { index := rand.Intn(this.size) return this.arr[index] } /** * Your RandomizedSet object will be instantiated and called as such: * obj := Constructor(); * param_1 := obj.Insert(val); * param_2 := obj.Remove(val); * param_3 := obj.GetRandom(); */ Benchmark Follow up 如果允許重複, 譬如多個1 0381.Insert-Delete-GetRandom-O1-Duplicates-allowed #Hard © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0381.Insert-Delete-GetRandom-O1-Duplicates-allowed/":{"url":"Leetcode/0381.Insert-Delete-GetRandom-O1-Duplicates-allowed/","title":"381.Insert Delete GetRandom O(1) Duplicates allowed","summary":"0381.Insert-Delete-GetRandom-O1-Duplicates-allowed","keywords":"","body":"381.Insert Delete GetRandom O(1) Duplicates allowed tagsstart LeetCode Go Hard Insert Delete GetRandom O(1) Duplicates allowed Array Hash tagsstop 題目 題目大意 解題思路 RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element. Implement the RandomizedCollection class: RandomizedCollection() Initializes the empty RandomizedCollection object. bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise. bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them. int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains. You must implement the functions of the class such that each function works on average O(1) time complexity. Note: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection. Example 1: Input [\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"] [[], [1], [1], [2], [], [1], []] Output [null, true, false, true, 2, true, 1] Explanation RandomizedCollection randomizedCollection = new RandomizedCollection(); randomizedCollection.insert(1); // return true since the collection does not contain 1. // Inserts 1 into the collection. randomizedCollection.insert(1); // return false since the collection contains 1. // Inserts another 1 into the collection. Collection now contains [1,1]. randomizedCollection.insert(2); // return true since the collection does not contain 2. // Inserts 2 into the collection. Collection now contains [1,1,2]. randomizedCollection.getRandom(); // getRandom should: // - return 1 with probability 2/3, or // - return 2 with probability 1/3. randomizedCollection.remove(1); // return true since the collection contains 1. // Removes 1 from the collection. Collection now contains [1,2]. randomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely. Constraints: -231 Big O 時間複雜 : O(1) 空間複雜 : O(n) 來源 https://leetcode.com/problems/insert-delete-getrandom-o1-duplicates-allowed/description/ https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed/description/ https://www.youtube.com/watch?v=46dZH7LDbf8 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0381.Insert-Delete-GetRandom-O1-Duplicates-allowed/main.go package insertdeletegetrandomo1duplicatesallowed import ( \"math/rand\" ) // 時間複雜 O(1), 空間複雜 O(n) type RandomizedCollection struct { arr []int set map[int]map[int]struct{} size int } func Constructor() RandomizedCollection { arr := make([]int, 0) set := make(map[int]map[int]struct{}) size := 0 return RandomizedCollection{arr, set, size} } func (this *RandomizedCollection) Insert(val int) bool { ids, ok := this.set[val] if !ok { // 沒有此數字了, 建立一個index的map ids = map[int]struct{}{} this.set[val] = ids } // index的map, key為當前最後的index, value為空的struct{}{} ids[this.size] = struct{}{} this.arr = append(this.arr, val) this.size++ return !ok } func (this *RandomizedCollection) Remove(val int) bool { ids, ok := this.set[val] if !ok { return false } // 找出此val的的index, 並且把最後一個index的map刪除, 並且把此index的value設為空的struct{}{} var i int for id := range ids { i = id break } // 將最後一筆移到要替換的id this.arr[i] = this.arr[this.size-1] delete(ids, i) // 因為把最後一個元素移到前面了 delete(this.set[this.arr[i]], this.size-1) if i Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0409.Longest-Palindrome/":{"url":"Leetcode/0409.Longest-Palindrome/","title":"0409. Longest Palindrome","summary":null,"keywords":"","body":"409. Longest Palindrome tagsstart Easy String tagsstop 題目 Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, \"Aa\" is not considered a palindrome here. Example 1: Input: s = \"abccccdd\" Output: 7 Explanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7. Example 2: Input: s = \"a\" Output: 1 Explanation: The longest palindrome that can be built is \"a\", whose length is 1. Constraints: 1 s consists of lowercase and/or uppercase English letters only. 題目大意 給定一個包含大寫字母和小寫字母的字符串，找到通過這些字母構造成的最長的回文串。 在構造過程中，請注意區分大小寫。比如 Aa 不能當做一個回文字符串。 注意:假設字符串的長度不會超過 1010。 解題思路 給出一個字符串，要求用這個字符串裡面的字符組成一個回文串，問回文串最多可以組合成多長的？ 這也是一道題水題，然後先統計每個字符的頻次，每個字符能取2個的取2個，不足2個的並且當前構造中的回文串是偶數的情況下（即每2個都陣容了），可以取1個。最後組合出來的就是終止回文串。 來源 https://leetcode.com/problems/longest-palindrome/ 解答 package longestpalindrome func LongestPalindrome(s string) int { counter := make(map[rune]int) for _, r := range s { counter[r]++ } result := 0 for _, v := range counter { result += v / 2 * 2 // 字符出現奇數次，我們可以選擇其中一個, 放在回文串的中間，這可以貢獻一個長度 if result%2 == 0 && v%2 == 1 { result++ } } return result } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0412.Fizz-Buzz/":{"url":"Leetcode/0412.Fizz-Buzz/","title":"412. Fizz Buzz","summary":"0412.Fizz-Buzz","keywords":"","body":"412. Fizz Buzz tagsstart LeetCode Go Easy Fizz Buzz Facebook Microsoft Apple string math tagsstop 題目 Facebook, Microsoft, Apple Given an integer n, return a string array answer (1-indexed) where: answer[i] == \"FizzBuzz\" if i is divisible by 3 and 5. answer[i] == \"Fizz\" if i is divisible by 3. answer[i] == \"Buzz\" if i is divisible by 5. answer[i] == i (as a string) if none of the above conditions are true. Example 1: Input: n = 3 Output: [\"1\",\"2\",\"Fizz\"] Example 2: Input: n = 5 Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"] Example 3: Input: n = 15 Output: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"] Constraints: 1 題目大意 解題思路 Big O 時間複雜 : O(n) 空間複雜 : O(n) 來源 https://leetcode.com/problems/fizz-buzz/description/ https://leetcode.cn/problems/fizz-buzz/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0412.Fizz-Buzz/main.go package fizzbuzz import \"strconv\" // 時間複雜 O(), 空間複雜 O() func fizzBuzz(n int) []string { var result []string for i := 1; i Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0412.Fizz-Buzz cpu: Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz BenchmarkFizzBuzz-4 5918809 287.1 ns/op 112 B/op 3 allocs/op BenchmarkFizzBuzz2-4 5024536 223.8 ns/op 112 B/op 3 allocs/op BenchmarkFizzBuzz3-4 5406643 196.3 ns/op 112 B/op 3 allocs/op PASS ok LeetcodeGolang/Leetcode/0412.Fizz-Buzz 5.507s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0438.Find-All-Anagrams-in-a-String/":{"url":"Leetcode/0438.Find-All-Anagrams-in-a-String/","title":"0438.Find All Anagrams in a String","summary":null,"keywords":"","body":"438. Find All Anagrams in a String tagsstart Medium Sliding Window tagsstop 题目 Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: Input: s = \"cbaebabacd\", p = \"abc\" Output: [0,6] Explanation: The substring with start index = 0 is \"cba\", which is an anagram of \"abc\". The substring with start index = 6 is \"bac\", which is an anagram of \"abc\". Example 2: Input: s = \"abab\", p = \"ab\" Output: [0,1,2] Explanation: The substring with start index = 0 is \"ab\", which is an anagram of \"ab\". The substring with start index = 1 is \"ba\", which is an anagram of \"ab\". The substring with start index = 2 is \"ab\", which is an anagram of \"ab\". Constraints: 1 題目大意 找所有字母異位詞, 就像全排列 給定一個字符串 S 和非空的字符串 P, 找到 S 中所有是 P 得排列, 並返回他的起始 index 解題思路 跟 0567.Permutation-in-String類似, 只是把找到的答案記錄起來 來源 https://leetcode.com/problems/find-all-anagrams-in-a-string/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0438.Find-All-Anagrams-in-a-String/main.go package findallanagramsinastring func FindAnagrams(s string, p string) []int { need, window := make(map[rune]int), make(map[rune]int) for _, c := range p { need[c]++ } left, right := 0, 0 valid := 0 res := []int{} //紀錄結果 for right 0 { window[c]++ if window[c] == need[c] { valid++ } } // fmt.Printf(\"[%d,%d) \\n\", left, right) // 判斷左視窗是否收縮, 看看視窗長度是否同要找的字串的長度 if (right - left) >= len(p) { if valid == len(need) { // 想要的字元都找到了, 紀錄index res = append(res, left) } d := rune(s[left]) left++ if need[d] > 0 { if window[d] == need[d] { valid-- } window[d]-- } } } return res } // 用 slice 取代 map 來優化 func FindAnagramsSlice(s string, p string) []int { need := [256]int{} for _, c := range p { need[c-'a']++ } left, right := 0, 0 count := len(p) res := []int{} for right 0 { count-- } need[c]-- right++ if count == 0 { res = append(res, left) } if (right - left) >= len(p) { d := s[left] - 'a' if need[d] >= 0 { count++ } need[d]++ left++ } } return res } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0509.Fibonacci-Number/":{"url":"Leetcode/0509.Fibonacci-Number/","title":"0509.Fibonacci Number","summary":null,"keywords":"","body":"509. Fibonacci Number tagsstart Easy Dynamic Programming tagsstop 題目 The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n > 1. Given n, calculate F(n). Example 1: Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: Input: n = 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: Input: n = 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Constraints: 0 題目大意 斐波那契數列, 通常用 F(n) 表示 F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 給定 N，計算 F(N)。 提示：0 ≤ N ≤ 30 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377 ,610, 987…… 解題思路 遇到遞迴最好畫出遞迴樹 f(20) / \\ f(19) f(18) ... ... / \\ / \\ f(1) f(2) f(1) f(2) 這一題解法很多，大的分類是四種，遞歸，記憶化搜索(dp)，矩陣快速冪，通項公式。其中記憶化搜索可以寫 3 種方法，自底向上的，自頂向下的，優化空間複雜度版的。通項公式方法實質是求 a^b 這個還可以用快速冪優化時間複雜度到 O(log n) 。 來源 https://books.halfrost.com/leetcode/ChapterFour/0500~0599/0509.Fibonacci-Number/ https://leetcode.com/problems/fibonacci-number/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0509.Fibonacci-Number/Fibonacci-Number.go // --- Directions // Print out the n-th entry in the fibonacci series. // The fibonacci series is an ordering of numbers where // each number is the sum of the preceeding two. // For example, the sequence // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] // forms the first ten entries of the fibonacci series. // Example: // fib(4) === 3 package fibonaccinumber import \"math\" // Fib : iterative 迴圈 O(n) . 空間複雜 O(n). 自底向上的記憶化搜索 func FibIterative(n int) int { var result = []int{0, 1} for i := 2; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0516.Longest-Palindromic-Subsequence/":{"url":"Leetcode/0516.Longest-Palindromic-Subsequence/","title":"516. Longest Palindromic Subsequence","summary":null,"keywords":"","body":"516. Longest Palindromic Subsequence tagsstart Medium Dynamic Programming tagsstop 題目 Given a string s, find the longest palindromic subsequence's length in s. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Example 1: Input: s = \"bbbab\" Output: 4 Explanation: One possible longest palindromic subsequence is \"bbbb\". Example 2: Input: s = \"cbbd\" Output: 2 Explanation: One possible longest palindromic subsequence is \"bb\". Constraints: 1 s consists only of lowercase English letters. 題目大意 給你一個字符串 s，找到 s 中最長的回文子串。 解題思路 來源 https://leetcode.com/problems/longest-palindromic-subsequence/ 解答 © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0543.Diameter-of-Binary-Tree/":{"url":"Leetcode/0543.Diameter-of-Binary-Tree/","title":"0543. Diameter of Binary Tree","summary":"0543.Diameter-of-Binary-Tree","keywords":"","body":"543. Diameter of Binary Tree tagsstart LeetCode Go Easy Diameter of Binary Tree DFS tagsstop 題目 Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2: Input: root = [1,2] Output: 1 Constraints: The number of nodes in the tree is in the range [1, 104]. -100 題目大意 解題思路 左邊的最高高度與右邊的最高高度相加 Big O 時間複雜 O(n), 空間複雜: 最壞 O(n), 平衡樹 O(log(n)) 來源 https://leetcode.com/problems/diameter-of-binary-tree/ https://leetcode.cn/problems/diameter-of-binary-tree/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0543.Diameter-of-Binary-Tree/main.go package diameterofbinarytree import \"LeetcodeGolang/structures\" /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ type TreeNode = structures.TreeNode var maxDiameter int // 時間複雜 O(n), 空間複雜: 最壞 O(n), 平衡樹 O(log(n)) func DiameterOfBinaryTree(root *TreeNode) int { if root == nil { return 0 } maxDiameter = 0 maxDepth(root) return maxDiameter } func maxDepth(node *TreeNode) int { if node == nil { return 0 } left := maxDepth(node.Left) right := maxDepth(node.Right) maxDiameter = max(maxDiameter, left+right) return max(left, right) + 1 } func max(a, b int) int { if a >= b { return a } else { return b } } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0567.Permutation-in-String/":{"url":"Leetcode/0567.Permutation-in-String/","title":"0567.Permutation in String","summary":null,"keywords":"","body":"567. Permutation in String tagsstart Medium Sliding Window tagsstop 題目 Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise. In other words, return true if one of s1's permutations is the substring of s2. Example 1: Input: s1 = \"ab\", s2 = \"eidbaooo\" Output: true Explanation: s2 contains one permutation of s1 (\"ba\"). Example 2: Input: s1 = \"ab\", s2 = \"eidboaoo\" Output: false Constraints: 1 s1 and s2 consist of lowercase English letters. 題目大意 輸入兩個String S1 和 S2 , 判斷 S2 是否包含S1的排列, 也就是要判斷 S2 中是否存在一個子字串是S1的一種全排列 解題思路 Sliding Window 可以用 slice 取代 map 來優化 來源 https://leetcode.com/problems/permutation-in-string/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0567.Permutation-in-String/main.go package permutationinstring func CheckInclusion(s1 string, s2 string) bool { need, window := make(map[rune]int), make(map[rune]int) for _, c := range s1 { need[c]++ } left, right := 0, 0 valid := 0 for right 0 { window[c]++ if window[c] == need[c] { // 該字符長度達到 valid++ } } // fmt.Printf(\"[%d,%d) \\n\", left, right) // 判斷左視窗是否要收縮 // for (right - left) >= len(s1) if (right - left) >= len(s1) { if valid == len(need) { // 全找到 return true } d := rune(s2[left]) left++ if need[d] > 0 { if window[d] == need[d] { valid-- } window[d]-- } } } return false } // 用 slice 取代 map 來優化 func CheckInclusionSlice(s1 string, s2 string) bool { need := [256]int{} for _, c := range s1 { need[c-'a']++ } left, right := 0, 0 count := len(s1) for right 0 { // 有找到 count-- } need[c]-- right++ // fmt.Printf(\"[%d,%d)\\n\", left, right) if count == 0 { return true } // 判斷左視窗是否要收縮 if (right - left) == len(s1) { d := s2[left] - 'a' if need[d] >= 0 { // 符合預期的長度, 但是卻沒找到預期的結果 count++ } need[d]++ left++ } } return false } tags: Medium Leetcode Sliding Window © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0693.Binary-Number-with-Alternating-Bits/":{"url":"Leetcode/0693.Binary-Number-with-Alternating-Bits/","title":"0693.Binary Number with Alternating Bits","summary":null,"keywords":"","body":"693. Binary Number with Alternating Bits tagsstart Medium Bit Manipulation tagsstop 題目 Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: Input: 5 Output: True Explanation: The binary representation of 5 is: 101 Example 2: Input: 7 Output: False Explanation: The binary representation of 7 is: 111. Example 3: Input: 11 Output: False Explanation: The binary representation of 11 is: 1011. Example 4: Input: 10 Output: True Explanation: The binary representation of 10 is: 1010. 題目大意 給定一個正整數，檢查他是否為交替位二進制數：換句話說，就是他的二進制數相鄰的兩個位數永不相等。 解題思路 判斷一個數的二進制位相鄰兩個數是不相等的，即 0101 交叉間隔的，如果是，輸出 true。這一題有多種做法，最簡單的方法就是直接模擬。比較巧妙的方法是通過位運算，合理構造特殊數據進行位運算到達目的。 010101 構造出 101010 兩者相互 & 位運算以後就為 0，因為都“插空”了。 提示： 1 來源 https://books.halfrost.com/leetcode/ChapterFour/0600~0699/0693.Binary-Number-with-Alternating-Bits/ https://leetcode-cn.com/problems/binary-number-with-alternating-bits/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0693.Binary-Number-with-Alternating-Bits/Binary-Number-with-Alternating-Bits.go package binarynumberwithalternatingbits // 暴力解 O(n) func hasAlternatingBits(n int) bool { for n > 0 { preBit := n & 1 n = n / 2 curBit := n & 1 if curBit == preBit { return false } } return true } // 數學解 func hasAlternatingBits2(n int) bool { /* n=5 n= 1 0 1 n >> 1 0 1 0 n^(n>>1) 1 1 1 (XOR 不同時得1) n 1 1 1 n+1 1 0 0 0 n & (n+1) 0 0 0 n=7 n= 1 1 1 n >> 1 0 1 1 n^(n>>1) 1 0 0 (XOR 不同時得1) n 1 0 0 n+1 1 0 1 n & (n+1) 1 0 0 */ n = n ^ (n >> 1) result := n & (n + 1) return result == 0 } © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0695.Max-Area-of-Island/":{"url":"Leetcode/0695.Max-Area-of-Island/","title":"0695.Max Area of Island","summary":"Max Area of Island","keywords":"","body":"695. Max Area of Island tagsstart LeetCode Go Medium Max Area of Island DFS BFS Array & String Matrix tagsstop 題目 You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. The area of an island is the number of cells with a value 1 in the island. Return the maximum area of an island in grid. If there is no island, return 0. Example 1: Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]] Output: 6 Explanation: The answer is not 11, because the island must be connected 4-directionally. Example 2: Input: grid = [[0,0,0,0,0,0,0,0]] Output: 0 Constraints: m == grid.length n == grid[i].length 1 grid[i][j] is either 0 or 1. 題目大意 給定一個由 '1'（陸地）和 '0'（水域）組成的二維矩陣，計算矩陣中連續的1所組成的最大區域的面積。 解題思路 使用BFS或DFS遍歷矩陣，計算每個島嶼的面積，並找到最大的面積值。 給出一個地圖，要求計算上面島嶼的。注意島嶼的定義是要求都是海（為0的點），如果土地（為1的點）靠在地圖邊緣，不能是珊瑚島。 這題和第200題，第1254題解題思路是一致的。 DPS深搜。不過這題需要多處理2件事情，一是注意靠邊緣的島嶼不能計算關係，二是動態維護島嶼的最大面積。 使用DFS的解法： 創建一個變量maxArea，用於記錄最大面積，初始化為0。 遍歷二維網格，對於每個為1的位置，調用dfs函數計算以該位置為起點的島嶼面積。 在dfs函數中，首先檢查當前位置的合法性，如果超出網格範圍或者該位置已經訪問過或者是水域（0），則返回0。 將當前位置標記為已訪問，並初始化面積為1。 遞迴地對當前位置的上、下、左、右四個相鄰位置進行dfs，並將返回的面積加到當前面積上。 返回當前面積。 更新maxArea為當前面積和maxArea中的較大值。 遍歷完整個網格後，返回maxArea作為結果。 時間複雜度: 遍歷整個網格的時間複雜度為O(mn)，其中m和n分別為網格的行數和列數。 空間複雜度: 使用了遞迴調用的栈空間，空間複雜度為O(mn)。 來源 https://leetcode.com/problems/max-area-of-island/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0695.Max-Area-of-Island/main.go package maxareaofisland var ( dir = [][]int{ {-1, 0}, // 上 {0, 1}, // 右 {1, 0}, // 下 {0, -1}, // 左 } ) func MaxAreaOfIsland(grid [][]int) int { result := 0 for i, row := range grid { for j, col := range row { if col == 1 { result = max(result, areaOfIsland(grid, i, j)) } } } return result } // DFS func areaOfIsland(grid [][]int, x, y int) int { if x = len(grid) || y = len(grid[0]) || grid[x][y] == 0 { return 0 } // 設為0，避免重複計算 grid[x][y] = 0 total := 1 // 四個方向查找 for i := 0; i y { return x } return y } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0703.Kth-Largest-Element-in-a-Stream/":{"url":"Leetcode/0703.Kth-Largest-Element-in-a-Stream/","title":"0703. Kth Largest Element in a Stream","summary":"0703.Kth-Largest-Element-in-a-Stream","keywords":"","body":"0703. Kth Largest Element in a Stream tagsstart LeetCode Go Easy Kth Largest Element in a Stream Heap Priority Queue tagsstop 題目 Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. Example 1: Input [\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 Constraints: 1 題目大意 設計一個找到數據流中第 k 大元素的類（class）。 注意是排序後的第 k 大元素，不是第 k 個不同的元素。 請實現 KthLargest 類： KthLargest（int k， int[] nums） 使用整數 k 和整數流 nums 初始化物件。 int add（int val） 將 val 插入數據流 nums 後，返回當前數據流中第 k 大的元素。 解題思路 這題考察優先順序佇列的使用，可以先做下這道類似的題目 215.陣列中的第 K 個最大元素。 golang container/heap Big O 時間複雜 : 初始化時間複雜度為： O(nlog⁡k) ，其中 n 為初始化時 nums 的長度; 單次插入時間複雜度為： O(log⁡k) 空間複雜 : O(k)。 需要使用優先佇列存儲前 k 大的元素 來源 https://leetcode.com/problems/kth-largest-element-in-a-stream/ https://leetcode.cn/problems/kth-largest-element-in-a-stream/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0703.Kth-Largest-Element-in-a-Stream/main.go package kthlargestelementinastream import ( \"container/heap\" \"sort\" ) /** * Your KthLargest object will be instantiated and called as such: * obj := Constructor(k, nums); * param_1 := obj.Add(val); */ // 時間複雜 O(), 空間複雜 O() type KthLargest struct { sort.IntSlice k int } func Constructor(k int, nums []int) KthLargest { kl := KthLargest{k: k} for _, val := range nums { kl.Add(val) } return kl } func (kl *KthLargest) Add(val int) int { heap.Push(kl, val) if kl.Len() > kl.k { heap.Pop(kl) } return kl.IntSlice[0] } func (kl *KthLargest) Push(v interface{}) { kl.IntSlice = append(kl.IntSlice, v.(int)) } func (kl *KthLargest) Pop() interface{} { a := kl.IntSlice v := a[len(a)-1] kl.IntSlice = a[:len(a)-1] return v } func KthLargestStream(k int, nums []int, elem []int) []int { obj := Constructor(k, nums) result := []int{0} for _, val := range elem { obj.Add(val) result = append(result, obj.IntSlice[0]) } return result } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0704.Binary-Search/":{"url":"Leetcode/0704.Binary-Search/","title":"0704.Binary Search","summary":null,"keywords":"","body":"704. Binary Search tagsstart Easy Binary Search tagsstop 題目 Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 Constraints: 1 -104 All the integers in nums are unique. nums is sorted in ascending order. 題目大意 給一個已排序過後的array, 找出target所在index 若未找到回傳 -1 解題思路 提示： 來源 https://leetcode.com/problems/binary-search/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0704.Binary-Search/main.go package binarysearch import \"sort\" func Search(nums []int, target int) int { lenght := len(nums) if lenght target { // 找左邊 right = mid - 1 } } // 都沒找到 return -1 } func Search2(nums []int, target int) int { lenght := len(nums) if lenght >1 mid := int(uint(right+left) >> 1) if nums[mid] == target { return mid } else if nums[mid] target { // 找左邊 right = mid - 1 } } // 都沒找到 return -1 } // 內建sort func BinarySearch(nums []int, target int) int { length := len(nums) index := sort.Search(length, func(i int) bool { return nums[i] >= target }) if index > 1) if nums[middle] == target { return middle } else if target > nums[middle] { return BinarySearchRecursively(nums, target, middle+1, end) } else { return BinarySearchRecursively(nums, target, start, middle-1) } } // 有點類似 nums 小於 target的元素有幾個 func LeftBound(nums []int, target int) (index int) { lenght := len(nums) if lenght >1 mid := int(uint(right+left) >> 1) if nums[mid] == target { // 要繼續找左邊, 所以把右邊變小 right = mid - 1 } else if nums[mid] target { // 找左邊 right = mid - 1 } } // 都沒找到 注意: left越界情況 if left >= lenght || nums[left] != target { return -1 } return left } func RightBound(nums []int, target int) (index int) { lenght := len(nums) if lenght >1 mid := int(uint(right+left) >> 1) if nums[mid] == target { // 注意:要繼續找右邊, 所以把左邊變大=mid+1 left = mid + 1 } else if nums[mid] target { // 找左邊 right = mid - 1 } } // 都沒找到 注意:right越界情況 if right tags: Easy Leetcode Binary Search © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0721.Accounts-Merge/":{"url":"Leetcode/0721.Accounts-Merge/","title":"0721.Accounts Merge","summary":null,"keywords":"","body":"721. Accounts Merge tagsstart Easy Union Find tagsstop 题目 Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emailsrepresenting emails of the account. Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name. After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order. Example 1: Input: accounts = [[\"John\", \"johnsmith@mail.com\", \"john00@mail.com\"], [\"John\", \"johnnybravo@mail.com\"], [\"John\", \"johnsmith@mail.com\", \"john_newyork@mail.com\"], [\"Mary\", \"mary@mail.com\"]] Output: [[\"John\", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'], [\"John\", \"johnnybravo@mail.com\"], [\"Mary\", \"mary@mail.com\"]] Explanation: The first and third John's are the same person as they have the common email \"johnsmith@mail.com\". The second John and Mary are different people as none of their email addresses are used by other accounts. We could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], ['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted. Note: The length of accounts will be in the range [1, 1000]. The length of accounts[i] will be in the range [1, 10]. The length of accounts[i][j] will be in the range [1, 30]. 題目大意 給定一個列表 accounts，每個元素 accounts[i] 是一個字符串列表，其中第一個元素 accounts[i][0] 是 名稱 (name)，其餘元素是 emails 表示該賬戶的郵箱地址。 現在，我們想合併這些賬戶。如果兩個賬戶都有一些共同的郵箱地址，則兩個賬戶必定屬於同一個人。請注意，即使兩個賬戶具有相同的名稱，它們也可能屬於不同的人，因為人們可能具有相同的名稱。一個人最初可以擁有任意數量的賬戶，但其所有賬戶都具有相同的名稱。 合併賬戶後，按以下格式返回賬戶：每個賬戶的第一個元素是名稱，其餘元素是按字符 ASCII 順序排列的郵箱地址。賬戶本身可以以任意順序返回。 解題思路 給出一堆賬戶和對應的郵箱。要求合併同一個人的多個郵箱賬戶。 如果這個人名和所屬的其中之一的郵箱是相同的，就判定這是同一個人的郵箱，那麼就合併這些郵箱。 這題的解題思路是並查集。不過如果用暴力合併的方法，時間複雜度非常差。優化方法是先把每組數據都進行編號，人編號，每個郵箱都進行編號。這個映射關係用 map 記錄起來。如果利用並查集的 union() 操作，把這些編號都進行合併。最後把人的編號和對應郵箱的編號拼接起來。 這一題有 2 處比較“坑”的是，不需要合併的用戶的郵箱列表也是需要排序和去重的，同一個人的所有郵箱集合都要合併到一起。具體見測試用例。不過題目中也提到了這些點，也不能算題目坑，只能歸自己沒注意這些邊界情況。 來源 https://books.halfrost.com/leetcode/ChapterFour/0700~0799/0721.Accounts-Merge/ 時間複雜度：O(n log n) 其中 n 是不同郵箱地址的數量。 需要遍歷所有郵箱地址，在並查集內進行查找和合併操作，對於兩個不同的郵箱地址， 如果它們的祖先不同則需要進行合併，需要進行 2 次查找和最多 1 次合併。一共需要進行 2n 次查找和最多 n 次合併， 因此時間複雜度是 O(2n log n) = O(n log n)。 這裡的並查集使用了路徑壓縮，但是沒有使用按秩合併， 最壞情況下的時間複雜度是O(n log n)，平均情況下的時間複雜度依然是 O(nα(n))，其中α 為阿克曼函數的反函數，α(n) 可以認為是一個很小的常數。 整理出題目要求的返回賬戶的格式時需要對郵箱地址排序，時間複雜度是 O(n log n)。 其餘操作包括遍歷所有郵箱地址，在哈希表中記錄相應的信息，時間複雜度是O(n)， 在漸進意義下O(n) 小於O(nlog n)。 因此總時間複雜度是 O(n log n)。 作者：LeetCode-Solution 鏈接：https://leetcode-cn.com/problems/accounts-merge/solution/zhang-hu-he-bing-by-leetcode-solution-3dyq/ 來源：力扣（LeetCode） 著作權歸作者所有。商業轉載請聯繫作者獲得授權，非商業轉載請註明出處。 來源 https://books.halfrost.com/leetcode/ChapterFour/0700~0799/0721.Accounts-Merge/ https://leetcode-cn.com/problems/accounts-merge/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0721.Accounts-Merge/Accounts-Merge.go package accountsmerge import ( \"LeetcodeGolang/template\" \"sort\" ) // TODO: 優化 func AccountsMerge(accounts [][]string) (result [][]string) { // result := [][]string{} emailToIndex := map[string]int{} emailToName := map[string]string{} indexToEmails := map[int][]string{} for _, account := range accounts { name := account[0] for _, email := range account[1:] { if _, has := emailToIndex[email]; !has { // 紀錄 email, 對寫入到 對應的index 跟 對應的user name emailToIndex[email] = len(emailToIndex) emailToName[email] = name } } } parent := make([]int, len(emailToIndex)) // 初始化 for i := range parent { parent[i] = i } var find func(int) int find = func(x int) int { if parent[x] != x { // 遞迴一直找下去 parent[x] = find(parent[x]) } return parent[x] } union := func(from, to int) { parent[find(from)] = find(to) } for _, account := range accounts { firstIndex := emailToIndex[account[1]] for _, email := range account[2:] { union(emailToIndex[email], firstIndex) } } for email, index := range emailToIndex { index = find(index) indexToEmails[index] = append(indexToEmails[index], email) } for _, emails := range indexToEmails { for i := 0; i © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0733.Flood-Fill/":{"url":"Leetcode/0733.Flood-Fill/","title":"0733.Flood Fill","summary":"0733.Flood Fill","keywords":"","body":"0733.Flood Fill tagsstart LeetCode Go Easy Flood Fill BFS DFS tagsstop 題目 An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr,sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color. Return the modified image after performing the flood fill. Example 1: Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel. Example 2: Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0 Output: [[0,0,0],[0,0,0]] Explanation: The starting pixel is already colored 0, so no changes are made to the image. Constraints: m == image.length n == image[i].length 1 0 0 0 題目大意 有一個以二維整數陣列表示的圖畫，每個整數表示該圖畫的像素值大小，數值在 0 到 65535 之間。 給你一個坐標 (sr, sc) 表示圖像渲染開始的像素值（行 ，列）和一個新的顏色值新顏色，讓您重新上色該幅圖像。 為了完成上顏色工作，從主板坐標開始，記錄主板坐標的上下四個方向上像素值與主板坐標相同的完整像素點，連接再記錄這四個方向上條件符合的像素點與它們對應的四個像素點方向上像素值與主板坐標的連通像素點相同，……，重複該過程。將所有有記錄的像素點的顏色值改為新的顏色值。最後返回經過上顏色渲染後的圖像。 注意： image 和 image[0] 的長度在範圍 [1, 50] 內。 給出的初始點將滿足 0 image[i][j] 和 newColor 表示的顏色值在範圍 [0, 65535] 內。 解題思路 一個給出二維的圖片點陣，每個點陣都有一個數字。給出起點一個坐標，要求從這個起點坐標開始，把所有與這個起點設置的點都染色成新的顏色。 這題是標準的洪水填充算法。可以用 DFS 也可以用 BFS 。 BFS比較適合找最短路徑，DFS比較適合找所有路徑 DFS使用遞迴比較好寫 使用DFS的解法： 檢查起始點的顏色是否等於新的顏色，如果是則直接返回圖像。 呼叫深度優先搜索函數dfs，傳入起始點座標sr和sc。 在dfs函數中，檢查當前座標的顏色是否等於起始點的顏色，如果是則將其顏色修改為新的顏色。 遞迴地對當前座標的四個相鄰方格進行dfs。 返回填充完成的圖像。 時間複雜度: 圖像中的每個方格最多被訪問一次，因此時間複雜度為O(mn)，其中m和n分別為圖像的行數和列數。 空間複雜度: 使用了遞迴調用的栈空間，空間複雜度為O(mn)。 使用BFS的解題思路如下： 檢查起始點的顏色是否等於新的顏色，如果是則直接返回圖像。 創建一個隊列，將起始點的座標(sr, sc)加入隊列中。 創建一個訪問過的集合，將起始點的座標(sr, sc)添加到集合中，表示已經訪問過。 進入BFS循環，當隊列不為空時，執行以下操作： 從隊列中取出一個座標(current_r, current_c)。 檢查該座標的顏色是否等於起始點的顏色，如果是，將該座標的顏色修改為新的顏色。 檢查該座標的四個相鄰方格，如果相鄰方格的座標有效且顏色等於起始點的顏色，且該相鄰方格的座標還沒有被訪問過，則將該相鄰方格的座標加入隊列中，同時將該相鄰方格的座標添加到訪問過的集合中。 重複以上步驟，直到隊列為空。 返回填充完成的圖像。 時間複雜度和空間複雜度的分析與DFS解法相同。 使用BFS的解法同樣可以完成泛洪填充的任務，不同的是使用隊列來保存待處理的座標，而不是使用遞迴函數。 來源 https://leetcode.com/problems/flood-fill/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0733.Flood-Fill/main.go package floodfill // DFS func FloodFill(image [][]int, sr int, sc int, color int) [][]int { oldColor := image[sr][sc] if color == oldColor { return image } dfsfill(image, sr, sc, oldColor, color) return image } func dfsfill(image [][]int, row, col, oldColor, newColor int) { // Check if the current pixel is out of bounds or does not have the old color if row = len(image) || col = len(image[0]) || image[row][col] != oldColor { return } // Update the current pixel with the new color image[row][col] = newColor // Recursively perform flood fill on the adjacent pixels dfsfill(image, row-1, col, oldColor, newColor) // Up dfsfill(image, row+1, col, oldColor, newColor) // Down dfsfill(image, row, col-1, oldColor, newColor) // Left dfsfill(image, row, col+1, oldColor, newColor) // Right } type Point struct { row, col int } func FloodFillBFS(image [][]int, sr int, sc int, newColor int) [][]int { // Check if the starting point is out of bounds or already has the new color if sr = len(image) || sc = len(image[0]) || image[sr][sc] == newColor { return image } // Get the old color at the starting point oldColor := image[sr][sc] // Create a queue and enqueue the starting point queue := []Point{{sr, sc}} // Define the directions (up, down, left, right) directions := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} // Perform BFS for len(queue) > 0 { // Dequeue a point from the queue point := queue[0] queue = queue[1:] // Update the point with the new color image[point.row][point.col] = newColor // Explore the neighboring pixels for _, dir := range directions { newRow, newCol := point.row+dir[0], point.col+dir[1] // Check if the neighboring pixel is within bounds and has the old color if newRow >= 0 && newRow = 0 && newCol Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0733.Flood-Fill cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkFloodFillDFS-8 384756555 4.486 ns/op 0 B/op 0 allocs/op BenchmarkFloodFillBFS-8 309088303 3.642 ns/op 0 B/op 0 allocs/op PASS ok LeetcodeGolang/Leetcode/0733.Flood-Fill 3.572s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0746.Min-Cost-Climbing-Stairs/":{"url":"Leetcode/0746.Min-Cost-Climbing-Stairs/","title":"746. Min Cost Climbing Stairs","summary":"0746.Min-Cost-Climbing-Stairs","keywords":"","body":"746. Min Cost Climbing Stairs tagsstart LeetCode Go Easy Min Cost Climbing Stairs tagsstop 題目 You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor. Example 1: Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1. Pay 15 and climb two steps to reach the top. The total cost is 15. Example 2: Input: cost = [1,100,1,1,1,100,1,1,100,1] Output: 6 Explanation: You will start at index 0. Pay 1 and climb two steps to reach index 2. Pay 1 and climb two steps to reach index 4. Pay 1 and climb two steps to reach index 6. Pay 1 and climb one step to reach index 7. Pay 1 and climb two steps to reach index 9. Pay 1 and climb one step to reach the top. The total cost is 6. Constraints: 2 題目大意 陣列的每個索引做為一個階梯，第 i 個階梯對應著一個非負數的體力花費值 cost[i] （索引從 0 開始）。 每當你爬上一個階梯你都要花費對應的體力花費值，然後你可以選擇繼續爬一個階梯或者爬兩個階梯。 您需要找到達到樓層頂部的最低花費。 在開始時，你可以選擇從索引為 0 或 1 的元素作為初始階梯。 解題思路 cur 變數存儲從第 i-2 步到達第 i 步的最小花費。 last 變數存儲從第 i-1 步到達第 i 步的最小花費。 在每次迭代中，函數都會比較 cur 和 last 變數的值，並選擇較小的那個存儲在 cur 變數中。 在迭代結束時，last 變數將存儲爬完所有樓梯的最小花費。 cost := []int{1, 100, 1, 1, 1, 100, 1, 1, 100, 1} 迭代 cur last 2 0 1 3 1 2 4 2 2 5 2 3 6 3 3 7 3 4 8 4 4 9 4 5 10 5 6 Big O 時間複雜 : O(n) 空間複雜 : O(1) 來源 https://leetcode.com/problems/min-cost-climbing-stairs/ https://leetcode.cn/problems/min-cost-climbing-stairs/ https://books.halfrost.com/leetcode/ChapterFour/0700~0799/0746.Min-Cost-Climbing-Stairs/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0746.Min-Cost-Climbing-Stairs/main.go package mincostclimbingstairs // 時間複雜 O(n), 空間複雜 O(1) func MinCostClimbingStairs(cost []int) int { dp := make([]int, len(cost)) dp[0], dp[1] = cost[0], cost[1] for i := 2; i b { return b } return a } // 時間複雜 O(n), 空間複雜 O(1) // 優化 // 使用了兩個變數cur和last， // cur 變數存儲從第 i-2 步到達第 i 步的最小花費。 // last 變數存儲從第 i-1 步到達第 i 步的最小花費。 // 比較兩種選擇的花費： // 從第2階開始（i := 2），一直迭代到最後一階（i cur+cost[i-2] { cur, last = last, cur+cost[i-2] } else { cur, last = last, last+cost[i-1] } // fmt.Printf(\"%-d | %-d | %-d\\n\", i, cur, last) } return last } Benchmark goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/0746.Min-Cost-Climbing-Stairs cpu: Intel(R) Core(TM) i5-6400 CPU @ 2.70GHz BenchmarkMinCostClimbingStairs-4 36693742 30.17 ns/op 24 B/op 1 allocs/op BenchmarkMinCostClimbingStairsOptimize-4 405489464 3.091 ns/op 0 B/op 0 allocs/op PASS ok LeetcodeGolang/Leetcode/0746.Min-Cost-Climbing-Stairs 2.713s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0752.Open-the-Lock/":{"url":"Leetcode/0752.Open-the-Lock/","title":"0752.Open the Lock","summary":null,"keywords":"","body":"752. Open the Lock tagsstart Medium Breadth First Search tagsstop You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot. The lock initially starts at '0000', a string representing the state of the 4 wheels. You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it. Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible. Example 1: Input: deadends = [\"0201\",\"0101\",\"0102\",\"1212\",\"2002\"], target = \"0202\" Output: 6 Explanation: A sequence of valid moves would be \"0000\" -> \"1000\" -> \"1100\" -> \"1200\" -> \"1201\" -> \"1202\" -> \"0202\". Note that a sequence like \"0000\" -> \"0001\" -> \"0002\" -> \"0102\" -> \"0202\" would be invalid, because the wheels of the lock become stuck after the display becomes the dead end \"0102\". Example 2: Input: deadends = [\"8888\"], target = \"0009\" Output: 1 Explanation: We can turn the last wheel in reverse to move from \"0000\" -> \"0009\". Example 3: Input: deadends = [\"8887\",\"8889\",\"8878\",\"8898\",\"8788\",\"8988\",\"7888\",\"9888\"], target = \"8888\" Output: -1 Explanation: We cannot reach the target without getting stuck. Constraints: 1 deadends[i].length == 4 target.length == 4 target will not be in the list deadends. target and deadends[i] consist of digits only. 題目大意 有一個四個圓形播盤的轉盤鎖, 每個播盤有0~9共10個數字, 每個播盤上下旋轉可以把 0變成9 或 9變成0. 每次只能旋轉一個播盤 初始直接為0.且有一組 deadends 數組. 不能接數字轉到其中任一組. 如果無法得到 target 回傳 -1 解題思路 從 0000開始轉, 轉一次可窮舉出 \"1000\", \"9000\", \"0100\", \"0900\", \"0010\", \"0090\", \"0001\", \"0009\". 8 總可能, 再以這八種密碼為基礎, 對每總密碼再轉一下, 窮舉出每個可能 可以抽象成一副圖, 每個節點有8個相鄰的節點, 讓你求出最短距離 方法二: 還可以用雙向BFS, 從起點跟終點開始擴散, 當兩邊有交集時停止 方法三: 雙向 BFS 優化, 在 while 開始時做一個判斷. 讓每次都選擇較小的集合進行擴散, 那麼佔用的空間增長速度就會慢一些, 盡可能以最小的空間代價產生 curDepth 和 nextDepth 的交集 無論單向的 BFS 或是 雙向BFS, 優化過的BFS 空間複雜度都是一樣的 來源 https://leetcode.com/problems/open-the-lock/ https://books.halfrost.com/leetcode/ChapterFour/0700~0799/0752.Open-the-Lock/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0752.Open-the-Lock/main.go package openthelock // 方法ㄧ: 單向BFS func OpenLock(deadends []string, target string) int { if target == \"0000\" { return 0 } targetNum := strToInt(target) // 紀錄已窮舉過的密碼, 防止走回頭路 visited := make([]bool, 10000) visited[0] = true for _, deadend := range deadends { num := strToInt(deadend) if num == 0 { return -1 } visited[num] = true } depth, curDepth, nextDepth := 0, []int16{0}, make([]int16, 0) var nextNum int16 for len(curDepth) > 0 { nextDepth = nextDepth[0:0] // 當前Queue中所有的節點向外擴散 for _, curNum := range curDepth { // 遍歷八種組合 for incrementer := int16(1000); incrementer > 0; incrementer /= 10 { nextNum = PlusOne(curNum, incrementer) if nextNum == targetNum { return depth + 1 } if !visited[nextNum] { visited[nextNum] = true nextDepth = append(nextDepth, nextNum) } nextNum = MinusOne(curNum, incrementer) if nextNum == targetNum { return depth + 1 } if !visited[nextNum] { visited[nextNum] = true nextDepth = append(nextDepth, nextNum) } } } curDepth, nextDepth = nextDepth, curDepth // 增加步數 depth++ } return -1 } /* Note: Golang set type void struct{} var member void set := make(map[string]void) // New empty set set[\"Foo\"] = member // Add for k := range set { // Loop fmt.Println(k) } delete(set, \"Foo\") // Delete size := len(set) // Size _, exists := set[\"Foo\"] // Membership */ // 方法二: 雙向BFS. 不在使用 Queue而是用 hashset, 快速判斷兩者是否交集 // 從起點跟終點開始擴散, 當兩邊有交集時停止 func OpenLockBiDirection(deadends []string, target string) int { if target == \"0000\" { return 0 } targetNum := strToInt(target) // 紀錄已窮舉過的密碼, 防止走回頭路 visited := make([]bool, 10000) for _, deadend := range deadends { num := strToInt(deadend) if num == 0 { return -1 } visited[num] = true } depth := 0 // 起點跟終點初始化 curDepth := make(map[int16]struct{}) nextDepth := make(map[int16]struct{}) curDepth[0] = struct{}{} nextDepth[targetNum] = struct{}{} var nextNum int16 for len(curDepth) != 0 && len(nextDepth) != 0 { // 儲存 curDepth 的擴散結果 tmp := make(map[int16]struct{}) // curDepth的節點向外擴散 for curNum := range curDepth { // 判斷是否達到終點 if visited[curNum] { continue } _, exists := nextDepth[curNum] if exists { return depth } visited[curNum] = true // 遍歷八種組合 for incrementer := int16(1000); incrementer > 0; incrementer /= 10 { nextNum = PlusOne(curNum, incrementer) if !visited[nextNum] { tmp[nextNum] = struct{}{} } nextNum = MinusOne(curNum, incrementer) if !visited[nextNum] { tmp[nextNum] = struct{}{} } } } // 小技巧, 這裏交換 curDepth, nextDepth . // 下一輪 whihe會擴散 nextDepth. // 所以只要默認擴散curDepth, 就相當於輪流擴散curDepth, nextDepth curDepth, nextDepth = nextDepth, tmp // 增加步數 depth++ } return -1 } // 方法三 : 雙向 BFS 優化, 在 while 開始時做一個判斷. 讓每次都選擇較小的集合進行擴散, // 那麼佔用的空間增長速度就會慢一些, 盡可能以最小的空間代價產生 curDepth 和 nextDepth 的交集 // 無論單向的 BFS 或是 雙向BFS, 優化過的BFS 空間複雜度都是一樣的 func OpenLockBiDirectionOptimization(deadends []string, target string) int { if target == \"0000\" { return 0 } targetNum := strToInt(target) // 紀錄已窮舉過的密碼, 防止走回頭路 visited := make([]bool, 10000) for _, deadend := range deadends { num := strToInt(deadend) if num == 0 { return -1 } visited[num] = true } depth := 0 // 起點跟終點初始化 curDepth := make(map[int16]struct{}) nextDepth := make(map[int16]struct{}) curDepth[0] = struct{}{} nextDepth[targetNum] = struct{}{} var nextNum int16 for len(curDepth) != 0 && len(nextDepth) != 0 { if len(curDepth) > len(nextDepth) { curDepth, nextDepth = nextDepth, curDepth } // 儲存 curDepth 的擴散結果 tmp := make(map[int16]struct{}) // curDepth的節點向外擴散 for curNum := range curDepth { // 判斷是否達到終點 if visited[curNum] { continue } _, exists := nextDepth[curNum] if exists { return depth } visited[curNum] = true // 遍歷八種組合 for incrementer := int16(1000); incrementer > 0; incrementer /= 10 { nextNum = PlusOne(curNum, incrementer) if !visited[nextNum] { tmp[nextNum] = struct{}{} } nextNum = MinusOne(curNum, incrementer) if !visited[nextNum] { tmp[nextNum] = struct{}{} } } } // 小技巧, 這裏交換 curDepth, nextDepth . // 下一輪 whihe會擴散 nextDepth. // 所以只要默認擴散curDepth, 就相當於輪流擴散curDepth, nextDepth curDepth, nextDepth = nextDepth, tmp // 增加步數 depth++ } return -1 } func PlusOne(curNum int16, incrementer int16) (nextNum int16) { digit := (curNum / incrementer) % 10 if digit == 9 { nextNum = curNum - 9*incrementer } else { nextNum = curNum + incrementer } return nextNum } func MinusOne(curNum int16, incrementer int16) (nextNum int16) { digit := (curNum / incrementer) % 10 if digit == 0 { nextNum = curNum + 9*incrementer } else { nextNum = curNum - incrementer } return nextNum } func strToInt(str string) int16 { return int16(str[0]-'0')*1000 + int16(str[1]-'0')*100 + int16(str[2]-'0')*10 + int16(str[3]-'0') } tags: Medium Leetcode BFS © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0875.Koko-Eating-Bananas/":{"url":"Leetcode/0875.Koko-Eating-Bananas/","title":"875. Koko Eating Bananas","summary":"0875.Koko-Eating-Bananas","keywords":"","body":"875. Koko Eating Bananas tagsstart LeetCode Go Medium Koko Eating Bananas Array Binary Search tagsstop 題目 題目大意 珂珂喜歡吃香蕉。 這裡有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。 警衛已經離開了，將在 H 小時後回來。 可以決定她吃香蕉的速度 K （單位：根/小時）。 每個小時，她將會選擇一堆香蕉，從中吃掉 K 根。 如果這堆香蕉少於 K 根，她將吃掉這堆的所有香蕉，然後這一小時內不會再吃更多的香蕉。 珂珂喜歡慢慢吃，但仍然想在警衛回來前吃掉所有的香蕉。 返回她可以在 H 小時內吃掉所有香蕉的最小速度 K（K 為整數）。 解題思路 這一題可以用二分搜索來解答。 在 [0 , max(piles)] 的範圍內搜索，二分的過程都是常規思路。 判斷是否左右邊界如果劃分的時候需要注意題目中給的限定條件。 當香蕉個數小於 k 的時候，那個小時不能再吃其他香蕉了。 Big O 時間複雜 : O（n log m），其中 n 是香蕉堆的數量，m 是香蕉堆中香蕉數量的最大值 空間複雜 : O(1) 來源 https://leetcode.com/problems/koko-eating-bananas/description/ https://leetcode.cn/problems/koko-eating-bananas/description/ https://books.halfrost.com/leetcode/ChapterFour/0800~0899/0875.Koko-Eating-Bananas/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0875.Koko-Eating-Bananas/main.go package kokoeatingbananas // 時間複雜 O（n log m）, 空間複雜 O(1) func minEatingSpeed(piles []int, h int) int { // 找出最大的香蕉堆 left, right := 1, maxPile(piles) for left > 1) if executeTime(piles, mid) 0 { time++ } // time += int(math.Ceil(float64(pile) / float64(k))) } return time } func maxPile(piles []int) int { result := 0 for _, pile := range piles { if result Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0876.Middle-of-the-Linked-List/":{"url":"Leetcode/0876.Middle-of-the-Linked-List/","title":"0876.Middle of the Linked List","summary":null,"keywords":"","body":"876. Middle of the Linked List tagsstart Easy Linked List Two Pointers tagsstop 題目 Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. Example 1: Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2: Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. Constraints: The number of nodes in the list is in the range [1, 100]. 1 題目大意 尋找無環的 linked list 的中間節點 解題思路 使用 two pointer. 讓快指針往前兩步. 慢指針往前一步. 當快指針到達盡頭時, 慢指針就位於linked list的中間位置. 當linked list的長度為奇數時, slow剛好停在中點位置; 如果長度為偶數, slow停在中間偏右 來源 https://leetcode.com/problems/middle-of-the-linked-list/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0876.Middle-of-the-Linked-List/main.go package middleofthelinkedlist /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ type ListNode struct { Val int Next *ListNode } func MiddleNode(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } fast, slow := head, head for fast.Next != nil && fast.Next.Next != nil { fast = fast.Next.Next slow = slow.Next } // 算出長度 curr := head length := 0 for curr != nil { length++ curr = curr.Next } if length%2 == 0 { // 偶數 return slow.Next } else { // 奇數 return slow } } tags: Medium Leetcode two pointers © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/0981.Time-Based-Key-Value-Store/":{"url":"Leetcode/0981.Time-Based-Key-Value-Store/","title":"0981.Time Based Key-Value Store","summary":"0981.Time-Based-Key-Value-Store","keywords":"","body":"0981.Time Based Key-Value Store tagsstart LeetCode Go Medium Time Based Key-Value Store Hash Table String Binary Search Design tagsstop 題目 題目大意 解題思路 Big O 時間複雜 : `` 空間複雜 : `` 來源 https://leetcode.com/problems/time-based-key-value-store/description/ https://leetcode.cn/problems/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/0981.Time-Based-Key-Value-Store/main.go package timebasedkeyvaluestore import \"sort\" // 時間複雜 O(), 空間複雜 O() type element struct { key string value string timestamp int } type TimeMap struct { elements map[string][]element } func Constructor() TimeMap { return TimeMap{elements: make(map[string][]element)} } func (this *TimeMap) Set(key string, value string, timestamp int) { this.elements[key] = append(this.elements[key], element{ key: key, value: value, timestamp: timestamp, }) } // O(log n) func (this *TimeMap) Get(key string, timestamp int) string { if _, ok := this.elements[key]; !ok { return \"\" } // 二分法找出符合條件的最左邊 index := sort.Search(len(this.elements[key]), func(i int) bool { return this.elements[key][i].timestamp > timestamp }) if index == 0 { return \"\" } index-- return this.elements[key][index].value } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/1046.Last-Stone-Weight/":{"url":"Leetcode/1046.Last-Stone-Weight/","title":"1046. Last Stone Weight","summary":"1046.Last-Stone-Weight","keywords":"","body":"1046. Last Stone Weight tagsstart LeetCode Go Easy Heap Priority Queue Last Stone Weight tagsstop 題目 You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x If x == y, both stones are destroyed, and If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. Return the weight of the last remaining stone. If there are no stones left, return 0. Example 1: Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone. Example 2: Input: stones = [1] Output: 1 Constraints: 1 題目大意 有一個集合 stones，每個 stone 的重量由正整數表示。 每次可以選擇兩個不同的石頭，將它們一起粉碎，然後得到一個新的石頭，其重量為兩者之差。 你需要重複這個過程，直到集合中只剩下一個石頭，或者集合中沒有石頭為止。 在這個過程中，找到可能的最後一顆石頭的重量。如果集合中沒有石頭，則返回 0。 Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: 步驟1：選擇石頭 7 和 8，得到新石頭 [2,4,1,1,1]。 步驟2：選擇石頭 2 和 4，得到新石頭 [2,1,1,1]。 步驟3：選擇石頭 2 和 1，得到新石頭 [1,1,1]。 步驟4：選擇石頭 1 和 1，得到新石頭 [0,1]。 步驟5：選擇石頭 1 和 0，得到新石頭 [1]。 最後剩下的石頭的重量為 1。 解題思路 將 stones 陣列轉換為最大堆（max heap），可以使用優先佇列實現。 進行迴圈，每次從最大堆中取出兩個最大的石頭。 如果兩個石頭不相等，將它們的差值插入最大堆。 重複上述步驟，直到最大堆中只剩下一個石頭或沒有石頭為止。 如果最大堆中有石頭，返回該石頭的重量，否則返回 0。 這樣的做法確保每次都選擇最大的兩個石頭進行粉碎，最終留下的石頭重量就是可能的最後一個石頭的重量。 參考 0215 Kth Largest Element in an Array Big O 時間複雜 : O(nlogn) 空間複雜 : O(n) n 是石頭數量. 每次從隊列中取出元素需要話O(logn) 的時間, 最多共需要需要粉碎 n−1 次石頭 來源 https://leetcode.com/problems/last-stone-weight/ https://leetcode.cn/problems/last-stone-weight/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/1046.Last-Stone-Weight/main.go package laststoneweight import ( \"container/heap\" \"fmt\" \"sort\" ) /* // IntSlice attaches the methods of Interface to []int, sorting in increasing order. type IntSlice []int func (x IntSlice) Len() int { return len(x) } func (x IntSlice) Less(i, j int) bool { return x[i] h.IntSlice[j] } func (h *hp) Push(v interface{}) { h.IntSlice = append(h.IntSlice, v.(int)) } func (h *hp) Pop() interface{} { old := h.IntSlice v := old[len(old)-1] h.IntSlice = old[:len(old)-1] return v } func (h *hp) PushInt(v int) { heap.Push(h, v) } func (h *hp) PopInt() int { return heap.Pop(h).(int) } // 時間複雜 O(nlogn), 空間複雜 O(n) // n 是石頭數量. 每次從隊列中取出元素需要話O(logn) 的時間, 最多共需要需要粉碎 n−1 次石頭 func LastStoneWeight(stones []int) int { q := &hp{stones} heap.Init(q) fmt.Println(q) for q.Len() > 1 { fmt.Println(q) x, y := q.PopInt(), q.PopInt() fmt.Printf(\"%d,%d\\n\", x, y) if x > y { q.PushInt(x - y) } } if q.Len() > 0 { return q.IntSlice[0] } return 0 } Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/1143.Longest-Common-Subsequence/":{"url":"Leetcode/1143.Longest-Common-Subsequence/","title":"1143.Longest Common Subsequence","summary":null,"keywords":"","body":"1143. Longest Common Subsequence tagsstart Medium Dynamic Programming tagsstop 題目 Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\". A common subsequence of two strings is a subsequence that is common to both strings. Example 1: Input: text1 = \"abcde\", text2 = \"ace\" Output: 3 Explanation: The longest common subsequence is \"ace\" and its length is 3. Example 2: Input: text1 = \"abc\", text2 = \"abc\" Output: 3 Explanation: The longest common subsequence is \"abc\" and its length is 3. Example 3: Input: text1 = \"abc\", text2 = \"def\" Output: 0 Explanation: There is no such common subsequence, so the result is 0. Constraints: 1 text1 and text2 consist of only lowercase English characters. 題目大意 給兩個string 求出, 這兩個string 的最長公共子序列的長度, 如果不存在返回0. 譬如 str1=\"abcde\", str2=\"aceb\", 輸出為3, 因為最長公共子序列是\"ace\" 解題思路 暴力解法, 用遞迴 dp(i,j) 表示 s1[0..i]和s2[0..j]中最長公共子序列的長度, 如果s1[i]==s2[j], 說明這個公共字符一定在lcs中, 如果知道了s1[0..i-1]和s2[0..j-1]中的lcs長度, 再加1就是s1[0..i]和s2[0..j]中lcs的長度 if (str[i] == str2[j]) { dp(i,j) = dp(i-1,j-1)+1 } 如果s1[i]!=s2[j], 說明這兩個字符至少有一個不在lcs中, if (str[i] != str2[j]){ dp(i,j) = max( dp(i-1,j) , dp(i,j-1)) } def longestCommonSubsequence(str1,str2) ->int: def dp(i,j): # 空的base code if i == -1 or j == -1: return 0 if str[i] == str2[j]: # 找到一個lcs中的元素 return dp(i-1, j-1)+1 if str[i] != str2[j]: # 至少有一個字符不在lcs中, 都試一下,看誰能讓lcs最長 return max( dp(i-1,j) , dp(i,j-1)) return dp(len(str1)-1,len(str2)-1) DP優化 int longestCommonSubsequence(string str1, string str2) { int m = str1.size(), n = str2.size(); // 定義對s1[0..i-1] 和 s2[0..j-1], 他們的lcs長度是dp[i][j] vector> dp(m + 1, vector(n + 1, 0)); // base case: dp[0][...] = dp[..][0] = 0, 已初始化 for (int i = 1; i 來源 https://leetcode.com/problems/longest-common-subsequence/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/1143.Longest-Common-Subsequence/main.go package longestcommonsubsequence func LongestCommonSubsequence(text1 string, text2 string) int { var dp func(int, int) int dp = func(i, j int) int { if i == -1 || j == -1 { return 0 } if text1[i] == text2[j] { return dp(i-1, j-1) + 1 } if text1[i] != text2[j] { return max(dp(i-1, j), dp(i, j-1)) } return 0 } return dp(len(text1)-1, len(text2)-1) } func LongestCommonSubsequenceDP(text1 string, text2 string) int { m, n := len(text1), len(text2) if m == 0 || n == 0 { return 0 } dp := make([][]int, m+1) for i := range dp { dp[i] = make([]int, n+1) } for i := 1; i b { return a } return b } goos: darwin goarch: amd64 pkg: LeetcodeGolang/Leetcode/1143.Longest-Common-Subsequence cpu: Intel(R) Core(TM) i5-8259U CPU @ 2.30GHz BenchmarkLongestCommonSubsequence-8 100 737158262 ns/op 0 B/op 0 allocs/op BenchmarkLongestCommonSubsequenceDP-8 2355297 491.3 ns/op 912 B/op 8 allocs/op PASS ok LeetcodeGolang/Leetcode/1143.Longest-Common-Subsequence 75.400s © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Leetcode/1195.Fizz-Buzz-Multithreaded/":{"url":"Leetcode/1195.Fizz-Buzz-Multithreaded/","title":"1195. Fizz Buzz Multithreaded","summary":"1195.Fizz-Buzz-Multithreaded","keywords":"","body":"1195. Fizz Buzz Multithreaded tagsstart LeetCode Go Medium Fizz Buzz Multithreaded Concurrency tagsstop 題目 You have the four functions: printFizz that prints the word \"fizz\" to the console, printBuzz that prints the word \"buzz\" to the console, printFizzBuzz that prints the word \"fizzbuzz\" to the console, and printNumber that prints a given integer to the console. You are given an instance of the class FizzBuzz that has four functions: fizz, buzz, fizzbuzz and number. The same instance of FizzBuzz will be passed to four different threads: Thread A: calls fizz() that should output the word \"fizz\". Thread B: calls buzz() that should output the word \"buzz\". Thread C: calls fizzbuzz() that should output the word \"fizzbuzz\". Thread D: calls number() that should only output the integers. Modify the given class to output the series [1, 2, \"fizz\", 4, \"buzz\", ...] where the ith token (1-indexed) of the series is: \"fizzbuzz\" if i is divisible by 3 and 5, \"fizz\" if i is divisible by 3 and not 5, \"buzz\" if i is divisible by 5 and not 3, or i if i is not divisible by 3 or 5. Implement the FizzBuzz class: FizzBuzz(int n) Initializes the object with the number n that represents the length of the sequence that should be printed. void fizz(printFizz) Calls printFizz to output \"fizz\". void buzz(printBuzz) Calls printBuzz to output \"buzz\". void fizzbuzz(printFizzBuzz) Calls printFizzBuzz to output \"fizzbuzz\". void number(printNumber) Calls printnumber to output the numbers. Example 1: Input: n = 15 Output: [1,2,\"fizz\",4,\"buzz\",\"fizz\",7,8,\"fizz\",\"buzz\",11,\"fizz\",13,14,\"fizzbuzz\"] Example 2: Input: n = 5 Output: [1,2,\"fizz\",4,\"buzz\"] Constraints: 1 題目大意 解題思路 Big O 時間複雜 : 空間複雜 : 來源 https://leetcode.com/problems/fizz-buzz-multithreaded/description/ https://leetcode.cn/problems/fizz-buzz-multithreaded/description/ 解答 https://github.com/kimi0230/LeetcodeGolang/blob/master/Leetcode/1195.Fizz-Buzz-Multithreaded/main.go package fizzbuzzmultithreaded import ( \"fmt\" \"sync\" ) var ( wg = sync.WaitGroup{} ) // 時間複雜 O(), 空間複雜 O() func FizzBuzz(n int) { fb := NewFizzBuzz() wg.Add(4) go fb.fizz() go fb.buzz() go fb.fizzbuzz() go fb.number() for i := 1; i Benchmark © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"structures/":{"url":"structures/","title":"Structures","keywords":"","body":"來源 https://github.com/halfrost/LeetCode-Go/tree/master/structures © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"structures/heap/index.en.html":{"url":"structures/heap/index.en.html","title":"Golang Container Heap","summary":"0703.Kth-Largest-Element-in-a-Stream","keywords":"","body":"Golang : container/heap tagsstart Go container/heap tagsstop Heap是什麼 Wiki: https://zh.wikipedia.org/wiki/%E5%A0%86%E7%A9%8D 堆積（Heap）是電腦科學中的一種特別的完全二元樹。 若是滿足以下特性，即可稱為堆積：「給定堆積中任意節點P和C，若P是C的母節點，那麼P的值會小於等於（或大於等於）C的值」。 若母節點的值恆小於等於子節點的值，此堆積稱為最小堆積（min heap）； 反之，若母節點的值恆大於等於子節點的值，此堆積稱為最大堆積（max heap）。 在堆積中最頂端的那一個節點，稱作根節點（root node），根節點本身沒有母節點（parent node）。 container/heap 提供的方法 heap包為實現了 heap.Interface 的類型提供了堆方法：Init/Push/Pop/Remove/Fix。 container/heap 為最小堆， 即每個節點的值都小於它的子樹的所有元素的值（A heap is a tree with the property that each node is the minimum-valued node in its subtree）。 heap: package heap // ... // Note that Push and Pop in this interface are for package heap's // implementation to call. To add and remove things from the heap, // use heap.Push and heap.Pop. type Interface interface { sort.Interface Push(x any) // add x as element Len() Pop() any // remove and return element Len() - 1. } sort: package sort // An implementation of Interface can be sorted by the routines in this package. // The methods refer to elements of the underlying collection by integer index. type Interface interface { // Len is the number of elements in the collection. Len() int // Less reports whether the element with index i // must sort before the element with index j. // // If both Less(i, j) and Less(j, i) are false, // then the elements at index i and j are considered equal. // Sort may place equal elements in any order in the final result, // while Stable preserves the original input order of equal elements. // // Less must describe a transitive ordering: // - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well. // - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well. // // Note that floating-point comparison (the 由於 heap.Interface 包含了 sort.Interface ，所以，目標類型需要包含如下方法：Len/Less/Swap ,Push/Pop。 container/heap 可用在哪 container/heap包可以用來構造優先順序佇列。 https://go.dev/play/p/77zrF3PurO4 // This example demonstrates a priority queue built using the heap interface. package main import ( \"container/heap\" \"fmt\" ) // An Item is something we manage in a priority queue. type Item struct { value string // The value of the item; arbitrary. priority int // The priority of the item in the queue. // The index is needed by update and is maintained by the heap.Interface methods. index int // The index of the item in the heap. } // A PriorityQueue implements heap.Interface and holds Items. type PriorityQueue []*Item func (pq PriorityQueue) Len() int { return len(pq) } func (pq PriorityQueue) Less(i, j int) bool { // We want Pop to give us the highest, not lowest, priority so we use greater than here. return pq[i].priority > pq[j].priority } func (pq PriorityQueue) Swap(i, j int) { pq[i], pq[j] = pq[j], pq[i] pq[i].index = i pq[j].index = j } func (pq *PriorityQueue) Push(x interface{}) { n := len(*pq) item := x.(*Item) item.index = n *pq = append(*pq, item) } func (pq *PriorityQueue) Pop() interface{} { old := *pq n := len(old) item := old[n-1] item.index = -1 // for safety *pq = old[0 : n-1] return item } // update modifies the priority and value of an Item in the queue. func (pq *PriorityQueue) update(item *Item, value string, priority int) { item.value = value item.priority = priority heap.Fix(pq, item.index) } PriorityQueue 本質上是個 *Item 陣列，其Len/Less/Swap是比較常見的陣列用來sort需要定義的函數，而Push、Pop則是使用數位來插入、的方法。 PriorityQueue 還提供了update方法。 注意由於通常希望優先順序佇列Pop出來的是優先順序最高的元素，所以Less方法是反著寫的。 定義了以上方法以後， PriorityQueue 就具備了使用 container/heap 包的條件。 如下代碼，先從items map出發定義了一個pq陣列，長度為hash的size，並調用 heap.Init 初始化pq; 之後向佇列中增加了一個優先順序為1的元素，並更新該元素的佇列; 最後從佇列中依此Pop，可見元素在Pop時是依照優先順序排序的。 // This example creates a PriorityQueue with some items, adds and manipulates an item, // and then removes the items in priority order. func main() { // Some items and their priorities. items := map[string]int{ \"banana\": 3, \"apple\": 2, \"pear\": 4, } // Create a priority queue, put the items in it, and // establish the priority queue (heap) invariants. pq := make(PriorityQueue, len(items)) i := 0 for value, priority := range items { pq[i] = &Item{ value: value, priority: priority, index: i, } i++ } heap.Init(&pq) // Insert a new item and then modify its priority. item := &Item{ value: \"orange\", priority: 1, } heap.Push(&pq, item) pq.update(item, item.value, 5) // Take the items out; they arrive in decreasing priority order. for pq.Len() > 0 { item := heap.Pop(&pq).(*Item) fmt.Printf(\"%.2d:%s index:%d \\n\", item.priority, item.value, item.index) } } // Output: // 05:orange index:-1 // 04:pear index:-1 // 03:banana index:-1 // 02:apple index:-1 Reference Golang: 详解container/heap © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"template/":{"url":"template/","title":"Template","keywords":"","body":"來源 https://github.com/halfrost/LeetCode-Go/tree/master/template © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"CHANGELOG.html":{"url":"CHANGELOG.html","title":"CHANGELOG","keywords":"","body":"kk2 © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 "},"Content.html":{"url":"Content.html","title":"Content","keywords":"","body":"Kimi's LeetcodeGolang Notes Algorithms A 1 B 2 C 3 A1B2C3: Two Go Routine Print A1B2C3....Z26 Find Target Last Index Find Target Last Index Intersection Of Two Sorted Arrays Using In Place Approach Intersection Of Two Sorted Arrays Using In Place Approach Search Graph Search Graph In Golang Weighted Edit Distance Code Signal Bank Requests Bank Requests Codility Lesson 0001.Iterations Binary Gap Binary Gap 0002.Array Cyclic Rotation Cyclic Rotation Odd Occurrences In Array 0003.Time-Complexity Frog Jmp Perm Missing Elem Tape Equilibrium 0004.Counting-Elements Frog River One Max Counters Missing Integer Perm Check 0005.Prefix-Sums Count Div Genomic Range Query Min Avg Two Slice Passing Cars 0006.Sorting Distinct Max Product Of Three Number Of Disc Intersections Triangle 0007.Stacks-and-Queues Brackets Fish Nesting Stone Wall 0008.Leader Dominator Equi Leader 0009.Maximum-Slice-Problem Max Double Slice Sum Max Profit Max Slice Sum 0010.Prime-And-Composite-Numbers Count Factors Flags Min Perimeter Rectangle Peaks 0011.Sieve-of-Eratosthenes Count Non Divisible Count Semiprimes 0012.Euclidean-Algorithm Chocolates By Numbers Common Prime Divisors 0013.Fibonacci-Numbers Fib Frog 0015.Caterpillar-Method Abs Distinct Geeksfor Geeks Sorting Algorithms 0031.Find-Minimum-Difference-Between-Any-Two-Elements Leetcode 0000.xxxx NUM.LEETCODETITLE 0001.Two-Sum Merging 2 Packages 0001.Two Sum 0002.Add-Two-Numbers 0002.Add Two Numbers 0003.Longest-Substring-Without-Repeating-Characters 0003.Longest Substring Without Repeating Characters 0005.Longest-Palindromic-Substring 0005. Longest Palindromic Substring 0011.Container-With-Most-Water 0011.Container With Most Water 0015.3Sum 0015. 3Sum 0019.Remove-Nth-Node-From-End-of-List 0019. Remove Nth Node From End of List 0020.Valid-Parentheses 0020. Valid Parentheses 0021.Merge-Two-Sorted-Lists 0021. Merge Two Sorted Lists 0027.Remove-Element 0027.Remove Element 0028.Find-the-Index-of-the-First-Occurrence-in-a-String 0028. Find the Index of the First Occurrence in a String 0033.Search-in-Rotated-Sorted-Array 33. Search in Rotated Sorted Array 0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array 0034. Find First and Last Position of Element in Sorted Array 0035.Search-Insert-Position 0035.Search Insert Position 0046.Permutations 0049.Group-Anagrams 0049.Group Anagrams 0053.Maximum-Subarray 0053.Maximum Subarray 0059.Spiral-Matrix-II 0059.Spiral Matrix II 0070.Climbing-Stairs 0070.Climbing Stairs 0072.Edit-Distance 0072. Edit Distance 0074.Search-a-2D-Matrix 74. Search a 2D Matrix 0075.Sort-Colors 0075.Sort Colors 0078.Subsets 0078. Subsets 0088.Merge-Sorted-Array 0088.Merge Sorted Array 0094.Binary-Tree-Inorder-Traversal 0094.Binary Tree Inorder Traversal 0100.Same-Tree 100. Same Tree 0104.Maximum-Depth-of-Binary-Tree 0104.Maximum Depth of Binary Tree 0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal 105. Construct Binary Tree from Preorder and Inorder Traversal 0110.Balanced-Binary-Tree 110. Balanced Binary Tree 0121.Best-Time-to-Buy-and-Sell-Stock 0121.Best Time to Buy and Sell Stock 0125.Valid-Palindrome 0125. Valid Palindrome 0128.Longest-Consecutive-Sequence 128. Longest Consecutive Sequence 0138.Copy-List-with-Random-Pointer 138. Copy List with Random Pointer 0141.Linked-List-Cycle 0141.Linked List Cycle 0142.Linked-List-CycleII 0142.Linked List Cycle II 0143.Reorder-List 143. Reorder List 0153.Find-Minimum-in-Rotated-Sorted-Array 0167.Two-Sum-II-Input-Array-Is-Sorted 0167.Two Sum II Input Array Is Sorted 0203.Remove-Linked-List-Elements 0203.Remove Linked List Elements 0206.Reverse-Linked-List 206. Reverse Linked List 0209.Minimum-Size-Subarray-Sum 0209. Minimum Size Subarray Sum 0215.Kth-Largest-Element-in-an-Array 0215. Kth Largest Element in an Array 0217.Contains-Duplicate 0226.Invert-Binary-Tree 226. Invert Binary Tree 0238.Product-of-Array-Except-Self 238. Product of Array Except Self 0242.Valid-Anagram 0283.Move-Zeroes 0283. Move Zeroes 0300.Longest-Increasing-Subsequence 0300.Longest Increasing Subsequence 0310.Minimum-Height-Trees 0310.Minimum Height Trees 0322.Coin-Change 0322.Coin Change 0344.Reverse-String 0344.Reverse String 0347.Top-K-Frequent-Elements 347. Top K Frequent Elements 0354.Russian-Doll-Envelopes 0354. Russian Doll Envelope 0380.Insert-Delete-GetRandom-O1 380. Insert Delete GetRandom O(1) 0381.Insert-Delete-GetRandom-O1-Duplicates-allowed 381.Insert Delete GetRandom O(1) Duplicates allowed 0409.Longest-Palindrome 0409. Longest Palindrome 0412.Fizz-Buzz 412. Fizz Buzz 0438.Find-All-Anagrams-in-a-String 0438.Find All Anagrams in a String 0509.Fibonacci-Number 0509.Fibonacci Number 0516.Longest-Palindromic-Subsequence 516. Longest Palindromic Subsequence 0543.Diameter-of-Binary-Tree 0543. Diameter of Binary Tree 0567.Permutation-in-String 0567.Permutation in String 0693.Binary-Number-with-Alternating-Bits 0693.Binary Number with Alternating Bits 0695.Max-Area-of-Island 0695.Max Area of Island 0703.Kth-Largest-Element-in-a-Stream 0703. Kth Largest Element in a Stream 0704.Binary-Search 0704.Binary Search 0721.Accounts-Merge 0721.Accounts Merge 0733.Flood-Fill 0733.Flood Fill 0746.Min-Cost-Climbing-Stairs 746. Min Cost Climbing Stairs 0752.Open-the-Lock 0752.Open the Lock 0875.Koko-Eating-Bananas 875. Koko Eating Bananas 0876.Middle-of-the-Linked-List 0876.Middle of the Linked List 0981.Time-Based-Key-Value-Store 0981.Time Based Key-Value Store 1046.Last-Stone-Weight 1046. Last Stone Weight 1143.Longest-Common-Subsequence 1143.Longest Common Subsequence 1195.Fizz-Buzz-Multithreaded 1195. Fizz Buzz Multithreaded Structures Heap Golang Container Heap Template CHANGELOG Content Tags © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:37:50 "},"tags.html":{"url":"tags.html","title":"Tags","keywords":"","body":"Tags © Kimi Tsai all right reserved.            Updated : 2024-05-06 09:36:37 Algorithm A1B2C3: Two Go Routine Print A1B2C3....Z26 Golang A1B2C3: Two Go Routine Print A1B2C3....Z26 Intersection Of Two Sorted Arrays Using In Place Approach Search Graph In Golang Weighted Edit Distance 0072. Edit Distance A1B2C3 A1B2C3: Two Go Routine Print A1B2C3....Z26 Interview Find Target Last Index Algorithms Find Target Last Index Intersection Of Two Sorted Arrays Using In Place Approach Search Graph In Golang Go Find Target Last Index Bank Requests Binary Gap Cyclic Rotation NUM.LEETCODETITLE 0002.Add Two Numbers 0003.Longest Substring Without Repeating Characters 0005. Longest Palindromic Substring 0011.Container With Most Water 0015. 3Sum 0019. Remove Nth Node From End of List 0020. Valid Parentheses 0021. Merge Two Sorted Lists 0028. Find the Index of the First Occurrence in a String 33. Search in Rotated Sorted Array 0034. Find First and Last Position of Element in Sorted Array 0049.Group Anagrams 0053.Maximum Subarray 0070.Climbing Stairs 74. Search a 2D Matrix 0078. Subsets 100. Same Tree 0104.Maximum Depth of Binary Tree 105. Construct Binary Tree from Preorder and Inorder Traversal 110. Balanced Binary Tree 0121.Best Time to Buy and Sell Stock 0125. Valid Palindrome 128. Longest Consecutive Sequence 138. Copy List with Random Pointer 143. Reorder List 0153.Find-Minimum-in-Rotated-Sorted-Array 0167.Two Sum II Input Array Is Sorted 206. Reverse Linked List 0215. Kth Largest Element in an Array 0217.Contains-Duplicate 226. Invert Binary Tree 238. Product of Array Except Self 0242.Valid-Anagram 0283. Move Zeroes 0322.Coin Change 347. Top K Frequent Elements 380. Insert Delete GetRandom O(1) 381.Insert Delete GetRandom O(1) Duplicates allowed 412. Fizz Buzz 0543. Diameter of Binary Tree 0695.Max Area of Island 0703. Kth Largest Element in a Stream 0733.Flood Fill 746. Min Cost Climbing Stairs 875. Koko Eating Bananas 0981.Time Based Key-Value Store 1046. Last Stone Weight 1195. Fizz Buzz Multithreaded Golang Container Heap Easy Find Target Last Index 0001.Two Sum 0020. Valid Parentheses 0027.Remove Element 0028. Find the Index of the First Occurrence in a String 0035.Search Insert Position 0070.Climbing Stairs 0088.Merge Sorted Array 100. Same Tree 0104.Maximum Depth of Binary Tree 110. Balanced Binary Tree 0121.Best Time to Buy and Sell Stock 0125. Valid Palindrome 0141.Linked List Cycle 0203.Remove Linked List Elements 206. Reverse Linked List 0217.Contains-Duplicate 226. Invert Binary Tree 0242.Valid-Anagram 0283. Move Zeroes 0344.Reverse String 0409. Longest Palindrome 412. Fizz Buzz 0509.Fibonacci Number 0543. Diameter of Binary Tree 0703. Kth Largest Element in a Stream 0704.Binary Search 0721.Accounts Merge 0733.Flood Fill 746. Min Cost Climbing Stairs 0876.Middle of the Linked List 1046. Last Stone Weight Find Target Last Index Find Target Last Index Right Bound Find Target Last Index Left Bound Find Target Last Index Intersection Intersection Of Two Sorted Arrays Using In Place Approach Search Graph Search Graph In Golang BFS Search Graph In Golang 226. Invert Binary Tree 0695.Max Area of Island 0733.Flood Fill WeightedEditDistance Weighted Edit Distance Dynamic Programming Weighted Edit Distance 0053.Maximum Subarray 0072. Edit Distance 0300.Longest Increasing Subsequence 0322.Coin Change 0354. Russian Doll Envelope 0509.Fibonacci Number 516. Longest Palindromic Subsequence 1143.Longest Common Subsequence CodeSignal Bank Requests Bank Requests Bank Requests Codility Binary Gap Cyclic Rotation Iterations Binary Gap Painless Binary Gap Cyclic Rotation Bitwise Manipulation Binary Gap Array Cyclic Rotation 0003.Longest Substring Without Repeating Characters 0011.Container With Most Water 0015. 3Sum 0027.Remove Element 33. Search in Rotated Sorted Array 0034. Find First and Last Position of Element in Sorted Array 0035.Search Insert Position 0053.Maximum Subarray 0059.Spiral Matrix II 74. Search a 2D Matrix 0088.Merge Sorted Array 105. Construct Binary Tree from Preorder and Inorder Traversal 128. Longest Consecutive Sequence 0167.Two Sum II Input Array Is Sorted 0217.Contains-Duplicate 238. Product of Array Except Self 380. Insert Delete GetRandom O(1) 381.Insert Delete GetRandom O(1) Duplicates allowed 875. Koko Eating Bananas Multiple Pointers Cyclic Rotation LeetCode NUM.LEETCODETITLE 0002.Add Two Numbers 0003.Longest Substring Without Repeating Characters 0005. Longest Palindromic Substring 0011.Container With Most Water 0015. 3Sum 0019. Remove Nth Node From End of List 0020. Valid Parentheses 0021. Merge Two Sorted Lists 0028. Find the Index of the First Occurrence in a String 33. Search in Rotated Sorted Array 0034. Find First and Last Position of Element in Sorted Array 0049.Group Anagrams 0053.Maximum Subarray 0070.Climbing Stairs 74. Search a 2D Matrix 0078. Subsets 100. Same Tree 0104.Maximum Depth of Binary Tree 105. Construct Binary Tree from Preorder and Inorder Traversal 110. Balanced Binary Tree 0121.Best Time to Buy and Sell Stock 0125. Valid Palindrome 128. Longest Consecutive Sequence 138. Copy List with Random Pointer 143. Reorder List 0153.Find-Minimum-in-Rotated-Sorted-Array 0167.Two Sum II Input Array Is Sorted 206. Reverse Linked List 0215. Kth Largest Element in an Array 0217.Contains-Duplicate 226. Invert Binary Tree 238. Product of Array Except Self 0242.Valid-Anagram 0283. Move Zeroes 0322.Coin Change 347. Top K Frequent Elements 380. Insert Delete GetRandom O(1) 381.Insert Delete GetRandom O(1) Duplicates allowed 412. Fizz Buzz 0543. Diameter of Binary Tree 0695.Max Area of Island 0703. Kth Largest Element in a Stream 0733.Flood Fill 746. Min Cost Climbing Stairs 875. Koko Eating Bananas 0981.Time Based Key-Value Store 1046. Last Stone Weight 1195. Fizz Buzz Multithreaded Easy/Medium/Hard NUM.LEETCODETITLE 0021. Merge Two Sorted Lists LEETCODETITLE NUM.LEETCODETITLE 0104.Maximum Depth of Binary Tree 0153.Find-Minimum-in-Rotated-Sorted-Array Medium 0002.Add Two Numbers 0003.Longest Substring Without Repeating Characters 0005. Longest Palindromic Substring 0011.Container With Most Water 0015. 3Sum 0019. Remove Nth Node From End of List 33. Search in Rotated Sorted Array 0034. Find First and Last Position of Element in Sorted Array 0046.Permutations 0049.Group Anagrams 0053.Maximum Subarray 0059.Spiral Matrix II 74. Search a 2D Matrix 0075.Sort Colors 0078. Subsets 0094.Binary Tree Inorder Traversal 105. Construct Binary Tree from Preorder and Inorder Traversal 128. Longest Consecutive Sequence 138. Copy List with Random Pointer 0142.Linked List Cycle II 0153.Find-Minimum-in-Rotated-Sorted-Array 0167.Two Sum II Input Array Is Sorted 0209. Minimum Size Subarray Sum 0215. Kth Largest Element in an Array 238. Product of Array Except Self 0300.Longest Increasing Subsequence 0310.Minimum Height Trees 0322.Coin Change 347. Top K Frequent Elements 380. Insert Delete GetRandom O(1) 0438.Find All Anagrams in a String 516. Longest Palindromic Subsequence 0567.Permutation in String 0693.Binary Number with Alternating Bits 0695.Max Area of Island 0752.Open the Lock 875. Koko Eating Bananas 0981.Time Based Key-Value Store 1143.Longest Common Subsequence 1195. Fizz Buzz Multithreaded Add Two Numbers 0002.Add Two Numbers Linked List 0002.Add Two Numbers 0019. Remove Nth Node From End of List 0141.Linked List Cycle 0142.Linked List Cycle II 143. Reorder List 0203.Remove Linked List Elements 0876.Middle of the Linked List Math 0002.Add Two Numbers Recursion 0002.Add Two Numbers 143. Reorder List Amazon 0002.Add Two Numbers 0005. Longest Palindromic Substring 0011.Container With Most Water 0019. Remove Nth Node From End of List 33. Search in Rotated Sorted Array 74. Search a 2D Matrix 128. Longest Consecutive Sequence 138. Copy List with Random Pointer 143. Reorder List 0153.Find-Minimum-in-Rotated-Sorted-Array Apple 0002.Add Two Numbers 33. Search in Rotated Sorted Array 412. Fizz Buzz Facebook 0002.Add Two Numbers 0005. Longest Palindromic Substring 0011.Container With Most Water 0019. Remove Nth Node From End of List 33. Search in Rotated Sorted Array 74. Search a 2D Matrix 138. Copy List with Random Pointer 143. Reorder List 0153.Find-Minimum-in-Rotated-Sorted-Array 412. Fizz Buzz Microsoft 0002.Add Two Numbers 0005. Longest Palindromic Substring 0011.Container With Most Water 0019. Remove Nth Node From End of List 33. Search in Rotated Sorted Array 74. Search a 2D Matrix 128. Longest Consecutive Sequence 138. Copy List with Random Pointer 143. Reorder List 0153.Find-Minimum-in-Rotated-Sorted-Array 412. Fizz Buzz Bloomberg 0002.Add Two Numbers 0019. Remove Nth Node From End of List 74. Search a 2D Matrix 138. Copy List with Random Pointer 143. Reorder List Longest Substring Without Repeating Characters 0003.Longest Substring Without Repeating Characters Sliding Window 0003.Longest Substring Without Repeating Characters 0209. Minimum Size Subarray Sum 0438.Find All Anagrams in a String 0567.Permutation in String Hash Table 0003.Longest Substring Without Repeating Characters 105. Construct Binary Tree from Preorder and Inorder Traversal 128. Longest Consecutive Sequence 0981.Time Based Key-Value Store String 0003.Longest Substring Without Repeating Characters 0028. Find the Index of the First Occurrence in a String 0409. Longest Palindrome 0981.Time Based Key-Value Store DP 0005. Longest Palindromic Substring 0070.Climbing Stairs 0121.Best Time to Buy and Sell Stock Google 0005. Longest Palindromic Substring 0011.Container With Most Water 0019. Remove Nth Node From End of List 128. Longest Consecutive Sequence 138. Copy List with Random Pointer Adobe 0005. Longest Palindromic Substring 0011.Container With Most Water 128. Longest Consecutive Sequence 143. Reorder List 0153.Find-Minimum-in-Rotated-Sorted-Array Container With Most Water 0011.Container With Most Water Two Pointers 0011.Container With Most Water 0015. 3Sum 0019. Remove Nth Node From End of List 0028. Find the Index of the First Occurrence in a String 0141.Linked List Cycle 0142.Linked List Cycle II 143. Reorder List 0167.Two Sum II Input Array Is Sorted 0344.Reverse String 0876.Middle of the Linked List Greedy 0011.Container With Most Water 3Sum 0015. 3Sum Sorting 0015. 3Sum 0215. Kth Largest Element in an Array Valid Parentheses 0020. Valid Parentheses Merge Two Sorted Lists 0021. Merge Two Sorted Lists Find the Index of the First Occurrence in a String 0028. Find the Index of the First Occurrence in a String String Matching 0028. Find the Index of the First Occurrence in a String Binary Search 33. Search in Rotated Sorted Array 0034. Find First and Last Position of Element in Sorted Array 74. Search a 2D Matrix 0167.Two Sum II Input Array Is Sorted 0300.Longest Increasing Subsequence 0354. Russian Doll Envelope 0704.Binary Search 875. Koko Eating Bananas 0981.Time Based Key-Value Store 33. Search in Rotated Sorted Array 33. Search in Rotated Sorted Array LinkedIn 33. Search in Rotated Sorted Array Find First and Last Position of Element in Sorted Array 0034. Find First and Last Position of Element in Sorted Array Backtracking 0046.Permutations Group Anagrams 0049.Group Anagrams Blind75 0053.Maximum Subarray 0121.Best Time to Buy and Sell Stock 0217.Contains-Duplicate 238. Product of Array Except Self Climbing Stairs 0070.Climbing Stairs Hard 0072. Edit Distance 0354. Russian Doll Envelope 381.Insert Delete GetRandom O(1) Duplicates allowed Edit Distance 0072. Edit Distance Search a 2D Matrix 74. Search a 2D Matrix Matrix 74. Search a 2D Matrix 0695.Max Area of Island Sort 0075.Sort Colors Subsets 0078. Subsets Stack 0094.Binary Tree Inorder Traversal 143. Reorder List Same Tree 100. Same Tree Tree 100. Same Tree 105. Construct Binary Tree from Preorder and Inorder Traversal Construct Binary Tree from Preorder and Inorder Traversal 105. Construct Binary Tree from Preorder and Inorder Traversal Divide and Conquer 105. Construct Binary Tree from Preorder and Inorder Traversal Binary Tree 105. Construct Binary Tree from Preorder and Inorder Traversal Balanced Binary Tree 110. Balanced Binary Tree DFS 110. Balanced Binary Tree 0543. Diameter of Binary Tree 0695.Max Area of Island 0733.Flood Fill Slide Windows 0121.Best Time to Buy and Sell Stock Best Time to Buy and Sell Stock 0121.Best Time to Buy and Sell Stock array 0121.Best Time to Buy and Sell Stock amazon 0121.Best Time to Buy and Sell Stock bloomberg 0121.Best Time to Buy and Sell Stock facebook 0121.Best Time to Buy and Sell Stock microsoft 0121.Best Time to Buy and Sell Stock uber 0121.Best Time to Buy and Sell Stock Valid Palindrome 0125. Valid Palindrome Longest Consecutive Sequence 128. Longest Consecutive Sequence Union Find 128. Longest Consecutive Sequence 0721.Accounts Merge Spotify 128. Longest Consecutive Sequence Copy List with Random Pointer 138. Copy List with Random Pointer /Medium 143. Reorder List 143. Reorder List 143. Reorder List Goldman Sachs 0153.Find-Minimum-in-Rotated-Sorted-Array Two Sum II Input Array Is Sorted 0167.Two Sum II Input Array Is Sorted Reverse Linked List 206. Reverse Linked List Kth Largest Element in an Array 0215. Kth Largest Element in an Array Heap 0215. Kth Largest Element in an Array 0703. Kth Largest Element in a Stream 1046. Last Stone Weight Priority Queue 0215. Kth Largest Element in an Array 0703. Kth Largest Element in a Stream 1046. Last Stone Weight Contains Duplicate 0217.Contains-Duplicate Invert Binary Tree 226. Invert Binary Tree Product of Array Except Self 238. Product of Array Except Self Prefix Sum 238. Product of Array Except Self Valid Anagram 0242.Valid-Anagram Move Zeroes 0283. Move Zeroes Patience Sorting 0300.Longest Increasing Subsequence Breadth First Search 0310.Minimum Height Trees 0752.Open the Lock Coin Change 0322.Coin Change Top K Frequent Elements 347. Top K Frequent Elements heap 347. Top K Frequent Elements Insert Delete GetRandom O(1) 380. Insert Delete GetRandom O(1) Hash 380. Insert Delete GetRandom O(1) 381.Insert Delete GetRandom O(1) Duplicates allowed Insert Delete GetRandom O(1) Duplicates allowed 381.Insert Delete GetRandom O(1) Duplicates allowed Fizz Buzz 412. Fizz Buzz string 412. Fizz Buzz math 412. Fizz Buzz Diameter of Binary Tree 0543. Diameter of Binary Tree Bit Manipulation 0693.Binary Number with Alternating Bits Max Area of Island 0695.Max Area of Island Array & String 0695.Max Area of Island Kth Largest Element in a Stream 0703. Kth Largest Element in a Stream Flood Fill 0733.Flood Fill Min Cost Climbing Stairs 746. Min Cost Climbing Stairs Koko Eating Bananas 875. Koko Eating Bananas Time Based Key-Value Store 0981.Time Based Key-Value Store Design 0981.Time Based Key-Value Store Last Stone Weight 1046. Last Stone Weight Fizz Buzz Multithreaded 1195. Fizz Buzz Multithreaded Concurrency 1195. Fizz Buzz Multithreaded container/heap Golang Container Heap "}}