# Solution - UMPIRE

## Output 1: UMPIRE 解題（完整思考版）

### U – Understand（理解題目）
- **題目描述**：給定一個整數陣列 `nums` 和一個目標值 `target`，找出陣列中兩個整數，使其相加等於 `target`，並回傳這兩個數字的索引值。
- **關鍵限制**：
  - 每種輸入剛好只有一個解。
  - 同一個元素不能使用兩次。
  - 回傳索引的順序不限。
- **潛在陷阱**：
  - 負數的存在（`target` 或 `nums[i]` 可能為負）。
  - 陣列長度最小為 2。
- **測試案例**：
  - **Happy Path**: `nums = [2, 7, 11, 15], target = 9` -> `[0, 1]`
  - **Edge Case 1 (重複數字)**: `nums = [3, 3], target = 6` -> `[0, 1]`
  - **Edge Case 2 (負數)**: `nums = [-1, -8, 5], target = -9` -> `[0, 1]`

### M – Match（匹配知識）
- **主要演算法/資料結構**：**Hash Table (Map)**。
- **為什麼匹配**：
  - 暴力法 (O(n²)) 需要兩層迴圈。
  - 使用 Hash Table 可以將查找時間從 O(n) 降低到 O(1)，總時間複雜度優化至 O(n)。
- **其他嘗試**：
  - **排序 + 雙指針**: 雖然空間複雜度可降至 O(1)，但因為需要回傳原始索引，排序會打亂索引，處理起來較複雜且時間複雜度為 O(n log n)，不如 Hash Table 快。

### P – Plan（制定計畫）
- 建立一個空的 Map `m`，Key 存數字的值，Value 存該數字的索引。
- 遍歷 `nums` 陣列，對於當前數字 `v` 與索引 `i`：
  1. 計算所需的差值 `complement = target - v`。
  2. 檢查 `complement` 是否已存在於 Map `m` 中。
  3. 如果存在，代表找到了這兩個數，直接回傳 `[]int{m[complement], i}`。
  4. 如果不存在，將當前數字與索引存入 Map：`m[v] = i`。
- 預防 Bug：確保先檢查再存入，以避免「同一個元素使用兩次」（例如 target 是 6，當前數字是 3）。

### I – Implement（實際實作，Golang）
```go
func twoSum(nums []int, target int) []int {
    // 建立 hash map 存儲 {值: 索引}
    m := make(map[int]int)
    
    for i, v := range nums {
        complement := target - v
        // 檢查差值是否已在 map 中
        if idx, ok := m[complement]; ok {
            return []int{idx, i}
        }
        // 將當前數字存入 map
        m[v] = i
    }
    return nil
}
```

### R – Review（檢查與回顧）
- **Dry Run (`nums = [2, 7, 11, 15], target = 9`)**:
  - `i=0, v=2`: complement=7。Map 空，存入 `{2: 0}`。
  - `i=1, v=7`: complement=2。Map 中有 2 (索引 0)，回傳 `[0, 1]`。正確。
- **狀態轉換**：Map 動態增長，確保我們只會跟「之前出現過」的數字做比較，完美避開重複使用同一元素。

### E – Evaluate（總結與評估）
- **Time Complexity**: **O(n)**。只需遍歷陣列一次，Map 的查找與插入均為 O(1)。
- **Space Complexity**: **O(n)**。最差情況下需要將所有數字存入 Map。
- **Trade-offs**: 犧牲了空間（O(n)）來換取最快的時間（O(n)）。

---

## Output 2: 面試官口語回答腳本（精簡可直接說）

### 1️⃣ 開場：題目理解
這題是要在陣列中找到兩個數，相加等於給定的 `target`。比較關鍵的要求是每個輸入只有一個正確解，而且同一個元素不能重複用兩次。

### 2️⃣ 解法選擇說明
最直觀的方法是兩層迴圈的暴力破解，但時間複雜度是 O(n²)。我會選擇使用 **Hash Map** 來優化，這樣可以把查找的時間降到 O(1)，讓整體的效率提升到 **O(n)**。

### 3️⃣ 解題策略概覽
我會遍歷陣列一次，每遇到一個數字，就去算一下「還差多少（complement）」才能達到目標值。如果這個差值已經在 Map 裡面了，就代表找到了；如果還沒出現過，就把現在這個數字存進 Map，留給後面的數字匹配。

### 4️⃣ 寫程式時會補充的關鍵說明
在實作時，我會注意**先檢查再存入**。這樣可以確保我們不會誤用同一個索引兩次，例如當 target 是 6 而當前數字是 3 的時候。

### 5️⃣ 快速 Dry Run 說明
以 `[2, 7, 11, 15]` 目標 9 為例。第一個數字 2 進去時 Map 是空的，所以把 `2` 存起來。到第二個數字 7 時，差值是 2，這時發現 Map 裡已經有 2 了，就直接回傳它們的索引。

### 6️⃣ 收尾總結
這個解法在時間上非常高效，是 **O(n)**。雖然空間上因為用了 Map 需要 **O(n)** 的額外空間，但在現代面試中，這通常是時間與空間權衡下的最優解。
